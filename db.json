{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/c-by黑马.md","hash":"7f6def09bb7765a1873730aa5a053f720342b347","modified":1632801952504},{"_id":"source/_posts/ER.md","hash":"569b3e179017baba051206167cb8fd6da798a28e","modified":1632190426265},{"_id":"source/_posts/firstpost.md","hash":"da8e4a69882e84f434db2e97c2c35e3d13d8734b","modified":1631502948024},{"_id":"source/_posts/ttt.md","hash":"41ec00ea5b26edbd1e681939fd911791b96032b3","modified":1631502948024},{"_id":"source/_posts/anotest.md","hash":"81e1031889324394db269125f52d03235b4fceaf","modified":1631502948024},{"_id":"source/_posts/test.md","hash":"61520ee92b7f18a44354de975b9012e10f208f9c","modified":1631502948024},{"_id":"source/_posts/哲学.md","hash":"b6e296a5341e51f471047f3c997faed0f3c1769c","modified":1631502948024},{"_id":"source/_posts/感悟.md","hash":"eb6ec1b2c82d323be43ee9609e018ce070aed1cc","modified":1631502948024},{"_id":"source/_posts/唱歌.md","hash":"8a90bd92c91c49510333b8dfbc7743d5b7031aed","modified":1631502948024},{"_id":"source/_posts/计算机网络.md","hash":"69430bd2c5d3d4b1baa2e57aadd8b0474d0620e6","modified":1632466164184},{"_id":"source/_posts/阅读测试.md","hash":"e0fc27a558703f3be8524ce57329edfba3c0c1d8","modified":1631502948024},{"_id":"source/_posts/关于蕾塞.md","hash":"7ad196d3b74097dca5d5e077e5b27a6e6e230b10","modified":1631502948024},{"_id":"source/categories/index.md","hash":"9789c7abb89723096bef6cbcefe2afac3ba8b862","modified":1631502948024},{"_id":"source/哲学/index.md","hash":"1aec23e6bd2dc182d3999e701da4e89f548fc8a9","modified":1631502948024},{"_id":"source/学习/index.md","hash":"2ef9e67fccede8e8f9fa5442a56c80c810878559","modified":1631502948040},{"_id":"source/感悟/index.md","hash":"84d8ef9bbb65c495b9d684b81f4a6c1a6e54e564","modified":1631502948040},{"_id":"source/tags/index.md","hash":"a4efc5b703b2d784e0f9a8b79fd3cb2a1ceccbec","modified":1631502948024},{"_id":"source/唱歌/index.md","hash":"abc4a0a26acf8e81e1e9ee9c76edf864ee5531a8","modified":1631502948040},{"_id":"source/唱歌/唱歌的一些基本事项.md","hash":"0596af08f573db8c9e2c7ea0c4b866df41ac796b","modified":1631502948040},{"_id":"source/阅读/index.md","hash":"817758836376ab0a1dec24305ab88ae003cdcd1b","modified":1631502948040},{"_id":"source/篮球/index.md","hash":"cae5ce937b42630de2f57821accc0169a5a6237f","modified":1631502948040},{"_id":"source/_posts/数据结构.md","hash":"c02f652979f8c6150408d6077404175ca3991591","modified":1632659963833},{"_id":"themes/butterfly/package.json","hash":"f669d2cb43e2a64e9f1cfaecaab4957fc2c35571","modified":1631502948071},{"_id":"themes/butterfly/README_CN.md","hash":"70ec43a8aa0776b5a0a2a6b6009dd253fa3679eb","modified":1631502948040},{"_id":"themes/butterfly/_config.yml","hash":"8a32e571c2470d87d430f38833bc1e411ce50550","modified":1631502948040},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1631502948040},{"_id":"themes/butterfly/layout/category.pug","hash":"5ac3cd8172088843cec03175c612a9c85f49cf2e","modified":1631502948040},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1631502948040},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1631502948071},{"_id":"themes/butterfly/layout/page.pug","hash":"cae76ce64c114fd192b5da5a7d14aa0240df2f06","modified":1631502948071},{"_id":"themes/butterfly/README.md","hash":"0f0eaee9c30ef1e9aed588fbb3e8263401348b55","modified":1631502948040},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1631502948071},{"_id":"themes/butterfly/layout/post.pug","hash":"8f2f13c9ae099dd83827ce3dbac5abc8d7d5bde3","modified":1631502948071},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1631502948040},{"_id":"themes/butterfly/languages/default.yml","hash":"b9dbdb20bd1f1c7ca8a8f38635bdc4ed8bb1d44c","modified":1631502948040},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"46685048a05b419ed9c72cf31bd6e5efef7524f2","modified":1631502948040},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1631502948040},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"736bec8eeb3a29d0d43669d81f1fa686e02be18e","modified":1631502948040},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"3cdc5e32d0f1e5866bcf86f94a0d76aaf7142937","modified":1631502948040},{"_id":"themes/butterfly/languages/en.yml","hash":"fd1c1211c8f166d089a7697872185a81182d92e1","modified":1631502948040},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1631502948040},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"a1ca58fdff74b890cade94479f8f0eb9ce7e5e73","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f4dcc0a596eb9801c4d3c033d018d0abb413c8e5","modified":1631502948040},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1631502948087},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9b5243385f7a90e0103c25c531a1e7f2f1884c15","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1631502948055},{"_id":"themes/butterfly/source/css/var.styl","hash":"31198af95fecc6819d3b2cb7ef03988ef67257da","modified":1631502948087},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1631502948087},{"_id":"themes/butterfly/source/js/main.js","hash":"5daa345abeda9de55a9912c30944fe80c084a2bf","modified":1631502948102},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1631502948071},{"_id":"themes/butterfly/source/img/favicon.png","hash":"d89b6f076abb4a0c682d52aec17958baaa39a278","modified":1631502948087},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1631502948087},{"_id":"themes/butterfly/scripts/events/init.js","hash":"5803aa55d9c21e51ea64c1ae50c9b602979aaee2","modified":1631502948071},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"98ef86305b8d2ad9dbab969715e1ac93b407f036","modified":1631502948071},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1631502948071},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"bd29f20fad3d3fab600940e7a6dc9a803943cb33","modified":1631502948071},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1631502948071},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1631502948071},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"51112d3db07f87034422ff4acc69ca2eb4215b4e","modified":1631502948071},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"8cb7ef368cc2ac7f4a13c2959908b1574e572acf","modified":1631502948071},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"98ab13a60413d68bd9d02d54d121c66a6d4634d2","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1631502948071},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1631502948102},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1631502948071},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1631502948040},{"_id":"themes/butterfly/source/js/utils.js","hash":"1b8bf1e6d50fa8ffe2aff7548b141cab72540ba0","modified":1631502948102},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1631502948040},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1631502948087},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"73c04d62055840545112dd12d73807835ca62347","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"3ca9d9cdfd6e61df1d5b07de40f34349cda7a7c7","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"d6556d5396eb0e10ea0ec10158779c21dc78f738","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1d875b1d7a6cd521894cf31a68d441980a6ee103","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"4d52000cae1fce333329c382dac6c9a21ad0b195","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"419807903e5586b8804b1f8f17cea97bd05f0b17","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7677911bd3f43edaf8230eea02f60a248eee9934","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"dcccb1425fabcf12a1bed955518b0e7b1054cab0","modified":1631502948040},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"c762732e200ff2627bc046af5f170b3269343341","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"9aa743b1f6fb7fafabee38f9204ce9c8f1be7f9a","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"ad59dcce32e4e67066303a1ffd1dd95874d9953e","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"0f1a5c356c1ffd47ff49e153226e2d670dc61057","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"4a2ea9fe59f1dc8cb4f4f6a28cf24a40fc300254","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"6c3449a44ae1a80f71dd4d9d6a85cec1781ceff1","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e4c39101d7087066a86f7743985a53d6a246470b","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1631502948071},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1631502948087},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"03164bca4546707543828cb2a41bc672b77bfa5a","modified":1631502948071},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1631502948087},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2e8e391b211b2416d3c9430ab5361659c073f348","modified":1631502948087},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f9de9db2a49ac4d5447660ab159171ac5c228e3c","modified":1631502948071},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"23ea60f8becc91f6e9f6cfb1cbfd25689c263b9c","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"8c4e08c8a63dacdfb2a733a0d0035fa97c7f5e9e","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dd71e34edece4e06b59e941fb3cc5ad9a3ad09cf","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"db7fe645662d87be4f8dfc08e55bbe1a3734bf93","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"4ae98e703440b616d2a36da139bda844c94d425e","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"191ce31ce0f2b1d22a64225801a88cee6054f574","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"814729d1d71f4326623a4f34b621bf0421503103","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a00ad74074513a1c7f6e02977b8fa778beaa2108","modified":1631502948087},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"8489722684aa9b4baa38386f4d4b39f4dbd60113","modified":1631502948087},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"943aa34c83c87d0225db65ae90621870472972fa","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"87c576a3361f30eefafec27a872ad76e9fbb2765","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1631502948087},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"89a6cb63a97cc08675319c403e4a89391f6ab401","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"0da09b1811a776106ca66c56be6e2a396dca5680","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"48ad198d0ea97a25db4d2a3e587a16ef41617c0b","modified":1631502948087},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"25ac939fc57346de07ba9e15a1a760b492baefd7","modified":1631502948087},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1631502948087},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"5e5c1d6d104cc15314ae365d0da7cb07334a6457","modified":1631502948087},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"fa2985afd08556b25f5f1a01bc1a7c76b294a962","modified":1631502948087},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e65ed98056e6c91e622f94bad5283d00fdb22142","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"c91609b7f431cacecc3718ae2fb7403c55f8267a","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"c3369a14f4111c098d0177036ca57df6deb59d72","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1631502948087},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1631502948087},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1631502948055},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1631502948087},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1631502948102},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1631502948055},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1631502948102},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"50126b2e841b01584b8b65b2f834038e3997b694","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0bf6a47e804fb793b40f82690a24816b902edd41","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0254203aae73e70b90dfce6ec4f9c9d3be9ac9f8","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"e877c98949873a62659db7501d19eb3d66650b51","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"bce8cf20986d941ccabcf733f3952938523b03d6","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"8290994cf1ee2faff60214ff245cf513fbbe94aa","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"afffc4ac8ce93d39dcc892bd518805cf33531244","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"8890becd8220c57db2c7451409710942c103a7f4","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0ad766ae491e6fcba2ef3d136a7af6158cd4153e","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"a3d43cc360666b5b9730e8bb9e5c8fd940ae5b3d","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"767c38e3dfa0097b0dc1fdfd0df292c16f757d05","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1631502948071},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"83103bad0db195bce095330c4a84e7529bbd40dd","modified":1631502948055},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1631502948071},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"b0916c8c7d15b67b55cb1618be8370870fedbf42","modified":1631502948087},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b74c61f6e15b422e9d2df23133552bbd1b5fe513","modified":1631502948087},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"4d71aab9082c67d3ee52ad58dfc3c1c9b41f2ab1","modified":1631502948087},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1631502948087},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1631502948087},{"_id":"public/atom.xml","hash":"0a6cdd9fd98f38cb923ac301ef53273c0d7b25a3","modified":1632802088692},{"_id":"public/search.xml","hash":"bcfb3305a912d9960a15321e9babcfc73ce75876","modified":1632802088692},{"_id":"public/sitemap.xml","hash":"c5a3338f6a9cf66c5c693391edeac6bc2d302897","modified":1632802088692},{"_id":"public/404.html","hash":"1a040a07cc6dabe3fbd9e527a9b0290552c9ccdd","modified":1632802088692},{"_id":"public/2021/09/24/计算机网络/index.html","hash":"e35face38b70ab211142534beec07f8e05ed0353","modified":1632802088692},{"_id":"public/2021/09/07/test/index.html","hash":"1c13cb2a463cb7d189699a74a76153fdbf8080f3","modified":1632802088692},{"_id":"public/2021/08/07/唱歌/index.html","hash":"6ac579a67a63053b3c464352d94cb379d53376fd","modified":1632802088692},{"_id":"public/2021/08/04/阅读测试/index.html","hash":"836e842f2fcb0277961924a0c44a718aae206793","modified":1632802088692},{"_id":"public/2021/08/03/哲学/index.html","hash":"f7303cef13b9ba5524e8a80927f1b4e2e3522437","modified":1632802088692},{"_id":"public/2021/08/02/ttt/index.html","hash":"33b7e262130466ac5a1edbdf59ca2ac4efcb0418","modified":1632802088692},{"_id":"public/2021/08/02/感悟/index.html","hash":"500f86fae74571b8ce754bc45b7021dafef48036","modified":1632802088692},{"_id":"public/2021/07/29/anotest/index.html","hash":"f3f2a5d4bc008f3416a9f8d95e1a235ca185f05a","modified":1632802088692},{"_id":"public/2021/07/28/firstpost/index.html","hash":"44f4235e4c4417e0dd89ae20397777a1eb03cedc","modified":1632802088692},{"_id":"public/哲学/index.html","hash":"b958d73bfc41380175a8515658f11ad3e56be06b","modified":1632802088692},{"_id":"public/categories/index.html","hash":"43c49090e3f250903f687e9faf8be49d3fde0502","modified":1632802088692},{"_id":"public/学习/index.html","hash":"2109acd24de029286ee42733a750f56be12428b3","modified":1632802088692},{"_id":"public/感悟/index.html","hash":"a203c6ff45546178b080254e911db8663f1b02fb","modified":1632802088692},{"_id":"public/tags/index.html","hash":"cfb99e87cb90172e68e21bd56a05adb190289615","modified":1632802088692},{"_id":"public/唱歌/index.html","hash":"5110609b1f6636703e8fd9fc72a9b0fb97edace3","modified":1632802088692},{"_id":"public/唱歌/唱歌的一些基本事项.html","hash":"3304fb1b58814a8709779f0dcb73b1409ecd4518","modified":1632802088692},{"_id":"public/阅读/index.html","hash":"2746ef3d53f27cefb9a51d174c8bdd47ecdd65c5","modified":1632802088692},{"_id":"public/篮球/index.html","hash":"af03e2dbe7a1aafda5fa9425b063d92969194763","modified":1632802088692},{"_id":"public/2021/08/06/c-by黑马/index.html","hash":"ead78ac03ceb92943675768b8db7e032106660db","modified":1632802088692},{"_id":"public/2021/08/06/关于蕾塞/index.html","hash":"049ae05eba3f4d55942b83cc59715896b619313f","modified":1632802088692},{"_id":"public/2021/08/04/数据结构/index.html","hash":"cbc6d29251e14777939cc138b8df6866e7f41486","modified":1632802088692},{"_id":"public/2021/08/02/ER/index.html","hash":"90affda7c7628508675ef69c57f3d48f13846db7","modified":1632802088692},{"_id":"public/artitalk/index.html","hash":"de7ef8fc8c7e470f603c20e473957c1fffb1c0dd","modified":1632802088692},{"_id":"public/archives/index.html","hash":"c353fbef0cb148e410a9ee679229443596d05290","modified":1632802088692},{"_id":"public/archives/page/2/index.html","hash":"ef273744fa287d53213e3bece026a324e5445fa8","modified":1632802088692},{"_id":"public/archives/2021/index.html","hash":"e656fe2cfd24d1ff68590fefdbb2476b7135d3fc","modified":1632802088692},{"_id":"public/archives/2021/page/2/index.html","hash":"8f03bf8ef1860156914f7a014be2bfc3b4bc3245","modified":1632802088692},{"_id":"public/archives/2021/07/index.html","hash":"823f058415a5dbedd4788a8c5f030b0d67a89ae6","modified":1632802088692},{"_id":"public/archives/2021/08/index.html","hash":"2fa91e184cdcd4ccce65654e86eccfed306cabee","modified":1632802088692},{"_id":"public/archives/2021/09/index.html","hash":"87d02639f013244e2430dedd84c936421e70f349","modified":1632802088692},{"_id":"public/tags/唱歌/index.html","hash":"95c2ef9da2918383faf5610e5bdac8f4e85708b9","modified":1632802088692},{"_id":"public/tags/C/index.html","hash":"79233a0894c0fa4a524c55c67c3f9ee820dd33c6","modified":1632802088692},{"_id":"public/tags/数据结构/index.html","hash":"a5584cf7cc51e60bd4380f5a65e9bc69b4acdbb4","modified":1632802088692},{"_id":"public/index.html","hash":"c61db18bed055de2ad3d8957c2910a9f76ad56d2","modified":1632802088692},{"_id":"public/page/2/index.html","hash":"4472825889511dc30ff3094552c19e47a255c80c","modified":1632802088692},{"_id":"public/page/3/index.html","hash":"dd9ab832f1dce95800d089d4ea3f2f479809ab03","modified":1632802088692},{"_id":"public/categories/感悟/index.html","hash":"55641b5b9e27be0e1c2552bd78c422ead2cb6728","modified":1632802088692},{"_id":"public/categories/篮球/index.html","hash":"88952b0485b852a8e3b4acfd3d3919be397e8449","modified":1632802088692},{"_id":"public/categories/学习/index.html","hash":"edc1cd969dfb4faaa08603c103471eb203384422","modified":1632802088692},{"_id":"public/categories/哲学/index.html","hash":"1319cc4de31cd5bd6787fdcaa8e2c47390fa16e4","modified":1632802088692},{"_id":"public/categories/唱歌/index.html","hash":"f0986f1d5e2fdc1b559e3e11798531b78f1a1727","modified":1632802088692},{"_id":"public/categories/阅读/index.html","hash":"754c977d1b8b52e5c2a124b682a1e8e7cdd5bd83","modified":1632802088692},{"_id":"public/img/favicon.png","hash":"d89b6f076abb4a0c682d52aec17958baaa39a278","modified":1632802088692},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1632802088692},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1632802088692},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1632802088692},{"_id":"public/lib/hbe.js","hash":"2a6e18b7c37578f582a0acdc1ebc54d1e846b1a7","modified":1632802088692},{"_id":"public/css/hbe.style.css","hash":"f80457bac5f4bc67ae41733ee1ffb65d7b6ba1e8","modified":1632802088692},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632802088692},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1632802088692},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1632802088692},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1632802088692},{"_id":"public/css/index.css","hash":"e599df82f9c575fa49bed3731a8775ca4f0e85a8","modified":1632802088692},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1632802088692},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1632802088692}],"Category":[{"name":"感悟","_id":"cku3k7fll000480u62c5dhdw1"},{"name":"篮球","_id":"cku3k7flr000c80u66hmbaxg2"},{"name":"学习","_id":"cku3k7flv000j80u62jsed9wa"},{"name":"哲学","_id":"cku3k7fm0000w80u6hbg3eqe0"},{"name":"唱歌","_id":"cku3k7fm2001180u6fo6rckhd"},{"name":"阅读","_id":"cku3k7fm3001480u6b36qfx83"}],"Data":[],"Page":[{"title":"philosophy","date":"2021-08-02T05:03:02.000Z","_content":"","source":"哲学/index.md","raw":"---\ntitle: philosophy\ndate: 2021-08-02 13:03:02\n---\n","updated":"2021-09-13T03:15:48.024Z","path":"哲学/index.html","comments":1,"layout":"page","_id":"cku3k7fle000080u649ikeq8a","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"categories","date":"2021-07-29T03:20:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-07-29 11:20:00\ntype: \"categories\"\n---\n","updated":"2021-09-13T03:15:48.024Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cku3k7flj000280u612k0di03","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"study","date":"2021-08-02T05:02:46.000Z","_content":"","source":"学习/index.md","raw":"---\ntitle: study\ndate: 2021-08-02 13:02:46\n---\n","updated":"2021-09-13T03:15:48.040Z","path":"学习/index.html","comments":1,"layout":"page","_id":"cku3k7flm000580u67a5l4tek","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"selfthinking","date":"2021-08-02T06:00:41.000Z","_content":"","source":"感悟/index.md","raw":"---\ntitle: selfthinking\ndate: 2021-08-02 14:00:41\n---\n","updated":"2021-09-13T03:15:48.040Z","path":"感悟/index.html","comments":1,"layout":"page","_id":"cku3k7flo000780u60pcl6l1w","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"标签","date":"2021-07-29T03:00:30.000Z","type":"tags","_content":"\n \n\n学习\n\n","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-7-29 11:00:30\ntype: tags\n---\n\n \n\n学习\n\n","updated":"2021-09-13T03:15:48.024Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cku3k7flq000a80u62og6352g","content":"<p>学习</p>\n","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":"<p>学习</p>\n"},{"title":"singing","date":"2021-08-02T05:03:13.000Z","_content":"","source":"唱歌/index.md","raw":"---\ntitle: singing\ndate: 2021-08-02 13:03:13\n---\n","updated":"2021-09-13T03:15:48.040Z","path":"唱歌/index.html","comments":1,"layout":"page","_id":"cku3k7flr000d80u62zkp5jql","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"唱歌的一些基本事项","date":"2021-08-02T05:26:30.000Z","tags":null,"categories":"singing","sticky":1,"_content":"\n首先，要有正确的呼吸\n","source":"唱歌/唱歌的一些基本事项.md","raw":"---\ntitle: 唱歌的一些基本事项\ndate: 2021-08-02 13:26:30\ntags:\ncategories: singing\nsticky: 1\n---\n\n首先，要有正确的呼吸\n","updated":"2021-09-13T03:15:48.040Z","path":"唱歌/唱歌的一些基本事项.html","comments":1,"layout":"page","_id":"cku3k7fls000f80u6696o6d6e","content":"<p>首先，要有正确的呼吸</p>\n","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":"<p>首先，要有正确的呼吸</p>\n"},{"title":"read","date":"2021-08-02T05:03:24.000Z","_content":"","source":"阅读/index.md","raw":"---\ntitle: read\ndate: 2021-08-02 13:03:24\n---\n","updated":"2021-09-13T03:15:48.040Z","path":"阅读/index.html","comments":1,"layout":"page","_id":"cku3k7flv000l80u60vb9g00e","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"basketball","date":"2021-08-02T04:46:27.000Z","_content":"","source":"篮球/index.md","raw":"---\ntitle: basketball\ndate: 2021-08-02 12:46:27\n---\n","updated":"2021-09-13T03:15:48.040Z","path":"篮球/index.html","comments":1,"layout":"page","_id":"cku3k7flw000n80u6hw29hrju","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""}],"Post":[{"title":"每天都看","date":"2021-08-02T05:39:47.000Z","sticky":5,"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/ER.jpg","description":"每天都看","password":"young","message":"输入密码查看！","wrong_pass_message":"密码错误哦~","_content":"\n#### 缺点\n\n做一件事情不能坚持\n\n意志力不够坚定\n\n做事情没有养成习惯\n\n容易因为事情简单觉得没有必要就放弃\n\n到时间该做什么事情总是会给自己延长\n\n\n\n#### 需要怎么做\n\n要多想未来，未来想做什么，能不能获得足够的能力，能不能做自己想做的工作，能不能赚到足够多的钱\n\n要养成习惯，不能什么事情都心血来潮，每天都做才能持续获得进步\n\n要心态坚定，在什么时间应该做什么事情，就做什么事情，不要给自己找借口\n\n不要幻想自己的意志力足够强，能够按照自己的计划来，用物理的方法放下手机娱乐去学习\n\n","source":"_posts/ER.md","raw":"---\ntitle: 每天都看\ndate: 2021-08-02 13:39:47\ntags:\ncategories: 感悟\nsticky: 5\ncover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/ER.jpg\ndescription: 每天都看\npassword: young\nmessage: 输入密码查看！\nwrong_pass_message: 密码错误哦~\n---\n\n#### 缺点\n\n做一件事情不能坚持\n\n意志力不够坚定\n\n做事情没有养成习惯\n\n容易因为事情简单觉得没有必要就放弃\n\n到时间该做什么事情总是会给自己延长\n\n\n\n#### 需要怎么做\n\n要多想未来，未来想做什么，能不能获得足够的能力，能不能做自己想做的工作，能不能赚到足够多的钱\n\n要养成习惯，不能什么事情都心血来潮，每天都做才能持续获得进步\n\n要心态坚定，在什么时间应该做什么事情，就做什么事情，不要给自己找借口\n\n不要幻想自己的意志力足够强，能够按照自己的计划来，用物理的方法放下手机娱乐去学习\n\n","slug":"ER","published":1,"updated":"2021-09-21T02:13:46.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flh000180u6hsgngket","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"密码错误哦~\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\r\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"abad58065f5cc6fad7783d9671ce02ff5934b894a8ad9abf14b84b6e16b35a3e\">6adc09e8c8e9d40ea8a65820195e72f5d2f54460b07ef338a86057bb3cf04d95c687a176d368d7435564ee2120bec4e41b4ae7b71dd82c5c0058ffe648610196cab4c59f7b7d05dfad0dd5425a47bd7d0f264e49485e32ae671147177b435e79feb76dfef68db978f7004fa9a2bc7070754528ec973ac0d99082d88036d0853661c0f1ee41f3187b2ab32f3c3e87c20f0438a0deb21d8c1a7a33ff92b4115d82a7e4ffbf3a36c8be312039f619c62ea7915f624dbdd1a2a331032edcc6638210b179872aba9430508834564ea3041dab3977d1f71f117d9bc4de958b581f4e908f3157d0fe97473987e52150416dd80594b4381129382367f2c23c0dc166c3d7af2e27cd22f7d05be44b241484768a1030a91e9c05e127b890f09afe7b8c4edc01802cd6085c97ce8ffdfc19a8a9bb52a90d74fec8d66bd4c0e00ff9de93f8c7a8622876c475244cd8d5e0b72012b9686f708cd79a21bd93e885d7b04a87114db9a0e370b0fe75203a0de2953188f9b0b98ef13c52ed270dc7643ed7b078787d80d2d46f527314b28a9b6020440f868ae3a9166db2b3dc01f15a12b19dde903a421e9d275537af246b839ac1f2ebbf28a6b010bd7ad7938b3fb8a8fe187b29123420fd87bee8797c7c65752ec3661ea11f55d71f6645038c8ac9ef19b866e7d3f941083e19a14d5c53dbbb22ae13721482b929c45faf50ad6bdf3d52b39779e1e6989c8c745f8e8943b9ee384f14969c5789f01e780ade28d9bac72c3e52b5fd235ffd938c99cf99ffbdf062590215510c44ebeedf63d78cf82edd023e810119d4dbdad23096154304ac93fb0365cd75927bf37ea66e22926017d459c45a09ba64d5b378014e63949569494e9d20ffb99703c58089e486f1894aec6d9600d85c0c9feabcd725240ebdb9f0bdb7a7f27ab1c3e5baf3ccd089772453d82507b174e01e6f3c415e6980c111164a8e7de7e1f4495bf0ce7a70ba1365be834a7e381c9bc608641e25f24e81bb41da9db20f1fca220cf8c9f5c9038dff98eb1b52313866f453df84961cb1007890c9a1bf8260203d2ee197e8262a329c96f2d5c014041831ffac6274cff9576b1a6fc4d43a0062eeac0cd379ba210f4eb7507dc29fd14ca2a29625538a61361a3c0560fc243e1e86e27847dd5135c0922472e8248ac88332aef6830c14f0955ac10388b92ea7cd5be543145c676138ee677fa5feae61a50305bd6a03ea934d4d2b264c0194ec162eed093888f332adb984bac29f38d1b985dd46d36a1998051bf2bdf0f6392726ca01a4b6151c5279d3a6ce212cc99b</script>\r\n  <div class=\"hbe hbe-content\">\r\n    <div class=\"hbe hbe-input hbe-input-default\">\r\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\r\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\r\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入密码查看！</span>\r\n      </label>\r\n    </div>\r\n  </div>\r\n</div>\r\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>做一件事情不能坚持</p>\n<p>意志力不够坚定</p>\n<p>做事情没有养成习惯</p>\n<p>容易因为事情简单觉得没有必要就放弃</p>\n<p>到时间该做什么事情总是会给自己延长</p>\n<h4 id=\"需要怎么做\"><a href=\"#需要怎么做\" class=\"headerlink\" title=\"需要怎么做\"></a>需要怎么做</h4><p>要多想未来，未来想做什么，能不能获得足够的能力，能不能做自己想做的工作，能不能赚到足够多的钱</p>\n<p>要养成习惯，不能什么事情都心血来潮，每天都做才能持续获得进步</p>\n<p>要心态坚定，在什么时间应该做什么事情，就做什么事情，不要给自己找借口</p>\n<p>不要幻想自己的意志力足够强，能够按照自己的计划来，用物理的方法放下手机娱乐去学习</p>\n","encrypt":true},{"title":"firstpost","date":"2021-07-28T12:05:25.000Z","_content":"\n## Hello, world!\n\nhere is my first post.\n","source":"_posts/firstpost.md","raw":"---\ntitle: firstpost\ndate: 2021-07-28 20:05:25\ntags:\ncategories: 篮球\n---\n\n## Hello, world!\n\nhere is my first post.\n","slug":"firstpost","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flk000380u6akkdc6u7","content":"<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello, world!\"></a>Hello, world!</h2><p>here is my first post.</p>\n","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":"<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello, world!\"></a>Hello, world!</h2><p>here is my first post.</p>\n"},{"title":"anotest","date":"2021-07-29T13:24:44.000Z","_content":"","source":"_posts/anotest.md","raw":"---\ntitle: anotest\ndate: 2021-07-29 21:24:44\ntags: 唱歌\n---\n","slug":"anotest","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fln000680u678gtc64n","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"C++","date":"2021-08-06T08:26:49.000Z","description":"《黑马程序员》C++课程学习记录","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/a68df657aebc7e237a829501b24bb0f.jpg","_content":"\n## C++基础入门\n\n### 常量\n\n作用：用于记录程序中不可更改的数据\n\nC++中定义常量两种方式：\n\n1. #define 宏常量    ``define 常量名 常量值``\n\n   **通常在文件上方定义**，表示一个常量\n\n2. const 修饰的变量 ``const 数据类型 常量名 = 常量值``\n\n   **通常在变量定义前加上关键字const**，修饰该变量为常量，不可修改\n\n\n\n### sizeof关键字\n\n作用：统计数据类型所占内存的大小\n\n语法：``sizeof( 数据类型 / 变量 )``\n\n```c++\nsizeof（short）\n```\n\n\n\n### 数据类型\n\n#### 浮点型\n\n作用：表示小数\n\n1. 单精度float\n\n```C++\nfloat f1 = 3.14f;   //在使用的时候在数字后面加上一个f\n```\n\n2. 双精度double\n\n两者的**区别**在于表示的有效数字范围不同\n\n| 数据类型 | 占用空间 | 有效数字范围    |\n| -------- | -------- | --------------- |\n| float    | 4字节    | 7位有效数字     |\n| double   | 8字节    | 15~16位有效数字 |\n\n有效数字：第一个不为零的数字开始往后数，同时最后一位要四舍五入。\n\n**默认情况下，输出一个小数，会显示6位有效数字**\n\n\n\n* 科学计数法\n\n```c++\nfloat f2 = 3e2;   //3*10^2\nfloat f3 = 3e-2;  //3*(0.1)^2\n```\n\n\n\n#### 字符型\n\n作用：显示单个字符\n\n语法：``char ch = 'a'``\n\n* 用单引号括起来，不用双引号\n* 单引号内只能有一个字符，不能是字符串\n* 字符型变量只占用一个字节\n* 字符型变量是将字符对应的ASCII码放到存储单元中存储\n\n‘A’的ASCII码：65         \n\n‘a’的ASCII码：97\n\n\n\n#### 转义字符\n\n换行：``\\n``\n\n反斜杠：``\\\\``\n\n水平制表符：``\\t``   作用：在输出的时候可以让代码对齐\n\n\n\n#### 字符串型\n\n作用：用于表示一串字符\n\n1. C风格字符串：``char 变量名[] = \"字符串值\"``\n\n```c\nchar str1[] = \"hello world\";\n```\n\n2. C++风格字符串：``string 变量名 = \"字符串值\"``\n\n```c++\n#include <string>  //在C++风格字符串的时候，要包含这个文件\n\nstring str2 = \"Hello World\"\n```\n\n\n\n#### 布尔类型bool\n\n作用：布尔数据类型代表真或假的值\n\nbool类型只有两个值：\n\n* true ：真（本质是1）\n* false：假（本质是0）\n\n**bool类型只占用1个字节大小**\n\n```c++\nbool flag = true;\nbool flag = false;\n```\n\n\n\n### 运算符\n\n#### 取模运算\n\n#####  %：求余数\n\n* 两个数相除除数不能为0\n* 两个小数不能进行取模运算\n\n\n\n#### 三目运算符\n\n作用：通过三目运算符实现简单的判断\n\n语法：``表达式1 ？ 表达式2 ： 表达式3``\n\n解释：\n\n如果表达式1的值为真，执行表达式2，并返回结果；\n\n如果表达式1的值为假，执行表达式3，并返回结果。\n\n**在C++中，三目运算符返回的是变量，可以继续赋值**\n\n\n\n\n\n### 程序流程结构\n\n#### switch语句\n\n格式\n\n```c++\nswitch (整型/字符型)\n{\ncase n:\n   {xxxxx;}\t //如果代码很长的话要加花括号\n\tbreak;   //重点要记得写break语句\n.\n.\n.\ncase i:\n\txxxxx;\n\tbreak;\ndefault:\n\txxxxx;\n}\n\n```\n\nif 和 switch 的区别：\n\n* switch缺点：判断的时候只能是整型或者字符型，不能是一个区间\n* switch优点：结构清晰，执行效率高\n\n\n\n#### while循环\n\n随机数：\n\n```c++\n#include <ctime>    //头文件添加\n\n//添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样\nsrand((unsigned int)time(NULL));    \n\nint num = rand()% 100 + 1    //在0~100之间随机生成一个数\n```\n\n\n\n#### 跳转语句\n\n##### break语句\n\n作用：用于跳出**选择结构**或者**循环结构**\n\n使用的时机：\n\n* 出现在switch语句中，作用是终止case并跳出switch\n* 出现在循环语句中，作用是跳出当前的循环语句\n* 出现在嵌套循环中，跳出最近的内层循环语句\n\n\n\n##### continue语句\n\n作用：在**循环语句**中，跳过本次循环余下尚未执行的语句，继续执行下一次循环\n\n\n\n##### goto语句\n\n作用：可以无条件跳转语句\n\n语法：``goto 标记;``\n\n解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n\n```c++\n语句1；\n语句2；\ngoto FLAG；//运行到此时跳转到下方标记处\n语句3；\n语句4；\nFLAG；  \n语句5；\n```\n\n\n\n\n\n### 数组\n\n#### 一维数组\n\n一维数组名称用途：\n\n1. 可以统计整个数组在内存中的长度``sizeof(array)``\n2. 可以获取数组在内存中的首地址``可以通过cout << array直接得到``\n\n\n\n#### 冒泡排序\n\n**作用：**最常用的算法，对数组内的元素进行排序\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换这两个元素\n2. 对每一对相邻的元素做相同的工作，执行完一轮后，找到数组中最大的元素\n3. 重复以上步骤，每一轮后需要比较的次数减一，直到不需要比较\n\n**示例：**将数组{4，2，8，0，5，7，1，3，9} 进行升序排序\n\n```c++\nint main()\n{\n\tint arr[9] = {4,2,8,0,5,7,1,3,9};\n\t\n\tfor (int i = 0; i < 9 - 1; i++)  //最外层循环，一共要执行排序的轮次，元素数减1\n\t{\n\t\tfor (int j = 0; j < 9 - 1 - i; j++)   // 内层每对元素之间依次向后比较\n\t\t{\n\t\t\tif(arr[j] > arr[j+1])\t\t\t//比较交换\n\t\t\t{\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n#### 二维数组\n\n二维数组定义的四种方式：\n\n1. ``数据类型 数组名[ 行数 ][ 列数 ];``\n2. ``数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2} ，{数据3，数据4} };``\n3. ``数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4 };``\n4. ``数据类型 数组名[  ][ 列数 ] = { 数据1， 数据2， 数据3， 数据4 };``\n\n> 第二种更加直观，提高代码的可读性\n\n\n\n二维数组数组名\n\n* 查看二维数组所占程序空间\n* 获取二维数组首地址\n\n```c++\nsizeof(arr)        //查看二维数组占用内存空间\nsizeof(arr[0])     //查看二维数组第一行占用内存空间\nsizeof(arr[0][0])  //查看第一个元素占用内存空间\n\nsizeof(arr) / sizeof(arr[0])       //查看二维数组行数\nsizeof(arr[0]) / sizeof(arr[0][0]) //查看二维数组列数\n\ncout << (int)arr;     //查看二维数组首地址\ncout << (int)arr[0];  //查看二维数组第一行首地址   不强制转换为int的话就直接输出数据了\ncout << (int)arr[1];  //查看二维数组第二行首地址\n\ncout << (int)&arr[0][0]  //查看第一个元素首地址\ncout << (int)&arr[0][1]  //查看第二个元素首地址\n```\n\n\n\n\n\n### 函数\n\n#### 概述\n\n作用：将一段经常使用的代码封装起来，减少重复代码\n\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\n\n\n\n#### 函数的定义\n\n```\n返回值类型 函数名（参数列表）\n{\n\t函数体语句\n\t\n\treturn表达式\n}\n```\n\n\n\n#### 函数的调用\n\n语法： 函数名称（参数）\n\n\n\n#### 函数值传递\n\n函数的形参发生改变，并不会影响实参\n\n\n\n#### 函数的声明\n\n作用：告诉编译器函数名称及如何调用函数，函数的实际主题可以单独定义\n\n* 函数的声明可以有多次，但是函数的定义只能有一次\n\n\n\n#### 函数的分文件编写\n\n作用：让代码结构更加清晰\n\n步骤：\n\n1. 创建后缀名为.h的文件\n2. 创建后缀名为.cpp的源文件\n3. 在头文件中写函数的声明\n4. 在源文件中写函数的定义\n\n\n\n\n\n### 指针\n\n#### 指针的基本概念\n\n作用：可以通过指针间接访问内存\n\n\n\n#### 指针变量的定义和使用\n\n指针变量定义语法：``数据类型 * 变量名;``\n\n解引用： *p 取指针指向地址的值\n\n\n\n#### 指针所占内存空间\n\n各种类型的指针所占的内存空间相同\n\n在32位操作系统下占4个字节\n\n在64位操作系统下占8个字节\n\n\n\n#### 空指针\n\n指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n\n注意：空指针指向的内存是不可以访问的\n\n```c++\nint *p = NULL;\n```\n\n<font color=\"red\">0~255号内存编号是系统占用的，不可以访问</font>\n\n\n\n#### 野指针\n\n指针变量指向非法的内存空间\n\n<font color=\"red\">在程序中要避免出现野指针</font>\n\n\n\n#### const修饰指针\n\n1. const修饰指针     常量指针\n\n   * 特点：指针的指向可以修改，指针指向的值不可以修改\n\n   ```c++\n   const int *p;\n   ```\n\n2. const修饰常量     指针常量\n\n   * 特点：指针的指向不可以修改，指针指向的值可以修改\n\n   ```c++\n   int * const p;\n   ```\n\n3. const既修饰指针，又修饰常量\n\n   * 特点：指针的指向和指针指向的值都不可以修改\n\n   ```c++\n   const int * const p;\n   ```\n\n   \n\n\n\n#### 指针和数组\n\n利用指针访问数组中的元素\n\n```c++\nint arr[10] = {1,2,3,4,5,6,7,8,9,10};\n\nint *p = arr;\t//arr就是数组首地址\ncout<<*p<<endl;\t//输出数组中的第一个元素\n\np++;\t\t\t//指针向后偏移4个字节\ncout<<*p<<endl;\t//此时输出的是数组中的第二个元素\n```\n\n\n\n#### 指针和函数\n\n1. 值传递\n\n2. 地址传递\n\n   ```c++\n   void swap(int *p1,int *p2){\t//用指针来接收参数，因为参数是地址\n   \tint temp = *p1;\t\t\t//用星号来解引用\n   \t*p1 = *p2;\n   \t*p2 = temp;\n   }\n   \n   int main(){\n   \tint a = 10;\n   \tint b = 20;\n   \tswap(&a,&b);\t\t\t//传入地址\n   }\n   ```\n\n   \n\n\n\n### 结构体\n\n#### 结构体的基本概念\n\n结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n\n\n\n#### 结构体的定义和使用\n\n语法：``struct 结构体名 {结构体成员列表};``\n\n通过结构体创建变量的方式有三种：\n\n* struct 结构体名 变量名 (再通过   .成员名   来进行赋值 )\n* struct 结构体名 变量名 = {成员1值，成员2值……}\n* 定义结构体时顺便创建变量\n\n\n\n总结：\n\n1. 定义结构体时的关键字是struct，不能省略\n2. 创建结构体变量时，关键字struct可以省略\n\n\n\n#### 结构体数组\n\n作用：将自定义的结构体放入到数组中方便维护\n\n语法：``struct 结构体名 数组名[元素个数] = { {} , {} , {} , ...{} }``\n\n​\t\t\t在{}中就将数据元素的值全部定义完成\n\n<font color=\"red\">结构体数组传入函数参数中的是地址</font>\n\n\n\n#### 结构体指针\n\n作用：通过指针访问结构体中的成员\n\n* 利用操作符->可以通过结构体指针访问结构体属性\n\n\n\n#### 结构体嵌套结构体\n\n先定义被嵌套的结构体，然后再定义嵌套结构体\n\n访问的时候直接用两个 . 号来访问嵌套结构体中的内容\n\n\n\n#### 结构体做函数参数\n\n1. 值传递\n\n   ```c++\n   void printstudent1(struct student s){\n   \tcout<<s.name<<\" \"<<s.age<<\" \"<<s.score<<endl;\n   }\n   \n   struct student{\n   \tstring name;\n   \tint age;\n   \tint score;\n   };\n   \n   int main(){\n   \ts = ...;\n       printstudent1(s);\n   \t\n   \treturn 0;\n   }\n   ```\n\n2. 地址传递\n\n   ```c++\n   void printstudent2(struct student *p){\t\t\t\t//用一个指针来接收地址\n   \tcout<<p->name<<\" \"<<p->age<<\" \"<<p->score<<endl;\t//用箭头访问\n   }\n   \n   struct student{\n   \tstring name;\n   \tint age;\n   \tint score;\n   };\n   \n   int main(){\n   \ts = ...;\n       printstudent(&s);\n   \t\n   \treturn 0;\n   }\n   ```\n\n   \n\n#### 结构体中const使用场景\n\n作用：用const来防止误操作\n\n\n\n在用结构体做函数参数时，用地址传递，可以节省内存空间，而且不会复制一个新的副本出来\n\n```c++\nvoid printstudent(const student *p){\t//用const可以避免对数据进行误修改\n\tp->name = \"李四\";\t\t//此时修改不合法\n\tcout<<p->name;\n}\n```\n\n\n\n## C++核心编程\n\n针对C++面向对象编程技术\n\n\n\n### 内存分区模型\n\nC++程序在执行时，将内存大方向划分为四个区域\n\n* 代码区：存放函数体的二进制代码，由操作系统进行管理\n* 全局区：存放全局变量和静态变量以及常量\n* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期，使编程更灵活\n\n\n\n#### 程序运行前\n\n在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\n**代码区：**\n\n​\t\t存放CPU执行的机器指令\n\n​\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\n​\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\n**全局区：**\n\n​\t\t全局变量和静态变量存放在此\n\n​\t\t全局区还包括了常量区，字符串常量和其他常量也存放在此\n\n​\t\t该区域的数据在程序结束后由操作系统释放\n\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\n//全局变量，存放在全局区中\nint g_a = 10;\n\n//const修饰的全局变量，全局常量，存放在常量区中（全局区）\nconst int c_g_a = 10；\n\nint main(){\n    //局部变量，不在全局区中\n    int a = 10; \n    \n    //静态变量，存放在全局区中\n    static int s_a = 10;\n    \n    //常量\n    //字符串常量,存放在常量区（全局区）中\n    cout<<\"字符串常量的地址为：\"<<(int)&\"Hello world\"<<endl;\n   \t\n    //const修饰的变量\n    //const修饰的全局变量,存放在全局区中\n   \n    //const修饰的局部变量,局部常量，不存放在全局区中\n    const int c_l_a = 10;\n    \n}\n```\n\n\n\n#### 程序运行后\n\n**栈区：**\n\n​\t\t由编译器自动分配释放，存放函数的参数值，局部变量等\n\n​\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n```c++\nint* func(int b){\t//形参数据也会放在栈区\n    b = 100;\n\tint a = 10;\t//局部变量\n\treturn &a;\t//返回局部变量地址\n}\n\nint main(){\n\t//接收func函数的返回值\n    int *p = func();\n    \n    cout<<*p<<endl;\t//第一次可以打印是因为编译器做了保留\n    cout<<*p<<endl;\t//第二次数据不再保留\n}\n```\n\n\n\n**堆区：**\n\n​\t\t由程序员分配释放，若程序员不释放，程序结束时由操作系统回收\n\n​\t\t在C++中主要利用new在堆区开辟内存\n\n```c++\nint* func(){\n    //利用new关键字，可以将数据开辟到堆区\n    //指针 本质也是局部变量，放在栈上，指针保存的数据是放在堆区\n   int *p =  new int(10);\n   return p;\n}\n\nint main(){\n    int *p = func();\n    \n    return 0;\n}\n```\n\n\n\n#### new操作符\n\nC++中利用new操作符在堆区开辟数据\n\n堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete\n\n语法：``new 数据类型``\n\n利用new创建的数据，会返回该数据类型对应的类型的指针\n\n```c++\n//1、new的基本语法\nint * func(){\n    //在堆区创建整型数据\n    //new 返回是该数据类型的指针\n    \n    int *p = new int(10);\n    return p;\n}\n\nvoid test01(){\n    int *p = func();\n    cout<<*p<<endl;\n    //堆区的数据 由程序员开辟由程序员释放\n    //如果想释放堆区的数据，利用关键字delete\n    delete p;\n    //cout<<*p<<endl;//内存已经被释放，不能再次访问\n}\n\n//2、在堆区用new开辟数组\nvoid test02(){\n    //在堆区创建10个整型数据的数组\n    int * arr = new int[10];\t//10代表元素个数\n    \n    //释放堆区数组，要加入中括号\n    delete[] arr;\n}\nint main(){\n    void test01;\n    void test02;\n    \n    return 0;\n}\n```\n\n\n\n### 引用\n\n#### 引用的基本使用\n\n**作用：**给变量起别名\n\n**语法：**``数据类型 &别名 = 原名``\n\n```c++\nint a = 10;\nint &b = a;\n```\n\n\n\n#### 引用注意事项\n\n* 引用必须初始化\n\n```c++\nint &b; //错误\n```\n\n* 引用在初始化后不能发生改变\n\n\n\n#### 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n```c++\n//值传递,形参不改变实参\nvoid swap01(int a,int b){\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//地址传递\nvoid swap02(int *a,int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//引用传递,形参修饰实参\nvoid swap03(int &a,int &b){\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main(){\n\tswap01(a,b);\n\t\n\tswap02(&a,&b);\n\t\n\tswap03(a,b);\n}\n```\n\n\n\n#### 引用做函数返回值\n\n**注意：**不要返回局部变量的引用（与 内存分区模型-程序运行后-栈区 中的例子类似，不能返回局部变量的地址）\n\n```c++\nint& test01(){\n\tint a = 10; //局部变量，存放在栈区\n\treturn a;\n}\n\nint main(){\n    int &ref = test01();\t//test01函数的返回值也是引用类型  但是这种做法是错误的\n}\n```\n\n\n\n函数调用可以作为左值存在\n\n```c++\nint& test02(){\n\tstatic int a = 10;\t//静态变量，存放在全局区，程序结束后由系统释放\n\treturn a;\n}\n\nint main(){\n    int &ref = test02();\n    cout<<\"ref=\"<<ref<<endl;\n    \n    test02() = 1000;\t//函数返回变量的引用，相当于返回变量，相当于 a = 1000；\n}\n```\n\n\n\n#### 引用的本质\n\n**本质：**引用的本质在C++内部实现是一个指针常量\n\n```c++\nvoid func(int &ref){\n    ref = 100;\t//ref是引用，转换为*ref = 100；\n}\n\nint main(){\n    int a = 10;\n    \n    //自动转换为int * const ref = &a; 指针常量是指针的指向不能改，引用不能改的原因\n    int &ref = a;\n    ref = 20;\t//内部发现ref是引用，转换为 *ref = 20;\n}\n```\n\nC++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作都由编译器完成\n\n\n\n\n\n#### 常量引用\n\n**作用：**常量引用主要用来修饰形参，防止误操作（结构体-结构体中const使用场景类似）\n\n在函数参数列表中，可以加const修饰形参，防止形参改变实参\n\n```c++\nvoid ShowValue(const int& val){\n\t//val = 1000;\t如果形参中不加const 会对实参进行修改\n    cout<<\"val=\"<<val<<endl;\n}\n\nint main(){\n\tint a = 10;\n\tint &ref = 10;\t//错误，10在常量区，不是引用合法内存空间\n    int &ref = a;\t//正确\n    \n    //加上const之后，编译器将代码修改为 int temp = 10;int &ref = temp;\n    const int &ref = 10;\t\n    ref = 20;\t//错误，加入const后变为只读，不能修改\n    \n    \n    int a = 100;\n    ShowValue(a);\n}\n```\n\n\n\n\n\n\n\n### 函数提高\n\n#### 函数默认参数\n\n语法：``返回值类型 函数名 （形参 = 默认值）{}``\n\n```c++\nint func(int a,int b,int c = 10){\n\treturn a + b + c;\n}\n```\n\n注意事项：\n\n1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值\n\n2、如果函数的声明有了默认参数，函数实现就不能有默认参数（声明和实现只能一个有默认参数）\n\n```\nint func2(int a = 10,int b = 10);\t//函数声明\n\nint func2(int a,int b){\t\t\t\t//函数实现，此时就不能再用默认参数了\n\treturn a + b;\n}\n```\n\n\n\n#### 函数占位参数\n\n函数的形参列表中可以有占位参数，但是函数调用时必须填补该位置\n\n语法：``返回值类型 函数名 （数据类型） {}``\n\n占位参数可以有默认参数\n\n```c++\nvoid func(int a,int){\n\tcout<<\"this is func\"<<endl;\n}\n\n//占位参数有默认参数\nvoid func1(int a, int = 10){\n    ......;\n}\n```\n\n目前用不到，后面会用到\n\n\n\n\n\n#### 函数重载\n\n##### 函数重载概述\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下（全局、局部）\n* 函数名称相同\n* 函数参数 **类型不同** 或者**个数不同** 或者 **顺序不同**\n\n\n\n**注意：**函数的返回值不可以作为函数重载的条件\n\n\n\n##### 函数重载注意事项\n\n* 引用作为重载条件\n* 函数重载碰到默认参数\n\n```c++\n//1、引用作为重载的条件\nvoid func(int &a){\t//int &a = 10; 不合法，10在常量区\n\tcout<<\"func(int &a)调用\"<<endl;\n}\n\nvoid func(const int &a){\t//const int &a = 10; 编译器优化，创建临时空间，合法\n\tcout<<\"func(const int &a)调用\"<<endl;\n}\n\nint main(){\n    int a = 10;\n    func(a);\t//调用第一个函数\n    \n    func(10);\t//调用第二个函数\n}\n\n//2、函数重载碰到默认参数\nvoid func2(int a,int b = 10){\n    cout<<\"func2的调用\"<<endl;\n}\n\nvoid func2(int a){\n    cout<<\"func2的调用\"<<endl;\n}\n\nint main(){\n    func2(10);\t\t//错误，此时两个函数都能被调用，出现二义性，尽量避免\n}\t\t\t\t\t//函数重载时尽量不用默认参数\n```\n\n\n\n\n\n\n\n### 类和对象\n\nC++面向对象的三大特性为：封装、继承、多态\n\nC++认为万事万物都是对象，对象上有其属性和行为\n\n**例：**\n\n​\t人可以作为对象，属性有姓名、年龄、性别…行为有走、跑、跳、吃饭\n\n​\t车也可以作为对象，属性有轮胎、方向盘…行为有载人、开空调、放音乐\n\n​\t具有<font color=\"red\">相同性质的对象</font>，我们可以抽象为<font color=\"red\">类</font>，人属于人类，车属于车类\n\n\n\n#### 封装\n\n封装是C++面向对象的三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的食物\n* 对属性和行为加以权限控制\n\n\n\n##### **封装意义1**\n\n​\t在设计类的时候，行为和属性写在一起，表现事务\n\n**语法：**``class 类名 { 访问权限 ： 属性 / 行为 };``\n\n\n\n例：设计一个圆类，求圆的周长\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst double pi = 3.14;\n\nclass Circle{\n    //访问权限-公共权限\n    public:\n    \n    //类中的属性和行为，统一称为 成员\n    //属性\t成员属性 成员变量\n    //行为\t成员函数 成员方法\n    int m_r;\n    \n    //行为\n    //获取圆的周长\n    double calculateZC(){\n        return 2 * pi *m_r;\n    }\n};\t\t//记得分号\n\nint main(){\n    //通过圆类来创建一个具体的圆（对象）\n    //实例化（通过一个类，创建一个对象的过程）\n    Circle c1;\n    \n    //给圆对象 属性进行赋值操作\n    c1.m_r = 10;\n    \n    //获取圆的周长\n    cout<<\"圆的周长为：\"<<c1.calculateZC()<<endl;\n}\n```\n\n\n\n##### **封装意义2**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n1. public \t\t公共权限\n2. protected   保护权限\n3. private        私有权限\n\n\n\n示例：\n\n```c++\n//公共权限 public \t\t成员 类内可以访问 类外可以访问\n//保护权限 protected\t成员 类内可以访问 类外不可以访问 儿子可以访问父亲中保护内容\n//私有权限 private \t\t成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中私有内容\n\nclass Person{\nPublic:   \n    //公共权限\n    string m_Name;\t//姓名\n    \nProtected:\n    //保护权限\n    string m_car;\t//汽车\n    \nPrivate:\n    //私有权限\n    int password;\t//密码\n    \nPublic:\n    void func(){\n        m_Name = \"张三\";\n        m_Car = \"比亚迪\";\n        m_password = \"123456\";\n    }\n};\n\nint main(){\n    //实例化一个具体的对象\n    Person p1;\n    p1.m_Name = \"李四\";\t\t//可以访问\n    //p1.m_Car = \"奔驰\";\t\t//此时错误，保护权限在类外不可以访问\n    //p1.m_password = \"123\";\t\t//错误\n}\n```\n\n\n\n\n\nstruct和class的区别\n\n在C++中struct和class的唯一区别就在于 **默认的访问权限不同**\n\n区别：\n\n* struct默认权限为公共\n* class默认权限为私有\n\n```c++\nclass C1{\n  int m_A;\t//默认权限为私有  \n};\n\nstruct C2{\n    int m_A;\t//默认权限为公共\n};\n\nint main(){\n    C1 c1;\n    //c1.m_A = 100;\t//错误,权限为私有\n    C2 c2;\n    c2.m_A = 100;\t//正确，权限为公共\n}\n```\n\n\n\n\n\n##### 成员属性设置为私有\n\n**优点1：**将所有成员属性设置为私有，可以自己设置读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n示例：\n\n```c++\nclass Person{\nPublic:\n    \n    //设置姓名\n    void setName(string name){\n        m_Name = name;\n    }\n    //获取姓名\n    string getName(){\n        return m_Name;\n    }\n    \n    //获取年龄 可读可写\t如果想修改，年龄必须在0~150之间\n    int getAge(){\n        //m_Age = 0;\t//初始化为0岁\n        return m_Age;\n    }\n    \n    //设置年龄\n    void setAge(int age){\n        if(age < 0 || age > 150){\n            m_Age = 0;\n            cout<<\"年龄有误\"<<endl;\n            return ;\n        }\n        m_Age = age;\n    }\n    \n    //设置情人 只写\n    void setLover(string lover){\n        m_Lover = lover;\n    }\n    \nPrivate:\n    //姓名\t可读可写\n    String m_Name;\n    //年龄\t只读\n    int m_Age;\n    //伴侣\t只写\n    string m_Lover;\n};\n\nint main(){\n    Person p;\n    //p.m_Name = \"张三\";\t//错误 私有权限不能访问\n    p.setName(\"张三\");\t//正确 公共权限函数访问\n    cout<<\"姓名为：\"<<p.getName()<<endl;\n    \n    //p.m_Age = 18;\t\t//错误 私有权限不能访问\n    //p.setAge(18);\t\t//错误 没有这个函数\t\t\n    cout<<\"年龄为：\"<<p.getAge()<<endl; \n    \n    //设置情人\n    p.setLover(\"李四\");\n    //cout<<\"情人为：\"<<p.m_Lover<<endl;\t//错误 私有权限不能访问\n}\n```\n\n\n\n##### 头文件与源文件分离\n\n头文件.h中写函数定义\n\n```c++\n#pragma once\t\t//为了避免一个头文件被包含多次\n#include <iostream>\nusing namespace std;\n#include <xxx.h>\t//若其中使用到了其他类的内容，只需要包含所用类的头文件\n\nvoid func();\t\t//只做函数声明\n```\n\n\n\ncpp文件中写函数实现\n\n```c++\n#include <xxx.h>\n\nvoid xxx::func(){\t//xxx:: 说明是成员函数\n\t//函数实现\n}\n```\n\n\n\n\n\n\n\n#### 对象特性\n\nC++中的面对对象来源于生活，每个对象有初始设置和对象销毁前的清理数据的设置\n\n\n\n##### 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n​\t一个对象或者变量没有初始状态，对其使用后果是未知\n\n​\t同样的使用完一个对象或变量，没有即时清理，也会造成一定的安全问题\n\n\n\nC++利用构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器提供的构造和析构函数是空实现**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，由编译器自动调用，无须手动\n* 析构函数：主要作用在于对象**销毁前**自动调用，执行一些清理工作\n\n\n\n构造函数语法：``类名(){}``\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称和类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次\n5. 前面要写作用域\n\n\n\n析构函数语法：``~类名(){}``\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称和类名相同，在名称前面多加一个~\n3. 析构函数不能有参数，不能发生重载\n4. 程序在对象销毁前会自动调用析构，因此无须手动调用，而且只会调用一次\n\n\n\n\n\n##### 构造函数的分类及调用\n\n两种分类方式：\n\n​\t按参数分为：有参构造和无参构造\n\n​\t按类型分为：普通构造和拷贝构造\n\n三种调用方式：\n\n​\t括号法\n\n​\t显示法\n\n​\t隐式转换法\n\n\n\n分类\n\n```c++\nclass Person{\npublic:\t\n    Person(){\n        cout<<\"无参函数构造调用\"<<endl;\n    }\n    Person(int a){\n        age = a;\n        cout<<\"有参函数构造调用\"<<endl;\n    }\n    //拷贝构造函数\n    Person(const Person &p){\t//避免对p本身进行修改，结构体中const的应用 类似\n        //将传入的人身上的所有属性，拷贝到自身\n        age = p.age;\n        cout<<\"拷贝构造函数调用\"<<endl;\n    }\n    \n    ~Person(){\n        cout<<\"析构函数调用\"<<endl;\n    }\n};\n```\n\n\n\n\n\n调用\n\n```c++\nvoid test01(){\n\t//1、括号法\n    Person p1;\t//函数默认构造函数调用\n    Person p2(10);\t//有参构造函数\n    //拷贝构造函数调用\n    Person p3(p1);\n    \n    //注意事项1\n    //调用默认构造函数时，不要加括号（）\n    //Person p1();\t//这行代码会被认为是函数的声明，不会认为是在创建对象\n    \n    //2、显示法\n    Person p1;\n    Person p2 = Person(10);\t//有参构造\n    Person p3 = Person(p2);\t//拷贝构造\n    \n    Person(10);\t//匿名对象 特点，当前行执行结束后，系统会立即回收掉匿名对象\n    //注意事项2\n    //不要利用拷贝构造函数 初始化匿名对象 编译器会认为Person(p3) === Person(p3);\n    //编译器会认为是对象的声明\n    Person(p3);\n    \n    //3、隐式转换法\n    Person p4 = 10;\t//相当于写了 Person p4 = Person(10);\n    Person p5 = p4;\n}\n```\n\n\n\n##### 拷贝构造函数调用时机\n\nC++中拷贝函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n```c++\nclass Person{\npublic:\n    Person(){\n        cout<<\"Person的默认构造函数调用\"<<endl;;\n    }\n    \n    Peson(int age){\n        cout<<\"Person的有参构造函数调用\"<<endl;\n        m_Age = age;\n    }\n    \n    Person(const Person &p){\n        cout<<\"Person的拷贝构造函数调用\"<<endl;\n        m_Age = p.m_Age;\n    }\n    \n    ~Person(){\n        cout<<\"Person的析构函数调用\"<<endl;\n    }\n    \n    int m_Age;\n}\n\n//1.使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01(){\n    Person p1(20);\n    Person p2(p1);\n}\n\n//2.值传递的方式给函数参数传值\nvoid doWork(Person p){\n    \n}\n\nvoid test02(){\n    Person p;\n    doWork(p);\n}\n\n//3.值方式返回局部对象\nPerson doWork2(){\n    Person p1;\n    cout<<(int*)&p1<<endl;\n    return p1;\n}\n\nvoid test03(){\n\tPerson p = doWork2();\n    cout<<(int*)p <<endl;\n}\n```\n\n\n\n\n\n##### 构造函数的调用规则\n\n默认情况下，c++编译器至少给类添加三个函数\n\n1.默认构造函数（无参，函数体为空）\n\n2.默认析构函数（无参，函数体为空）\n\n3.默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则：\n\n* 如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造\n* 如果用户定义拷贝构造函数，c++不再提供其他构造函数\n\n\n\n```c++\n//构造函数的调用规则\n//1.创建一个类，c++编译器会给每个类都添加至少三个函数\n//默认构造 （空实现）\n//析构函数 （空实现）\n//拷贝构造 （值拷贝）\n    \n//2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造\n\n\nclass Person{\npublic:\n\tPerson()\n\t{\n\t\tcout << \"Person的默认构造函数调用\" << endl;\n\t}\n\n\tPerson(int age)\n\t{\n\t\tcout << \"Person的有参构造函数调用\" << endl;\n\t\tm_Age = age;\n\t}\n\n\tPerson(const Person &p)\n\t{\n\t\tcout << \"Person的拷贝构造函数调用\" << endl;\n\t\tm_Age = p.m_Age;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person的默认析构函数调用\" << endl;\n\t}\n\n\tint m_Age;\n\n};\n\nvoid test01()\n{\n\tPerson p;\n\tp.m_Age = 18;\n\n\tPerson p2(p);\n\n\tcout << \"p2的年龄是：\" << p2.m_Age << endl;\n}\n\n\nvoid test02()\n{\n    Person p;\t//如果有 有参构造函数定义，没有自己定义的默认构造函数，就会报错，因为\n    \t\t\t//此时系统也不会提供默认构造函数\n    \n}\n```\n\n\n\n\n\n##### 深拷贝和浅拷贝\n\n浅拷贝：简单的赋值拷贝操作\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n```c++\nclass Person{\npublic:\n\tPerson()\n\t{\n\t\tcout << \"Person的默认构造函数调用\" << endl;\n\t}\n\n\tPerson(int age, int height)\n\t{\n\t\tcout << \"Person的有参构造函数调用\" << endl;\n\t\tm_Age = age;\n        m_Height = new int(height);\n\t}\n    \n    //自己实现拷贝构造函数 解决浅拷贝带来的问题\n    Person(const Person &p)\n    {\n        cout<< \"Person 拷贝构造函数调用\"<<endl;\n        m_Age = p.m_Age;\n        //m_Height = p.m_Height;\t编译器默认实现就是这行代码\n        \n        //深拷贝操作\n        m_Height = new int(*p.m_Height);\t//解引用来获得m_Height的值\n    }\n\n\t//Person(const Person &p)\n\t//{\n\t//\t  cout << \"Person的拷贝构造函数调用\" << endl;\n\t//\t  m_Age = p.m_Age;\n\t//}\n\n\t~Person()\n\t{\n        //析构代码，将堆区开辟的数据做释放操作\n        if(m_Height != NULL)\n        {\n            delete m_Height;\n            m_Height = NULL;\t//防止野指针出现\n        }\n\t\tcout << \"Person的默认析构函数调用\" << endl;\n\t}\n\n\tint m_Age;\n    int *m_Height; //new新建开辟到堆区，用指针接收\n\n};\n\nvoid test01()\n{\n    Person p1(18,160);\n    cout<<\"p1的年龄为:\"<<p1.m_Age<<\"  身高为:\"<<p1.m_Height<<endl;\n    \n    Person p2(p1);\n    cout<<\"p2的年龄为:\"<<p2.m_Age<<\"  身高为:\"<<p2.m_Height<<endl;\n    //此时会出错 默认拷贝函数将 int *m_Height 中的全部内容拷贝过去\n    //p2 和 p1 在函数运行结束后都会进行析构函数释放 m_Height 内存的操作 \n    //重复释放，非法操作\n}\n```\n\n\n\n浅拷贝带来的问题就是堆区的内存重复释放\n\n<font color=\"red\"> 浅拷贝的问题，要利用深拷贝来进行解决</font>，即给使用拷贝构造的函数也申请一块新的内存空间\n\n\n\n**总结：**\n\n<font color=\"red\">如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</font>\n\n\n\n\n\n##### 初始化列表\n\n作用：用来初始化属性\n\n\n\n**语法：**`` 构造函数():属性1(值1)，属性2(值2)...{}``\n\n```c++\nclass Person\n{\npublic:\n    //传统初始化操作\n    Person(int a, int b, int c)\n    {\n        m_A = a;\n        m_B = b;\n        m_C = c;\n    }\n    \n    int m_A;\n    int m_B;\n    int m_C;\n    \n    //初始化列表初始化属性\n    Person():m_A(10),m_B(20).m_C(30)\n    {\n        \n    }\n    \n    //更灵活的方式初始化列表初始化属性\n    Person(int a, int b, int c):m_A(a),m_B(b).m_C(c)\n    {\n        \n    }\n};\n\n\t\n\nvoid test01(){\n    //Person p(10,20,30);\t普通构造\n    Person p;\t\t\t\t初始化列表构造\n    Person p(30,20,10);\t\t第三种构造\n    cout<<\"m_A = \"<<p.m_A<<endl;\n    cout<<\"m_B = \"<<p.m_B<<endl;\n    cout<<\"m_C = \"<<p.m_C<<endl;\n}\n```\n\n\n\n\n\n##### 类对象作为类成员\n\nC++中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```c++\nclass A{}\nclass B{\n\tA a;\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n```c++\nclass phone{\npublic:\n\tphone(string PName){\n\t\tm_PName = pName;\n\t}\n\t\n\tstring m_PName\n};\n\nclass Person{\npublic:\n    \n    //Phone m_Phone = pName;\t隐式转换法\n    Person(string name, string pName):m_Name(name),m_Phone(PName)\n    {\n        \n    }\n    \n\t//姓名\n\tstring m_Nname;\n\t//手机\n\tPhone m_Phone;\n};\n\nvoid test01(){\n    Person p(\"张三\",\"苹果\")；\n}\n```\n\n\n\n<font color=\"red\">其他类的对象作为本类的成员时，构造时候先构造类对象，再构造自身，析构的顺序与构造相反，先析构本类，然后在析构其他类</font>\n\n\n\n\n\n##### 静态成员和静态成员函数\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n* 静态成员变量\n  * 所有对象共享同一份数据\n  * 在编译阶段分配内存\n  * 类内声明，类外初始化\n* 静态成员函数\n  * 所有对象共享同一个函数\n  * 静态成员函数只能访问静态成员变量\n\n\n\n```c++\nclass Person{\npublic:\n\t\n\t//静态成员函数\n\tstatic void func()\n\t{\n        m_A = 100; //静态成员函数可以访问静态成员变量\n        //m_B = 200; //静态成员函数 不可以访问 非静态成员变量，无法区分到底是哪个对象的m_B属性\n\t\tcout<<\"static void func调用\"<<endl;\n\t}\n    \n    static int m_A;\t//静态成员变量\n    int m_B; //非静态成员变量\n    \n    //静态成员函数也是有访问权限的\nprivate:\n    static void func2(){\n        cout<<\"static void func2()调用\"<<endl;\n    }\n};\n\nint Person::m_A = 0; //类外初始化\n\n//两种访问方式\nvoid test01()\n{\n\t//1.通过对象访问\n    Person p;\n    p.func();\n    //2.通过类名访问\n    Person::func();\n    \n    //Person::func2();\t//类外访问不到私有静态成员函数\n}\n\nint main(){\n    test01;\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n#### C++对象模型和this指针\n\n##### 成员变量和成员函数分开存储\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n```c++\nclass Person{\n\n    \n    int m_A;\t//非静态成员变量 属于类的对象上 只要不是空，就是原大小\n    \n    static int m_B;\t//静态成员变量 不属于类的对象上\n    88\n    void func(){}\t//非静态成员函数 不属于类的对象上\n    \n    static void fun2(){}\t//静态成员函数 不属于类的对象上\n};\n\nvoid test01(){\n\tPerson p;\n\t//空对象占用空间内存空间为：1\n    //C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置\n    //每个空对象也应该有一个独一无二的内存地址\n\tcout<<\"size of p = \"<<sizeof(p)<<endl;\n}\n\nvoid test02(){\n    Person p;\n\tcout<<\"size of p = \"<<sizeof(p)<<endl;\n}\n\nint main(){\n\t//test01();\n    test02();\n}\n```\n\n\n\n\n\n##### this指针概念\n\n 每一个非静态成员函数只会诞生一份函数实例，即多个同类型的对象会共用同一块代码，那么这一块代码如何区分哪个对象调用自己呢？\n\n\n\nC++通过提供特殊的对象指针，this指针来解决该问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含在每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n* 当形参和成员变量同名时，可以用this指针来区分\n* 在类的非静态成员函数中返回对象本身，可以使用return *this\n\n\n\n```c++\nclass Person\n{\nPublic:\n\tPerson(int age)\n\t{\n\t\tage = age;\n\t}\n\t\n\tint age;\t//与构造函数中的参数相同了，应该加以区分 可以使用m_Age\n\t\t\t\t//m代表member\n\t\n\t//这里要加&符号 不加&代表以值的方式返回，会复制一份新的数据返回\n    //相当于返回的不是p2 而是p2'\t引用的方式不会创建新的对象\n    Person& PersonAddAge(Person &p){\n        this->age += p.age;\n        \n        //this是指向p2的指针，而*this指向的就是p2这个对象本体\n        return *this;\n    }\n\n};\t\t\t\t\n\n正确的写法：\nPublic:\n\tPerson(int age){\n        //this指针指向被调用的成员函数所属的对象\t这里this指向p1\n        this->age = age;\n    }\n\n//1.解决名称冲突\nvoid test01(){\n\tPerson p1(18);\n    cout<<\"p1的年龄为：\"<<p1.age<<endl;\n}\n\n//2.返回对象本身用 *this\t可以一直做追加操作\nvoid test02(){\n    Person p1(10);\n    \n    Person p2(10);\n    \n    //链式编程思想\n    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);\n    \n    cout<<\"p2的年龄为：\"<<p2.age<<endl;\n}\n\nint main(){\n    test01();\n    \n    test02();\n}\n\n```\n\n","source":"_posts/c-by黑马.md","raw":"---\ntitle: C++\ndate: 2021-08-06 16:26:49\ntags: C++\ncategories: 学习\ndescription: 《黑马程序员》C++课程学习记录\ncover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/a68df657aebc7e237a829501b24bb0f.jpg\n---\n\n## C++基础入门\n\n### 常量\n\n作用：用于记录程序中不可更改的数据\n\nC++中定义常量两种方式：\n\n1. #define 宏常量    ``define 常量名 常量值``\n\n   **通常在文件上方定义**，表示一个常量\n\n2. const 修饰的变量 ``const 数据类型 常量名 = 常量值``\n\n   **通常在变量定义前加上关键字const**，修饰该变量为常量，不可修改\n\n\n\n### sizeof关键字\n\n作用：统计数据类型所占内存的大小\n\n语法：``sizeof( 数据类型 / 变量 )``\n\n```c++\nsizeof（short）\n```\n\n\n\n### 数据类型\n\n#### 浮点型\n\n作用：表示小数\n\n1. 单精度float\n\n```C++\nfloat f1 = 3.14f;   //在使用的时候在数字后面加上一个f\n```\n\n2. 双精度double\n\n两者的**区别**在于表示的有效数字范围不同\n\n| 数据类型 | 占用空间 | 有效数字范围    |\n| -------- | -------- | --------------- |\n| float    | 4字节    | 7位有效数字     |\n| double   | 8字节    | 15~16位有效数字 |\n\n有效数字：第一个不为零的数字开始往后数，同时最后一位要四舍五入。\n\n**默认情况下，输出一个小数，会显示6位有效数字**\n\n\n\n* 科学计数法\n\n```c++\nfloat f2 = 3e2;   //3*10^2\nfloat f3 = 3e-2;  //3*(0.1)^2\n```\n\n\n\n#### 字符型\n\n作用：显示单个字符\n\n语法：``char ch = 'a'``\n\n* 用单引号括起来，不用双引号\n* 单引号内只能有一个字符，不能是字符串\n* 字符型变量只占用一个字节\n* 字符型变量是将字符对应的ASCII码放到存储单元中存储\n\n‘A’的ASCII码：65         \n\n‘a’的ASCII码：97\n\n\n\n#### 转义字符\n\n换行：``\\n``\n\n反斜杠：``\\\\``\n\n水平制表符：``\\t``   作用：在输出的时候可以让代码对齐\n\n\n\n#### 字符串型\n\n作用：用于表示一串字符\n\n1. C风格字符串：``char 变量名[] = \"字符串值\"``\n\n```c\nchar str1[] = \"hello world\";\n```\n\n2. C++风格字符串：``string 变量名 = \"字符串值\"``\n\n```c++\n#include <string>  //在C++风格字符串的时候，要包含这个文件\n\nstring str2 = \"Hello World\"\n```\n\n\n\n#### 布尔类型bool\n\n作用：布尔数据类型代表真或假的值\n\nbool类型只有两个值：\n\n* true ：真（本质是1）\n* false：假（本质是0）\n\n**bool类型只占用1个字节大小**\n\n```c++\nbool flag = true;\nbool flag = false;\n```\n\n\n\n### 运算符\n\n#### 取模运算\n\n#####  %：求余数\n\n* 两个数相除除数不能为0\n* 两个小数不能进行取模运算\n\n\n\n#### 三目运算符\n\n作用：通过三目运算符实现简单的判断\n\n语法：``表达式1 ？ 表达式2 ： 表达式3``\n\n解释：\n\n如果表达式1的值为真，执行表达式2，并返回结果；\n\n如果表达式1的值为假，执行表达式3，并返回结果。\n\n**在C++中，三目运算符返回的是变量，可以继续赋值**\n\n\n\n\n\n### 程序流程结构\n\n#### switch语句\n\n格式\n\n```c++\nswitch (整型/字符型)\n{\ncase n:\n   {xxxxx;}\t //如果代码很长的话要加花括号\n\tbreak;   //重点要记得写break语句\n.\n.\n.\ncase i:\n\txxxxx;\n\tbreak;\ndefault:\n\txxxxx;\n}\n\n```\n\nif 和 switch 的区别：\n\n* switch缺点：判断的时候只能是整型或者字符型，不能是一个区间\n* switch优点：结构清晰，执行效率高\n\n\n\n#### while循环\n\n随机数：\n\n```c++\n#include <ctime>    //头文件添加\n\n//添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样\nsrand((unsigned int)time(NULL));    \n\nint num = rand()% 100 + 1    //在0~100之间随机生成一个数\n```\n\n\n\n#### 跳转语句\n\n##### break语句\n\n作用：用于跳出**选择结构**或者**循环结构**\n\n使用的时机：\n\n* 出现在switch语句中，作用是终止case并跳出switch\n* 出现在循环语句中，作用是跳出当前的循环语句\n* 出现在嵌套循环中，跳出最近的内层循环语句\n\n\n\n##### continue语句\n\n作用：在**循环语句**中，跳过本次循环余下尚未执行的语句，继续执行下一次循环\n\n\n\n##### goto语句\n\n作用：可以无条件跳转语句\n\n语法：``goto 标记;``\n\n解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n\n```c++\n语句1；\n语句2；\ngoto FLAG；//运行到此时跳转到下方标记处\n语句3；\n语句4；\nFLAG；  \n语句5；\n```\n\n\n\n\n\n### 数组\n\n#### 一维数组\n\n一维数组名称用途：\n\n1. 可以统计整个数组在内存中的长度``sizeof(array)``\n2. 可以获取数组在内存中的首地址``可以通过cout << array直接得到``\n\n\n\n#### 冒泡排序\n\n**作用：**最常用的算法，对数组内的元素进行排序\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换这两个元素\n2. 对每一对相邻的元素做相同的工作，执行完一轮后，找到数组中最大的元素\n3. 重复以上步骤，每一轮后需要比较的次数减一，直到不需要比较\n\n**示例：**将数组{4，2，8，0，5，7，1，3，9} 进行升序排序\n\n```c++\nint main()\n{\n\tint arr[9] = {4,2,8,0,5,7,1,3,9};\n\t\n\tfor (int i = 0; i < 9 - 1; i++)  //最外层循环，一共要执行排序的轮次，元素数减1\n\t{\n\t\tfor (int j = 0; j < 9 - 1 - i; j++)   // 内层每对元素之间依次向后比较\n\t\t{\n\t\t\tif(arr[j] > arr[j+1])\t\t\t//比较交换\n\t\t\t{\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n#### 二维数组\n\n二维数组定义的四种方式：\n\n1. ``数据类型 数组名[ 行数 ][ 列数 ];``\n2. ``数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2} ，{数据3，数据4} };``\n3. ``数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4 };``\n4. ``数据类型 数组名[  ][ 列数 ] = { 数据1， 数据2， 数据3， 数据4 };``\n\n> 第二种更加直观，提高代码的可读性\n\n\n\n二维数组数组名\n\n* 查看二维数组所占程序空间\n* 获取二维数组首地址\n\n```c++\nsizeof(arr)        //查看二维数组占用内存空间\nsizeof(arr[0])     //查看二维数组第一行占用内存空间\nsizeof(arr[0][0])  //查看第一个元素占用内存空间\n\nsizeof(arr) / sizeof(arr[0])       //查看二维数组行数\nsizeof(arr[0]) / sizeof(arr[0][0]) //查看二维数组列数\n\ncout << (int)arr;     //查看二维数组首地址\ncout << (int)arr[0];  //查看二维数组第一行首地址   不强制转换为int的话就直接输出数据了\ncout << (int)arr[1];  //查看二维数组第二行首地址\n\ncout << (int)&arr[0][0]  //查看第一个元素首地址\ncout << (int)&arr[0][1]  //查看第二个元素首地址\n```\n\n\n\n\n\n### 函数\n\n#### 概述\n\n作用：将一段经常使用的代码封装起来，减少重复代码\n\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\n\n\n\n#### 函数的定义\n\n```\n返回值类型 函数名（参数列表）\n{\n\t函数体语句\n\t\n\treturn表达式\n}\n```\n\n\n\n#### 函数的调用\n\n语法： 函数名称（参数）\n\n\n\n#### 函数值传递\n\n函数的形参发生改变，并不会影响实参\n\n\n\n#### 函数的声明\n\n作用：告诉编译器函数名称及如何调用函数，函数的实际主题可以单独定义\n\n* 函数的声明可以有多次，但是函数的定义只能有一次\n\n\n\n#### 函数的分文件编写\n\n作用：让代码结构更加清晰\n\n步骤：\n\n1. 创建后缀名为.h的文件\n2. 创建后缀名为.cpp的源文件\n3. 在头文件中写函数的声明\n4. 在源文件中写函数的定义\n\n\n\n\n\n### 指针\n\n#### 指针的基本概念\n\n作用：可以通过指针间接访问内存\n\n\n\n#### 指针变量的定义和使用\n\n指针变量定义语法：``数据类型 * 变量名;``\n\n解引用： *p 取指针指向地址的值\n\n\n\n#### 指针所占内存空间\n\n各种类型的指针所占的内存空间相同\n\n在32位操作系统下占4个字节\n\n在64位操作系统下占8个字节\n\n\n\n#### 空指针\n\n指针变量指向内存中编号为0的空间\n\n用途：初始化指针变量\n\n注意：空指针指向的内存是不可以访问的\n\n```c++\nint *p = NULL;\n```\n\n<font color=\"red\">0~255号内存编号是系统占用的，不可以访问</font>\n\n\n\n#### 野指针\n\n指针变量指向非法的内存空间\n\n<font color=\"red\">在程序中要避免出现野指针</font>\n\n\n\n#### const修饰指针\n\n1. const修饰指针     常量指针\n\n   * 特点：指针的指向可以修改，指针指向的值不可以修改\n\n   ```c++\n   const int *p;\n   ```\n\n2. const修饰常量     指针常量\n\n   * 特点：指针的指向不可以修改，指针指向的值可以修改\n\n   ```c++\n   int * const p;\n   ```\n\n3. const既修饰指针，又修饰常量\n\n   * 特点：指针的指向和指针指向的值都不可以修改\n\n   ```c++\n   const int * const p;\n   ```\n\n   \n\n\n\n#### 指针和数组\n\n利用指针访问数组中的元素\n\n```c++\nint arr[10] = {1,2,3,4,5,6,7,8,9,10};\n\nint *p = arr;\t//arr就是数组首地址\ncout<<*p<<endl;\t//输出数组中的第一个元素\n\np++;\t\t\t//指针向后偏移4个字节\ncout<<*p<<endl;\t//此时输出的是数组中的第二个元素\n```\n\n\n\n#### 指针和函数\n\n1. 值传递\n\n2. 地址传递\n\n   ```c++\n   void swap(int *p1,int *p2){\t//用指针来接收参数，因为参数是地址\n   \tint temp = *p1;\t\t\t//用星号来解引用\n   \t*p1 = *p2;\n   \t*p2 = temp;\n   }\n   \n   int main(){\n   \tint a = 10;\n   \tint b = 20;\n   \tswap(&a,&b);\t\t\t//传入地址\n   }\n   ```\n\n   \n\n\n\n### 结构体\n\n#### 结构体的基本概念\n\n结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n\n\n\n#### 结构体的定义和使用\n\n语法：``struct 结构体名 {结构体成员列表};``\n\n通过结构体创建变量的方式有三种：\n\n* struct 结构体名 变量名 (再通过   .成员名   来进行赋值 )\n* struct 结构体名 变量名 = {成员1值，成员2值……}\n* 定义结构体时顺便创建变量\n\n\n\n总结：\n\n1. 定义结构体时的关键字是struct，不能省略\n2. 创建结构体变量时，关键字struct可以省略\n\n\n\n#### 结构体数组\n\n作用：将自定义的结构体放入到数组中方便维护\n\n语法：``struct 结构体名 数组名[元素个数] = { {} , {} , {} , ...{} }``\n\n​\t\t\t在{}中就将数据元素的值全部定义完成\n\n<font color=\"red\">结构体数组传入函数参数中的是地址</font>\n\n\n\n#### 结构体指针\n\n作用：通过指针访问结构体中的成员\n\n* 利用操作符->可以通过结构体指针访问结构体属性\n\n\n\n#### 结构体嵌套结构体\n\n先定义被嵌套的结构体，然后再定义嵌套结构体\n\n访问的时候直接用两个 . 号来访问嵌套结构体中的内容\n\n\n\n#### 结构体做函数参数\n\n1. 值传递\n\n   ```c++\n   void printstudent1(struct student s){\n   \tcout<<s.name<<\" \"<<s.age<<\" \"<<s.score<<endl;\n   }\n   \n   struct student{\n   \tstring name;\n   \tint age;\n   \tint score;\n   };\n   \n   int main(){\n   \ts = ...;\n       printstudent1(s);\n   \t\n   \treturn 0;\n   }\n   ```\n\n2. 地址传递\n\n   ```c++\n   void printstudent2(struct student *p){\t\t\t\t//用一个指针来接收地址\n   \tcout<<p->name<<\" \"<<p->age<<\" \"<<p->score<<endl;\t//用箭头访问\n   }\n   \n   struct student{\n   \tstring name;\n   \tint age;\n   \tint score;\n   };\n   \n   int main(){\n   \ts = ...;\n       printstudent(&s);\n   \t\n   \treturn 0;\n   }\n   ```\n\n   \n\n#### 结构体中const使用场景\n\n作用：用const来防止误操作\n\n\n\n在用结构体做函数参数时，用地址传递，可以节省内存空间，而且不会复制一个新的副本出来\n\n```c++\nvoid printstudent(const student *p){\t//用const可以避免对数据进行误修改\n\tp->name = \"李四\";\t\t//此时修改不合法\n\tcout<<p->name;\n}\n```\n\n\n\n## C++核心编程\n\n针对C++面向对象编程技术\n\n\n\n### 内存分区模型\n\nC++程序在执行时，将内存大方向划分为四个区域\n\n* 代码区：存放函数体的二进制代码，由操作系统进行管理\n* 全局区：存放全局变量和静态变量以及常量\n* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期，使编程更灵活\n\n\n\n#### 程序运行前\n\n在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\n**代码区：**\n\n​\t\t存放CPU执行的机器指令\n\n​\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\n​\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\n**全局区：**\n\n​\t\t全局变量和静态变量存放在此\n\n​\t\t全局区还包括了常量区，字符串常量和其他常量也存放在此\n\n​\t\t该区域的数据在程序结束后由操作系统释放\n\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\n//全局变量，存放在全局区中\nint g_a = 10;\n\n//const修饰的全局变量，全局常量，存放在常量区中（全局区）\nconst int c_g_a = 10；\n\nint main(){\n    //局部变量，不在全局区中\n    int a = 10; \n    \n    //静态变量，存放在全局区中\n    static int s_a = 10;\n    \n    //常量\n    //字符串常量,存放在常量区（全局区）中\n    cout<<\"字符串常量的地址为：\"<<(int)&\"Hello world\"<<endl;\n   \t\n    //const修饰的变量\n    //const修饰的全局变量,存放在全局区中\n   \n    //const修饰的局部变量,局部常量，不存放在全局区中\n    const int c_l_a = 10;\n    \n}\n```\n\n\n\n#### 程序运行后\n\n**栈区：**\n\n​\t\t由编译器自动分配释放，存放函数的参数值，局部变量等\n\n​\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n```c++\nint* func(int b){\t//形参数据也会放在栈区\n    b = 100;\n\tint a = 10;\t//局部变量\n\treturn &a;\t//返回局部变量地址\n}\n\nint main(){\n\t//接收func函数的返回值\n    int *p = func();\n    \n    cout<<*p<<endl;\t//第一次可以打印是因为编译器做了保留\n    cout<<*p<<endl;\t//第二次数据不再保留\n}\n```\n\n\n\n**堆区：**\n\n​\t\t由程序员分配释放，若程序员不释放，程序结束时由操作系统回收\n\n​\t\t在C++中主要利用new在堆区开辟内存\n\n```c++\nint* func(){\n    //利用new关键字，可以将数据开辟到堆区\n    //指针 本质也是局部变量，放在栈上，指针保存的数据是放在堆区\n   int *p =  new int(10);\n   return p;\n}\n\nint main(){\n    int *p = func();\n    \n    return 0;\n}\n```\n\n\n\n#### new操作符\n\nC++中利用new操作符在堆区开辟数据\n\n堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete\n\n语法：``new 数据类型``\n\n利用new创建的数据，会返回该数据类型对应的类型的指针\n\n```c++\n//1、new的基本语法\nint * func(){\n    //在堆区创建整型数据\n    //new 返回是该数据类型的指针\n    \n    int *p = new int(10);\n    return p;\n}\n\nvoid test01(){\n    int *p = func();\n    cout<<*p<<endl;\n    //堆区的数据 由程序员开辟由程序员释放\n    //如果想释放堆区的数据，利用关键字delete\n    delete p;\n    //cout<<*p<<endl;//内存已经被释放，不能再次访问\n}\n\n//2、在堆区用new开辟数组\nvoid test02(){\n    //在堆区创建10个整型数据的数组\n    int * arr = new int[10];\t//10代表元素个数\n    \n    //释放堆区数组，要加入中括号\n    delete[] arr;\n}\nint main(){\n    void test01;\n    void test02;\n    \n    return 0;\n}\n```\n\n\n\n### 引用\n\n#### 引用的基本使用\n\n**作用：**给变量起别名\n\n**语法：**``数据类型 &别名 = 原名``\n\n```c++\nint a = 10;\nint &b = a;\n```\n\n\n\n#### 引用注意事项\n\n* 引用必须初始化\n\n```c++\nint &b; //错误\n```\n\n* 引用在初始化后不能发生改变\n\n\n\n#### 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n```c++\n//值传递,形参不改变实参\nvoid swap01(int a,int b){\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//地址传递\nvoid swap02(int *a,int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//引用传递,形参修饰实参\nvoid swap03(int &a,int &b){\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main(){\n\tswap01(a,b);\n\t\n\tswap02(&a,&b);\n\t\n\tswap03(a,b);\n}\n```\n\n\n\n#### 引用做函数返回值\n\n**注意：**不要返回局部变量的引用（与 内存分区模型-程序运行后-栈区 中的例子类似，不能返回局部变量的地址）\n\n```c++\nint& test01(){\n\tint a = 10; //局部变量，存放在栈区\n\treturn a;\n}\n\nint main(){\n    int &ref = test01();\t//test01函数的返回值也是引用类型  但是这种做法是错误的\n}\n```\n\n\n\n函数调用可以作为左值存在\n\n```c++\nint& test02(){\n\tstatic int a = 10;\t//静态变量，存放在全局区，程序结束后由系统释放\n\treturn a;\n}\n\nint main(){\n    int &ref = test02();\n    cout<<\"ref=\"<<ref<<endl;\n    \n    test02() = 1000;\t//函数返回变量的引用，相当于返回变量，相当于 a = 1000；\n}\n```\n\n\n\n#### 引用的本质\n\n**本质：**引用的本质在C++内部实现是一个指针常量\n\n```c++\nvoid func(int &ref){\n    ref = 100;\t//ref是引用，转换为*ref = 100；\n}\n\nint main(){\n    int a = 10;\n    \n    //自动转换为int * const ref = &a; 指针常量是指针的指向不能改，引用不能改的原因\n    int &ref = a;\n    ref = 20;\t//内部发现ref是引用，转换为 *ref = 20;\n}\n```\n\nC++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作都由编译器完成\n\n\n\n\n\n#### 常量引用\n\n**作用：**常量引用主要用来修饰形参，防止误操作（结构体-结构体中const使用场景类似）\n\n在函数参数列表中，可以加const修饰形参，防止形参改变实参\n\n```c++\nvoid ShowValue(const int& val){\n\t//val = 1000;\t如果形参中不加const 会对实参进行修改\n    cout<<\"val=\"<<val<<endl;\n}\n\nint main(){\n\tint a = 10;\n\tint &ref = 10;\t//错误，10在常量区，不是引用合法内存空间\n    int &ref = a;\t//正确\n    \n    //加上const之后，编译器将代码修改为 int temp = 10;int &ref = temp;\n    const int &ref = 10;\t\n    ref = 20;\t//错误，加入const后变为只读，不能修改\n    \n    \n    int a = 100;\n    ShowValue(a);\n}\n```\n\n\n\n\n\n\n\n### 函数提高\n\n#### 函数默认参数\n\n语法：``返回值类型 函数名 （形参 = 默认值）{}``\n\n```c++\nint func(int a,int b,int c = 10){\n\treturn a + b + c;\n}\n```\n\n注意事项：\n\n1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值\n\n2、如果函数的声明有了默认参数，函数实现就不能有默认参数（声明和实现只能一个有默认参数）\n\n```\nint func2(int a = 10,int b = 10);\t//函数声明\n\nint func2(int a,int b){\t\t\t\t//函数实现，此时就不能再用默认参数了\n\treturn a + b;\n}\n```\n\n\n\n#### 函数占位参数\n\n函数的形参列表中可以有占位参数，但是函数调用时必须填补该位置\n\n语法：``返回值类型 函数名 （数据类型） {}``\n\n占位参数可以有默认参数\n\n```c++\nvoid func(int a,int){\n\tcout<<\"this is func\"<<endl;\n}\n\n//占位参数有默认参数\nvoid func1(int a, int = 10){\n    ......;\n}\n```\n\n目前用不到，后面会用到\n\n\n\n\n\n#### 函数重载\n\n##### 函数重载概述\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下（全局、局部）\n* 函数名称相同\n* 函数参数 **类型不同** 或者**个数不同** 或者 **顺序不同**\n\n\n\n**注意：**函数的返回值不可以作为函数重载的条件\n\n\n\n##### 函数重载注意事项\n\n* 引用作为重载条件\n* 函数重载碰到默认参数\n\n```c++\n//1、引用作为重载的条件\nvoid func(int &a){\t//int &a = 10; 不合法，10在常量区\n\tcout<<\"func(int &a)调用\"<<endl;\n}\n\nvoid func(const int &a){\t//const int &a = 10; 编译器优化，创建临时空间，合法\n\tcout<<\"func(const int &a)调用\"<<endl;\n}\n\nint main(){\n    int a = 10;\n    func(a);\t//调用第一个函数\n    \n    func(10);\t//调用第二个函数\n}\n\n//2、函数重载碰到默认参数\nvoid func2(int a,int b = 10){\n    cout<<\"func2的调用\"<<endl;\n}\n\nvoid func2(int a){\n    cout<<\"func2的调用\"<<endl;\n}\n\nint main(){\n    func2(10);\t\t//错误，此时两个函数都能被调用，出现二义性，尽量避免\n}\t\t\t\t\t//函数重载时尽量不用默认参数\n```\n\n\n\n\n\n\n\n### 类和对象\n\nC++面向对象的三大特性为：封装、继承、多态\n\nC++认为万事万物都是对象，对象上有其属性和行为\n\n**例：**\n\n​\t人可以作为对象，属性有姓名、年龄、性别…行为有走、跑、跳、吃饭\n\n​\t车也可以作为对象，属性有轮胎、方向盘…行为有载人、开空调、放音乐\n\n​\t具有<font color=\"red\">相同性质的对象</font>，我们可以抽象为<font color=\"red\">类</font>，人属于人类，车属于车类\n\n\n\n#### 封装\n\n封装是C++面向对象的三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的食物\n* 对属性和行为加以权限控制\n\n\n\n##### **封装意义1**\n\n​\t在设计类的时候，行为和属性写在一起，表现事务\n\n**语法：**``class 类名 { 访问权限 ： 属性 / 行为 };``\n\n\n\n例：设计一个圆类，求圆的周长\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst double pi = 3.14;\n\nclass Circle{\n    //访问权限-公共权限\n    public:\n    \n    //类中的属性和行为，统一称为 成员\n    //属性\t成员属性 成员变量\n    //行为\t成员函数 成员方法\n    int m_r;\n    \n    //行为\n    //获取圆的周长\n    double calculateZC(){\n        return 2 * pi *m_r;\n    }\n};\t\t//记得分号\n\nint main(){\n    //通过圆类来创建一个具体的圆（对象）\n    //实例化（通过一个类，创建一个对象的过程）\n    Circle c1;\n    \n    //给圆对象 属性进行赋值操作\n    c1.m_r = 10;\n    \n    //获取圆的周长\n    cout<<\"圆的周长为：\"<<c1.calculateZC()<<endl;\n}\n```\n\n\n\n##### **封装意义2**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n1. public \t\t公共权限\n2. protected   保护权限\n3. private        私有权限\n\n\n\n示例：\n\n```c++\n//公共权限 public \t\t成员 类内可以访问 类外可以访问\n//保护权限 protected\t成员 类内可以访问 类外不可以访问 儿子可以访问父亲中保护内容\n//私有权限 private \t\t成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中私有内容\n\nclass Person{\nPublic:   \n    //公共权限\n    string m_Name;\t//姓名\n    \nProtected:\n    //保护权限\n    string m_car;\t//汽车\n    \nPrivate:\n    //私有权限\n    int password;\t//密码\n    \nPublic:\n    void func(){\n        m_Name = \"张三\";\n        m_Car = \"比亚迪\";\n        m_password = \"123456\";\n    }\n};\n\nint main(){\n    //实例化一个具体的对象\n    Person p1;\n    p1.m_Name = \"李四\";\t\t//可以访问\n    //p1.m_Car = \"奔驰\";\t\t//此时错误，保护权限在类外不可以访问\n    //p1.m_password = \"123\";\t\t//错误\n}\n```\n\n\n\n\n\nstruct和class的区别\n\n在C++中struct和class的唯一区别就在于 **默认的访问权限不同**\n\n区别：\n\n* struct默认权限为公共\n* class默认权限为私有\n\n```c++\nclass C1{\n  int m_A;\t//默认权限为私有  \n};\n\nstruct C2{\n    int m_A;\t//默认权限为公共\n};\n\nint main(){\n    C1 c1;\n    //c1.m_A = 100;\t//错误,权限为私有\n    C2 c2;\n    c2.m_A = 100;\t//正确，权限为公共\n}\n```\n\n\n\n\n\n##### 成员属性设置为私有\n\n**优点1：**将所有成员属性设置为私有，可以自己设置读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n示例：\n\n```c++\nclass Person{\nPublic:\n    \n    //设置姓名\n    void setName(string name){\n        m_Name = name;\n    }\n    //获取姓名\n    string getName(){\n        return m_Name;\n    }\n    \n    //获取年龄 可读可写\t如果想修改，年龄必须在0~150之间\n    int getAge(){\n        //m_Age = 0;\t//初始化为0岁\n        return m_Age;\n    }\n    \n    //设置年龄\n    void setAge(int age){\n        if(age < 0 || age > 150){\n            m_Age = 0;\n            cout<<\"年龄有误\"<<endl;\n            return ;\n        }\n        m_Age = age;\n    }\n    \n    //设置情人 只写\n    void setLover(string lover){\n        m_Lover = lover;\n    }\n    \nPrivate:\n    //姓名\t可读可写\n    String m_Name;\n    //年龄\t只读\n    int m_Age;\n    //伴侣\t只写\n    string m_Lover;\n};\n\nint main(){\n    Person p;\n    //p.m_Name = \"张三\";\t//错误 私有权限不能访问\n    p.setName(\"张三\");\t//正确 公共权限函数访问\n    cout<<\"姓名为：\"<<p.getName()<<endl;\n    \n    //p.m_Age = 18;\t\t//错误 私有权限不能访问\n    //p.setAge(18);\t\t//错误 没有这个函数\t\t\n    cout<<\"年龄为：\"<<p.getAge()<<endl; \n    \n    //设置情人\n    p.setLover(\"李四\");\n    //cout<<\"情人为：\"<<p.m_Lover<<endl;\t//错误 私有权限不能访问\n}\n```\n\n\n\n##### 头文件与源文件分离\n\n头文件.h中写函数定义\n\n```c++\n#pragma once\t\t//为了避免一个头文件被包含多次\n#include <iostream>\nusing namespace std;\n#include <xxx.h>\t//若其中使用到了其他类的内容，只需要包含所用类的头文件\n\nvoid func();\t\t//只做函数声明\n```\n\n\n\ncpp文件中写函数实现\n\n```c++\n#include <xxx.h>\n\nvoid xxx::func(){\t//xxx:: 说明是成员函数\n\t//函数实现\n}\n```\n\n\n\n\n\n\n\n#### 对象特性\n\nC++中的面对对象来源于生活，每个对象有初始设置和对象销毁前的清理数据的设置\n\n\n\n##### 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n​\t一个对象或者变量没有初始状态，对其使用后果是未知\n\n​\t同样的使用完一个对象或变量，没有即时清理，也会造成一定的安全问题\n\n\n\nC++利用构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器提供的构造和析构函数是空实现**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，由编译器自动调用，无须手动\n* 析构函数：主要作用在于对象**销毁前**自动调用，执行一些清理工作\n\n\n\n构造函数语法：``类名(){}``\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称和类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次\n5. 前面要写作用域\n\n\n\n析构函数语法：``~类名(){}``\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称和类名相同，在名称前面多加一个~\n3. 析构函数不能有参数，不能发生重载\n4. 程序在对象销毁前会自动调用析构，因此无须手动调用，而且只会调用一次\n\n\n\n\n\n##### 构造函数的分类及调用\n\n两种分类方式：\n\n​\t按参数分为：有参构造和无参构造\n\n​\t按类型分为：普通构造和拷贝构造\n\n三种调用方式：\n\n​\t括号法\n\n​\t显示法\n\n​\t隐式转换法\n\n\n\n分类\n\n```c++\nclass Person{\npublic:\t\n    Person(){\n        cout<<\"无参函数构造调用\"<<endl;\n    }\n    Person(int a){\n        age = a;\n        cout<<\"有参函数构造调用\"<<endl;\n    }\n    //拷贝构造函数\n    Person(const Person &p){\t//避免对p本身进行修改，结构体中const的应用 类似\n        //将传入的人身上的所有属性，拷贝到自身\n        age = p.age;\n        cout<<\"拷贝构造函数调用\"<<endl;\n    }\n    \n    ~Person(){\n        cout<<\"析构函数调用\"<<endl;\n    }\n};\n```\n\n\n\n\n\n调用\n\n```c++\nvoid test01(){\n\t//1、括号法\n    Person p1;\t//函数默认构造函数调用\n    Person p2(10);\t//有参构造函数\n    //拷贝构造函数调用\n    Person p3(p1);\n    \n    //注意事项1\n    //调用默认构造函数时，不要加括号（）\n    //Person p1();\t//这行代码会被认为是函数的声明，不会认为是在创建对象\n    \n    //2、显示法\n    Person p1;\n    Person p2 = Person(10);\t//有参构造\n    Person p3 = Person(p2);\t//拷贝构造\n    \n    Person(10);\t//匿名对象 特点，当前行执行结束后，系统会立即回收掉匿名对象\n    //注意事项2\n    //不要利用拷贝构造函数 初始化匿名对象 编译器会认为Person(p3) === Person(p3);\n    //编译器会认为是对象的声明\n    Person(p3);\n    \n    //3、隐式转换法\n    Person p4 = 10;\t//相当于写了 Person p4 = Person(10);\n    Person p5 = p4;\n}\n```\n\n\n\n##### 拷贝构造函数调用时机\n\nC++中拷贝函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n```c++\nclass Person{\npublic:\n    Person(){\n        cout<<\"Person的默认构造函数调用\"<<endl;;\n    }\n    \n    Peson(int age){\n        cout<<\"Person的有参构造函数调用\"<<endl;\n        m_Age = age;\n    }\n    \n    Person(const Person &p){\n        cout<<\"Person的拷贝构造函数调用\"<<endl;\n        m_Age = p.m_Age;\n    }\n    \n    ~Person(){\n        cout<<\"Person的析构函数调用\"<<endl;\n    }\n    \n    int m_Age;\n}\n\n//1.使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01(){\n    Person p1(20);\n    Person p2(p1);\n}\n\n//2.值传递的方式给函数参数传值\nvoid doWork(Person p){\n    \n}\n\nvoid test02(){\n    Person p;\n    doWork(p);\n}\n\n//3.值方式返回局部对象\nPerson doWork2(){\n    Person p1;\n    cout<<(int*)&p1<<endl;\n    return p1;\n}\n\nvoid test03(){\n\tPerson p = doWork2();\n    cout<<(int*)p <<endl;\n}\n```\n\n\n\n\n\n##### 构造函数的调用规则\n\n默认情况下，c++编译器至少给类添加三个函数\n\n1.默认构造函数（无参，函数体为空）\n\n2.默认析构函数（无参，函数体为空）\n\n3.默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则：\n\n* 如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造\n* 如果用户定义拷贝构造函数，c++不再提供其他构造函数\n\n\n\n```c++\n//构造函数的调用规则\n//1.创建一个类，c++编译器会给每个类都添加至少三个函数\n//默认构造 （空实现）\n//析构函数 （空实现）\n//拷贝构造 （值拷贝）\n    \n//2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造\n\n\nclass Person{\npublic:\n\tPerson()\n\t{\n\t\tcout << \"Person的默认构造函数调用\" << endl;\n\t}\n\n\tPerson(int age)\n\t{\n\t\tcout << \"Person的有参构造函数调用\" << endl;\n\t\tm_Age = age;\n\t}\n\n\tPerson(const Person &p)\n\t{\n\t\tcout << \"Person的拷贝构造函数调用\" << endl;\n\t\tm_Age = p.m_Age;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person的默认析构函数调用\" << endl;\n\t}\n\n\tint m_Age;\n\n};\n\nvoid test01()\n{\n\tPerson p;\n\tp.m_Age = 18;\n\n\tPerson p2(p);\n\n\tcout << \"p2的年龄是：\" << p2.m_Age << endl;\n}\n\n\nvoid test02()\n{\n    Person p;\t//如果有 有参构造函数定义，没有自己定义的默认构造函数，就会报错，因为\n    \t\t\t//此时系统也不会提供默认构造函数\n    \n}\n```\n\n\n\n\n\n##### 深拷贝和浅拷贝\n\n浅拷贝：简单的赋值拷贝操作\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n```c++\nclass Person{\npublic:\n\tPerson()\n\t{\n\t\tcout << \"Person的默认构造函数调用\" << endl;\n\t}\n\n\tPerson(int age, int height)\n\t{\n\t\tcout << \"Person的有参构造函数调用\" << endl;\n\t\tm_Age = age;\n        m_Height = new int(height);\n\t}\n    \n    //自己实现拷贝构造函数 解决浅拷贝带来的问题\n    Person(const Person &p)\n    {\n        cout<< \"Person 拷贝构造函数调用\"<<endl;\n        m_Age = p.m_Age;\n        //m_Height = p.m_Height;\t编译器默认实现就是这行代码\n        \n        //深拷贝操作\n        m_Height = new int(*p.m_Height);\t//解引用来获得m_Height的值\n    }\n\n\t//Person(const Person &p)\n\t//{\n\t//\t  cout << \"Person的拷贝构造函数调用\" << endl;\n\t//\t  m_Age = p.m_Age;\n\t//}\n\n\t~Person()\n\t{\n        //析构代码，将堆区开辟的数据做释放操作\n        if(m_Height != NULL)\n        {\n            delete m_Height;\n            m_Height = NULL;\t//防止野指针出现\n        }\n\t\tcout << \"Person的默认析构函数调用\" << endl;\n\t}\n\n\tint m_Age;\n    int *m_Height; //new新建开辟到堆区，用指针接收\n\n};\n\nvoid test01()\n{\n    Person p1(18,160);\n    cout<<\"p1的年龄为:\"<<p1.m_Age<<\"  身高为:\"<<p1.m_Height<<endl;\n    \n    Person p2(p1);\n    cout<<\"p2的年龄为:\"<<p2.m_Age<<\"  身高为:\"<<p2.m_Height<<endl;\n    //此时会出错 默认拷贝函数将 int *m_Height 中的全部内容拷贝过去\n    //p2 和 p1 在函数运行结束后都会进行析构函数释放 m_Height 内存的操作 \n    //重复释放，非法操作\n}\n```\n\n\n\n浅拷贝带来的问题就是堆区的内存重复释放\n\n<font color=\"red\"> 浅拷贝的问题，要利用深拷贝来进行解决</font>，即给使用拷贝构造的函数也申请一块新的内存空间\n\n\n\n**总结：**\n\n<font color=\"red\">如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</font>\n\n\n\n\n\n##### 初始化列表\n\n作用：用来初始化属性\n\n\n\n**语法：**`` 构造函数():属性1(值1)，属性2(值2)...{}``\n\n```c++\nclass Person\n{\npublic:\n    //传统初始化操作\n    Person(int a, int b, int c)\n    {\n        m_A = a;\n        m_B = b;\n        m_C = c;\n    }\n    \n    int m_A;\n    int m_B;\n    int m_C;\n    \n    //初始化列表初始化属性\n    Person():m_A(10),m_B(20).m_C(30)\n    {\n        \n    }\n    \n    //更灵活的方式初始化列表初始化属性\n    Person(int a, int b, int c):m_A(a),m_B(b).m_C(c)\n    {\n        \n    }\n};\n\n\t\n\nvoid test01(){\n    //Person p(10,20,30);\t普通构造\n    Person p;\t\t\t\t初始化列表构造\n    Person p(30,20,10);\t\t第三种构造\n    cout<<\"m_A = \"<<p.m_A<<endl;\n    cout<<\"m_B = \"<<p.m_B<<endl;\n    cout<<\"m_C = \"<<p.m_C<<endl;\n}\n```\n\n\n\n\n\n##### 类对象作为类成员\n\nC++中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```c++\nclass A{}\nclass B{\n\tA a;\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n```c++\nclass phone{\npublic:\n\tphone(string PName){\n\t\tm_PName = pName;\n\t}\n\t\n\tstring m_PName\n};\n\nclass Person{\npublic:\n    \n    //Phone m_Phone = pName;\t隐式转换法\n    Person(string name, string pName):m_Name(name),m_Phone(PName)\n    {\n        \n    }\n    \n\t//姓名\n\tstring m_Nname;\n\t//手机\n\tPhone m_Phone;\n};\n\nvoid test01(){\n    Person p(\"张三\",\"苹果\")；\n}\n```\n\n\n\n<font color=\"red\">其他类的对象作为本类的成员时，构造时候先构造类对象，再构造自身，析构的顺序与构造相反，先析构本类，然后在析构其他类</font>\n\n\n\n\n\n##### 静态成员和静态成员函数\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n* 静态成员变量\n  * 所有对象共享同一份数据\n  * 在编译阶段分配内存\n  * 类内声明，类外初始化\n* 静态成员函数\n  * 所有对象共享同一个函数\n  * 静态成员函数只能访问静态成员变量\n\n\n\n```c++\nclass Person{\npublic:\n\t\n\t//静态成员函数\n\tstatic void func()\n\t{\n        m_A = 100; //静态成员函数可以访问静态成员变量\n        //m_B = 200; //静态成员函数 不可以访问 非静态成员变量，无法区分到底是哪个对象的m_B属性\n\t\tcout<<\"static void func调用\"<<endl;\n\t}\n    \n    static int m_A;\t//静态成员变量\n    int m_B; //非静态成员变量\n    \n    //静态成员函数也是有访问权限的\nprivate:\n    static void func2(){\n        cout<<\"static void func2()调用\"<<endl;\n    }\n};\n\nint Person::m_A = 0; //类外初始化\n\n//两种访问方式\nvoid test01()\n{\n\t//1.通过对象访问\n    Person p;\n    p.func();\n    //2.通过类名访问\n    Person::func();\n    \n    //Person::func2();\t//类外访问不到私有静态成员函数\n}\n\nint main(){\n    test01;\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n#### C++对象模型和this指针\n\n##### 成员变量和成员函数分开存储\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n```c++\nclass Person{\n\n    \n    int m_A;\t//非静态成员变量 属于类的对象上 只要不是空，就是原大小\n    \n    static int m_B;\t//静态成员变量 不属于类的对象上\n    88\n    void func(){}\t//非静态成员函数 不属于类的对象上\n    \n    static void fun2(){}\t//静态成员函数 不属于类的对象上\n};\n\nvoid test01(){\n\tPerson p;\n\t//空对象占用空间内存空间为：1\n    //C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置\n    //每个空对象也应该有一个独一无二的内存地址\n\tcout<<\"size of p = \"<<sizeof(p)<<endl;\n}\n\nvoid test02(){\n    Person p;\n\tcout<<\"size of p = \"<<sizeof(p)<<endl;\n}\n\nint main(){\n\t//test01();\n    test02();\n}\n```\n\n\n\n\n\n##### this指针概念\n\n 每一个非静态成员函数只会诞生一份函数实例，即多个同类型的对象会共用同一块代码，那么这一块代码如何区分哪个对象调用自己呢？\n\n\n\nC++通过提供特殊的对象指针，this指针来解决该问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含在每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n* 当形参和成员变量同名时，可以用this指针来区分\n* 在类的非静态成员函数中返回对象本身，可以使用return *this\n\n\n\n```c++\nclass Person\n{\nPublic:\n\tPerson(int age)\n\t{\n\t\tage = age;\n\t}\n\t\n\tint age;\t//与构造函数中的参数相同了，应该加以区分 可以使用m_Age\n\t\t\t\t//m代表member\n\t\n\t//这里要加&符号 不加&代表以值的方式返回，会复制一份新的数据返回\n    //相当于返回的不是p2 而是p2'\t引用的方式不会创建新的对象\n    Person& PersonAddAge(Person &p){\n        this->age += p.age;\n        \n        //this是指向p2的指针，而*this指向的就是p2这个对象本体\n        return *this;\n    }\n\n};\t\t\t\t\n\n正确的写法：\nPublic:\n\tPerson(int age){\n        //this指针指向被调用的成员函数所属的对象\t这里this指向p1\n        this->age = age;\n    }\n\n//1.解决名称冲突\nvoid test01(){\n\tPerson p1(18);\n    cout<<\"p1的年龄为：\"<<p1.age<<endl;\n}\n\n//2.返回对象本身用 *this\t可以一直做追加操作\nvoid test02(){\n    Person p1(10);\n    \n    Person p2(10);\n    \n    //链式编程思想\n    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);\n    \n    cout<<\"p2的年龄为：\"<<p2.age<<endl;\n}\n\nint main(){\n    test01();\n    \n    test02();\n}\n\n```\n\n","slug":"c-by黑马","published":1,"updated":"2021-09-28T04:05:52.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flo000880u64nhyalic","content":"<h2 id=\"C-基础入门\"><a href=\"#C-基础入门\" class=\"headerlink\" title=\"C++基础入门\"></a>C++基础入门</h2><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>作用：用于记录程序中不可更改的数据</p>\n<p>C++中定义常量两种方式：</p>\n<ol>\n<li><p>#define 宏常量    <code>define 常量名 常量值</code></p>\n<p><strong>通常在文件上方定义</strong>，表示一个常量</p>\n</li>\n<li><p>const 修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>\n<p><strong>通常在变量定义前加上关键字const</strong>，修饰该变量为常量，不可修改</p>\n</li>\n</ol>\n<h3 id=\"sizeof关键字\"><a href=\"#sizeof关键字\" class=\"headerlink\" title=\"sizeof关键字\"></a>sizeof关键字</h3><p>作用：统计数据类型所占内存的大小</p>\n<p>语法：<code>sizeof( 数据类型 / 变量 )</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span>（<span class=\"keyword\">short</span>）</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><h4 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h4><p>作用：表示小数</p>\n<ol>\n<li>单精度float</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> f1 = <span class=\"number\">3.14f</span>;   <span class=\"comment\">//在使用的时候在数字后面加上一个f</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>双精度double</li>\n</ol>\n<p>两者的<strong>区别</strong>在于表示的有效数字范围不同</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>占用空间</th>\n<th>有效数字范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float</td>\n<td>4字节</td>\n<td>7位有效数字</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>15~16位有效数字</td>\n</tr>\n</tbody></table>\n<p>有效数字：第一个不为零的数字开始往后数，同时最后一位要四舍五入。</p>\n<p><strong>默认情况下，输出一个小数，会显示6位有效数字</strong></p>\n<ul>\n<li>科学计数法</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> f2 = <span class=\"number\">3e2</span>;   <span class=\"comment\">//3*10^2</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> f3 = <span class=\"number\">3e-2</span>;  <span class=\"comment\">//3*(0.1)^2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h4><p>作用：显示单个字符</p>\n<p>语法：<code>char ch = &#39;a&#39;</code></p>\n<ul>\n<li>用单引号括起来，不用双引号</li>\n<li>单引号内只能有一个字符，不能是字符串</li>\n<li>字符型变量只占用一个字节</li>\n<li>字符型变量是将字符对应的ASCII码放到存储单元中存储</li>\n</ul>\n<p>‘A’的ASCII码：65         </p>\n<p>‘a’的ASCII码：97</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p>换行：<code>\\n</code></p>\n<p>反斜杠：<code>\\\\</code></p>\n<p>水平制表符：<code>\\t</code>   作用：在输出的时候可以让代码对齐</p>\n<h4 id=\"字符串型\"><a href=\"#字符串型\" class=\"headerlink\" title=\"字符串型\"></a>字符串型</h4><p>作用：用于表示一串字符</p>\n<ol>\n<li>C风格字符串：<code>char 变量名[] = &quot;字符串值&quot;</code></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str1[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>C++风格字符串：<code>string 变量名 = &quot;字符串值&quot;</code></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span>  <span class=\"comment\">//在C++风格字符串的时候，要包含这个文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">string str2 = <span class=\"string\">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"布尔类型bool\"><a href=\"#布尔类型bool\" class=\"headerlink\" title=\"布尔类型bool\"></a>布尔类型bool</h4><p>作用：布尔数据类型代表真或假的值</p>\n<p>bool类型只有两个值：</p>\n<ul>\n<li>true ：真（本质是1）</li>\n<li>false：假（本质是0）</li>\n</ul>\n<p><strong>bool类型只占用1个字节大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><h4 id=\"取模运算\"><a href=\"#取模运算\" class=\"headerlink\" title=\"取模运算\"></a>取模运算</h4><h5 id=\"：求余数\"><a href=\"#：求余数\" class=\"headerlink\" title=\"%：求余数\"></a>%：求余数</h5><ul>\n<li>两个数相除除数不能为0</li>\n<li>两个小数不能进行取模运算</li>\n</ul>\n<h4 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h4><p>作用：通过三目运算符实现简单的判断</p>\n<p>语法：<code>表达式1 ？ 表达式2 ： 表达式3</code></p>\n<p>解释：</p>\n<p>如果表达式1的值为真，执行表达式2，并返回结果；</p>\n<p>如果表达式1的值为假，执行表达式3，并返回结果。</p>\n<p><strong>在C++中，三目运算符返回的是变量，可以继续赋值</strong></p>\n<h3 id=\"程序流程结构\"><a href=\"#程序流程结构\" class=\"headerlink\" title=\"程序流程结构\"></a>程序流程结构</h3><h4 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h4><p>格式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (整型/字符型)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> n:</span><br><span class=\"line\">   &#123;xxxxx;&#125;\t <span class=\"comment\">//如果代码很长的话要加花括号</span></span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;   <span class=\"comment\">//重点要记得写break语句</span></span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"keyword\">case</span> i:</span><br><span class=\"line\">\txxxxx;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\txxxxx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>if 和 switch 的区别：</p>\n<ul>\n<li>switch缺点：判断的时候只能是整型或者字符型，不能是一个区间</li>\n<li>switch优点：结构清晰，执行效率高</li>\n</ul>\n<h4 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h4><p>随机数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span>    <span class=\"comment\">//头文件添加</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样</span></span><br><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)<span class=\"built_in\">time</span>(<span class=\"literal\">NULL</span>));    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"built_in\">rand</span>()% <span class=\"number\">100</span> + <span class=\"number\">1</span>    <span class=\"comment\">//在0~100之间随机生成一个数</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h4><h5 id=\"break语句\"><a href=\"#break语句\" class=\"headerlink\" title=\"break语句\"></a>break语句</h5><p>作用：用于跳出<strong>选择结构</strong>或者<strong>循环结构</strong></p>\n<p>使用的时机：</p>\n<ul>\n<li>出现在switch语句中，作用是终止case并跳出switch</li>\n<li>出现在循环语句中，作用是跳出当前的循环语句</li>\n<li>出现在嵌套循环中，跳出最近的内层循环语句</li>\n</ul>\n<h5 id=\"continue语句\"><a href=\"#continue语句\" class=\"headerlink\" title=\"continue语句\"></a>continue语句</h5><p>作用：在<strong>循环语句</strong>中，跳过本次循环余下尚未执行的语句，继续执行下一次循环</p>\n<h5 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h5><p>作用：可以无条件跳转语句</p>\n<p>语法：<code>goto 标记;</code></p>\n<p>解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语句<span class=\"number\">1</span>；</span><br><span class=\"line\">语句<span class=\"number\">2</span>；</span><br><span class=\"line\"><span class=\"keyword\">goto</span> FLAG；<span class=\"comment\">//运行到此时跳转到下方标记处</span></span><br><span class=\"line\">语句<span class=\"number\">3</span>；</span><br><span class=\"line\">语句<span class=\"number\">4</span>；</span><br><span class=\"line\">FLAG；  </span><br><span class=\"line\">语句<span class=\"number\">5</span>；</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h4><p>一维数组名称用途：</p>\n<ol>\n<li>可以统计整个数组在内存中的长度<code>sizeof(array)</code></li>\n<li>可以获取数组在内存中的首地址<code>可以通过cout &lt;&lt; array直接得到</code></li>\n</ol>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>作用：</strong>最常用的算法，对数组内的元素进行排序</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换这两个元素</li>\n<li>对每一对相邻的元素做相同的工作，执行完一轮后，找到数组中最大的元素</li>\n<li>重复以上步骤，每一轮后需要比较的次数减一，直到不需要比较</li>\n</ol>\n<p><strong>示例：</strong>将数组{4，2，8，0，5，7，1，3，9} 进行升序排序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">9</span>] = &#123;<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span> - <span class=\"number\">1</span>; i++)  <span class=\"comment\">//最外层循环，一共要执行排序的轮次，元素数减1</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span> - <span class=\"number\">1</span> - i; j++)   <span class=\"comment\">// 内层每对元素之间依次向后比较</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])\t\t\t<span class=\"comment\">//比较交换</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h4><p>二维数组定义的四种方式：</p>\n<ol>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2&#125; ，&#123;数据3，数据4&#125; &#125;;</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4 &#125;;</code></li>\n<li><code>数据类型 数组名[  ][ 列数 ] = &#123; 数据1， 数据2， 数据3， 数据4 &#125;;</code></li>\n</ol>\n<blockquote>\n<p>第二种更加直观，提高代码的可读性</p>\n</blockquote>\n<p>二维数组数组名</p>\n<ul>\n<li>查看二维数组所占程序空间</li>\n<li>获取二维数组首地址</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr)        <span class=\"comment\">//查看二维数组占用内存空间</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>])     <span class=\"comment\">//查看二维数组第一行占用内存空间</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>])  <span class=\"comment\">//查看第一个元素占用内存空间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr) / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>])       <span class=\"comment\">//查看二维数组行数</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>]) / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) <span class=\"comment\">//查看二维数组列数</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr;     <span class=\"comment\">//查看二维数组首地址</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr[<span class=\"number\">0</span>];  <span class=\"comment\">//查看二维数组第一行首地址   不强制转换为int的话就直接输出数据了</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr[<span class=\"number\">1</span>];  <span class=\"comment\">//查看二维数组第二行首地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)&amp;arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]  <span class=\"comment\">//查看第一个元素首地址</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)&amp;arr[<span class=\"number\">0</span>][<span class=\"number\">1</span>]  <span class=\"comment\">//查看第二个元素首地址</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>作用：将一段经常使用的代码封装起来，减少重复代码</p>\n<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>\n<h4 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回值类型 函数名（参数列表）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t函数体语句</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn表达式</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h4><p>语法： 函数名称（参数）</p>\n<h4 id=\"函数值传递\"><a href=\"#函数值传递\" class=\"headerlink\" title=\"函数值传递\"></a>函数值传递</h4><p>函数的形参发生改变，并不会影响实参</p>\n<h4 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h4><p>作用：告诉编译器函数名称及如何调用函数，函数的实际主题可以单独定义</p>\n<ul>\n<li>函数的声明可以有多次，但是函数的定义只能有一次</li>\n</ul>\n<h4 id=\"函数的分文件编写\"><a href=\"#函数的分文件编写\" class=\"headerlink\" title=\"函数的分文件编写\"></a>函数的分文件编写</h4><p>作用：让代码结构更加清晰</p>\n<p>步骤：</p>\n<ol>\n<li>创建后缀名为.h的文件</li>\n<li>创建后缀名为.cpp的源文件</li>\n<li>在头文件中写函数的声明</li>\n<li>在源文件中写函数的定义</li>\n</ol>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"指针的基本概念\"><a href=\"#指针的基本概念\" class=\"headerlink\" title=\"指针的基本概念\"></a>指针的基本概念</h4><p>作用：可以通过指针间接访问内存</p>\n<h4 id=\"指针变量的定义和使用\"><a href=\"#指针变量的定义和使用\" class=\"headerlink\" title=\"指针变量的定义和使用\"></a>指针变量的定义和使用</h4><p>指针变量定义语法：<code>数据类型 * 变量名;</code></p>\n<p>解引用： *p 取指针指向地址的值</p>\n<h4 id=\"指针所占内存空间\"><a href=\"#指针所占内存空间\" class=\"headerlink\" title=\"指针所占内存空间\"></a>指针所占内存空间</h4><p>各种类型的指针所占的内存空间相同</p>\n<p>在32位操作系统下占4个字节</p>\n<p>在64位操作系统下占8个字节</p>\n<h4 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h4><p>指针变量指向内存中编号为0的空间</p>\n<p>用途：初始化指针变量</p>\n<p>注意：空指针指向的内存是不可以访问的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">0~255号内存编号是系统占用的，不可以访问</font></p>\n<h4 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h4><p>指针变量指向非法的内存空间</p>\n<p><font color=\"red\">在程序中要避免出现野指针</font></p>\n<h4 id=\"const修饰指针\"><a href=\"#const修饰指针\" class=\"headerlink\" title=\"const修饰指针\"></a>const修饰指针</h4><ol>\n<li><p>const修饰指针     常量指针</p>\n<ul>\n<li>特点：指针的指向可以修改，指针指向的值不可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p;</span><br></pre></td></tr></table></figure></li>\n<li><p>const修饰常量     指针常量</p>\n<ul>\n<li>特点：指针的指向不可以修改，指针指向的值可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p;</span><br></pre></td></tr></table></figure></li>\n<li><p>const既修饰指针，又修饰常量</p>\n<ul>\n<li>特点：指针的指向和指针指向的值都不可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h4><p>利用指针访问数组中的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;\t<span class=\"comment\">//arr就是数组首地址</span></span><br><span class=\"line\">cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//输出数组中的第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">p++;\t\t\t<span class=\"comment\">//指针向后偏移4个字节</span></span><br><span class=\"line\">cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//此时输出的是数组中的第二个元素</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"指针和函数\"><a href=\"#指针和函数\" class=\"headerlink\" title=\"指针和函数\"></a>指针和函数</h4><ol>\n<li><p>值传递</p>\n</li>\n<li><p>地址传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *p1,<span class=\"keyword\">int</span> *p2)</span></span>&#123;\t<span class=\"comment\">//用指针来接收参数，因为参数是地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *p1;\t\t\t<span class=\"comment\">//用星号来解引用</span></span><br><span class=\"line\">\t*p1 = *p2;</span><br><span class=\"line\">\t*p2 = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(&amp;a,&amp;b);\t\t\t<span class=\"comment\">//传入地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><h4 id=\"结构体的基本概念\"><a href=\"#结构体的基本概念\" class=\"headerlink\" title=\"结构体的基本概念\"></a>结构体的基本概念</h4><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>\n<h4 id=\"结构体的定义和使用\"><a href=\"#结构体的定义和使用\" class=\"headerlink\" title=\"结构体的定义和使用\"></a>结构体的定义和使用</h4><p>语法：<code>struct 结构体名 &#123;结构体成员列表&#125;;</code></p>\n<p>通过结构体创建变量的方式有三种：</p>\n<ul>\n<li>struct 结构体名 变量名 (再通过   .成员名   来进行赋值 )</li>\n<li>struct 结构体名 变量名 = {成员1值，成员2值……}</li>\n<li>定义结构体时顺便创建变量</li>\n</ul>\n<p>总结：</p>\n<ol>\n<li>定义结构体时的关键字是struct，不能省略</li>\n<li>创建结构体变量时，关键字struct可以省略</li>\n</ol>\n<h4 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h4><p>作用：将自定义的结构体放入到数组中方便维护</p>\n<p>语法：<code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125; , &#123;&#125; , &#123;&#125; , ...&#123;&#125; &#125;</code></p>\n<p>​            在{}中就将数据元素的值全部定义完成</p>\n<p><font color=\"red\">结构体数组传入函数参数中的是地址</font></p>\n<h4 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h4><p>作用：通过指针访问结构体中的成员</p>\n<ul>\n<li>利用操作符-&gt;可以通过结构体指针访问结构体属性</li>\n</ul>\n<h4 id=\"结构体嵌套结构体\"><a href=\"#结构体嵌套结构体\" class=\"headerlink\" title=\"结构体嵌套结构体\"></a>结构体嵌套结构体</h4><p>先定义被嵌套的结构体，然后再定义嵌套结构体</p>\n<p>访问的时候直接用两个 . 号来访问嵌套结构体中的内容</p>\n<h4 id=\"结构体做函数参数\"><a href=\"#结构体做函数参数\" class=\"headerlink\" title=\"结构体做函数参数\"></a>结构体做函数参数</h4><ol>\n<li><p>值传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent1</span><span class=\"params\">(struct student s)</span></span>&#123;</span><br><span class=\"line\">\tcout&lt;&lt;s.name&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;s.age&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;s.score&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span></span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ts = ...;</span><br><span class=\"line\">    <span class=\"built_in\">printstudent1</span>(s);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>地址传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent2</span><span class=\"params\">(struct student *p)</span></span>&#123;\t\t\t\t<span class=\"comment\">//用一个指针来接收地址</span></span><br><span class=\"line\">\tcout&lt;&lt;p-&gt;name&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;p-&gt;age&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;p-&gt;score&lt;&lt;endl;\t<span class=\"comment\">//用箭头访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span></span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ts = ...;</span><br><span class=\"line\">    <span class=\"built_in\">printstudent</span>(&amp;s);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"结构体中const使用场景\"><a href=\"#结构体中const使用场景\" class=\"headerlink\" title=\"结构体中const使用场景\"></a>结构体中const使用场景</h4><p>作用：用const来防止误操作</p>\n<p>在用结构体做函数参数时，用地址传递，可以节省内存空间，而且不会复制一个新的副本出来</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent</span><span class=\"params\">(<span class=\"keyword\">const</span> student *p)</span></span>&#123;\t<span class=\"comment\">//用const可以避免对数据进行误修改</span></span><br><span class=\"line\">\tp-&gt;name = <span class=\"string\">&quot;李四&quot;</span>;\t\t<span class=\"comment\">//此时修改不合法</span></span><br><span class=\"line\">\tcout&lt;&lt;p-&gt;name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"C-核心编程\"><a href=\"#C-核心编程\" class=\"headerlink\" title=\"C++核心编程\"></a>C++核心编程</h2><p>针对C++面向对象编程技术</p>\n<h3 id=\"内存分区模型\"><a href=\"#内存分区模型\" class=\"headerlink\" title=\"内存分区模型\"></a>内存分区模型</h3><p>C++程序在执行时，将内存大方向划分为四个区域</p>\n<ul>\n<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>\n<li>全局区：存放全局变量和静态变量以及常量</li>\n<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>\n</ul>\n<p><strong>内存四区意义：</strong></p>\n<p>不同区域存放的数据，赋予不同的生命周期，使编程更灵活</p>\n<h4 id=\"程序运行前\"><a href=\"#程序运行前\" class=\"headerlink\" title=\"程序运行前\"></a>程序运行前</h4><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>\n<p><strong>代码区：</strong></p>\n<p>​        存放CPU执行的机器指令</p>\n<p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p><strong>全局区：</strong></p>\n<p>​        全局变量和静态变量存放在此</p>\n<p>​        全局区还包括了常量区，字符串常量和其他常量也存放在此</p>\n<p>​        该区域的数据在程序结束后由操作系统释放</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局变量，存放在全局区中</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//const修饰的全局变量，全局常量，存放在常量区中（全局区）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c_g_a = <span class=\"number\">10</span>；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量，不在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//静态变量，存放在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//常量</span></span><br><span class=\"line\">    <span class=\"comment\">//字符串常量,存放在常量区（全局区）中</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;字符串常量的地址为：&quot;</span>&lt;&lt;(<span class=\"keyword\">int</span>)&amp;<span class=\"string\">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">   \t</span><br><span class=\"line\">    <span class=\"comment\">//const修饰的变量</span></span><br><span class=\"line\">    <span class=\"comment\">//const修饰的全局变量,存放在全局区中</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//const修饰的局部变量,局部常量，不存放在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c_l_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"程序运行后\"><a href=\"#程序运行后\" class=\"headerlink\" title=\"程序运行后\"></a>程序运行后</h4><p><strong>栈区：</strong></p>\n<p>​        由编译器自动分配释放，存放函数的参数值，局部变量等</p>\n<p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//形参数据也会放在栈区</span></span><br><span class=\"line\">    b = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;\t<span class=\"comment\">//局部变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;a;\t<span class=\"comment\">//返回局部变量地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//接收func函数的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//第一次可以打印是因为编译器做了保留</span></span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//第二次数据不再保留</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>堆区：</strong></p>\n<p>​        由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>\n<p>​        在C++中主要利用new在堆区开辟内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//利用new关键字，可以将数据开辟到堆区</span></span><br><span class=\"line\">    <span class=\"comment\">//指针 本质也是局部变量，放在栈上，指针保存的数据是放在堆区</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> *p =  <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>C++中利用new操作符在堆区开辟数据</p>\n<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p>\n<p>语法：<code>new 数据类型</code></p>\n<p>利用new创建的数据，会返回该数据类型对应的类型的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、new的基本语法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在堆区创建整型数据</span></span><br><span class=\"line\">    <span class=\"comment\">//new 返回是该数据类型的指针</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//堆区的数据 由程序员开辟由程序员释放</span></span><br><span class=\"line\">    <span class=\"comment\">//如果想释放堆区的数据，利用关键字delete</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    <span class=\"comment\">//cout&lt;&lt;*p&lt;&lt;endl;//内存已经被释放，不能再次访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、在堆区用new开辟数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在堆区创建10个整型数据的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];\t<span class=\"comment\">//10代表元素个数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//释放堆区数组，要加入中括号</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> test01;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> test02;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><h4 id=\"引用的基本使用\"><a href=\"#引用的基本使用\" class=\"headerlink\" title=\"引用的基本使用\"></a>引用的基本使用</h4><p><strong>作用：</strong>给变量起别名</p>\n<p><strong>语法：</strong><code>数据类型 &amp;别名 = 原名</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用注意事项\"><a href=\"#引用注意事项\" class=\"headerlink\" title=\"引用注意事项\"></a>引用注意事项</h4><ul>\n<li>引用必须初始化</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;b; <span class=\"comment\">//错误</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>引用在初始化后不能发生改变</li>\n</ul>\n<h4 id=\"引用做函数参数\"><a href=\"#引用做函数参数\" class=\"headerlink\" title=\"引用做函数参数\"></a>引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p><strong>优点：</strong>可以简化指针修改实参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//值传递,形参不改变实参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap01</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap02</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用传递,形参修饰实参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap03</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a,<span class=\"keyword\">int</span> &amp;b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap01</span>(a,b);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">swap02</span>(&amp;a,&amp;b);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">swap03</span>(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用做函数返回值\"><a href=\"#引用做函数返回值\" class=\"headerlink\" title=\"引用做函数返回值\"></a>引用做函数返回值</h4><p><strong>注意：</strong>不要返回局部变量的引用（与 内存分区模型-程序运行后-栈区 中的例子类似，不能返回局部变量的地址）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//局部变量，存放在栈区</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = <span class=\"built_in\">test01</span>();\t<span class=\"comment\">//test01函数的返回值也是引用类型  但是这种做法是错误的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>函数调用可以作为左值存在</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;\t<span class=\"comment\">//静态变量，存放在全局区，程序结束后由系统释放</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">test02</span>() = <span class=\"number\">1000</span>;\t<span class=\"comment\">//函数返回变量的引用，相当于返回变量，相当于 a = 1000；</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h4><p><strong>本质：</strong>引用的本质在C++内部实现是一个指针常量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;ref)</span></span>&#123;</span><br><span class=\"line\">    ref = <span class=\"number\">100</span>;\t<span class=\"comment\">//ref是引用，转换为*ref = 100；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//自动转换为int * const ref = &amp;a; 指针常量是指针的指向不能改，引用不能改的原因</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = a;</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;\t<span class=\"comment\">//内部发现ref是引用，转换为 *ref = 20;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作都由编译器完成</p>\n<h4 id=\"常量引用\"><a href=\"#常量引用\" class=\"headerlink\" title=\"常量引用\"></a>常量引用</h4><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作（结构体-结构体中const使用场景类似）</p>\n<p>在函数参数列表中，可以加const修饰形参，防止形参改变实参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShowValue</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; val)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//val = 1000;\t如果形参中不加const 会对实参进行修改</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;val=&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;ref = <span class=\"number\">10</span>;\t<span class=\"comment\">//错误，10在常量区，不是引用合法内存空间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = a;\t<span class=\"comment\">//正确</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//加上const之后，编译器将代码修改为 int temp = 10;int &amp;ref = temp;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ref = <span class=\"number\">10</span>;\t</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;\t<span class=\"comment\">//错误，加入const后变为只读，不能修改</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">ShowValue</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"函数提高\"><a href=\"#函数提高\" class=\"headerlink\" title=\"函数提高\"></a>函数提高</h3><h4 id=\"函数默认参数\"><a href=\"#函数默认参数\" class=\"headerlink\" title=\"函数默认参数\"></a>函数默认参数</h4><p>语法：<code>返回值类型 函数名 （形参 = 默认值）&#123;&#125;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项：</p>\n<p>1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</p>\n<p>2、如果函数的声明有了默认参数，函数实现就不能有默认参数（声明和实现只能一个有默认参数）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func2(int a = 10,int b = 10);\t//函数声明</span><br><span class=\"line\"></span><br><span class=\"line\">int func2(int a,int b)&#123;\t\t\t\t//函数实现，此时就不能再用默认参数了</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数占位参数\"><a href=\"#函数占位参数\" class=\"headerlink\" title=\"函数占位参数\"></a>函数占位参数</h4><p>函数的形参列表中可以有占位参数，但是函数调用时必须填补该位置</p>\n<p>语法：<code>返回值类型 函数名 （数据类型） &#123;&#125;</code></p>\n<p>占位参数可以有默认参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;this is func&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//占位参数有默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">    ......;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前用不到，后面会用到</p>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><h5 id=\"函数重载概述\"><a href=\"#函数重载概述\" class=\"headerlink\" title=\"函数重载概述\"></a>函数重载概述</h5><p><strong>作用：</strong>函数名可以相同，提高复用性</p>\n<p><strong>函数重载满足条件：</strong></p>\n<ul>\n<li>同一个作用域下（全局、局部）</li>\n<li>函数名称相同</li>\n<li>函数参数 <strong>类型不同</strong> 或者<strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>\n</ul>\n<p><strong>注意：</strong>函数的返回值不可以作为函数重载的条件</p>\n<h5 id=\"函数重载注意事项\"><a href=\"#函数重载注意事项\" class=\"headerlink\" title=\"函数重载注意事项\"></a>函数重载注意事项</h5><ul>\n<li>引用作为重载条件</li>\n<li>函数重载碰到默认参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、引用作为重载的条件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a)</span></span>&#123;\t<span class=\"comment\">//int &amp;a = 10; 不合法，10在常量区</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;func(int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;a)</span></span>&#123;\t<span class=\"comment\">//const int &amp;a = 10; 编译器优化，创建临时空间，合法</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;func(const int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(a);\t<span class=\"comment\">//调用第一个函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//调用第二个函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、函数重载碰到默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;func2的调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;func2的调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func2</span>(<span class=\"number\">10</span>);\t\t<span class=\"comment\">//错误，此时两个函数都能被调用，出现二义性，尽量避免</span></span><br><span class=\"line\">&#125;\t\t\t\t\t<span class=\"comment\">//函数重载时尽量不用默认参数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h3><p>C++面向对象的三大特性为：封装、继承、多态</p>\n<p>C++认为万事万物都是对象，对象上有其属性和行为</p>\n<p><strong>例：</strong></p>\n<p>​    人可以作为对象，属性有姓名、年龄、性别…行为有走、跑、跳、吃饭</p>\n<p>​    车也可以作为对象，属性有轮胎、方向盘…行为有载人、开空调、放音乐</p>\n<p>​    具有<font color=\"red\">相同性质的对象</font>，我们可以抽象为<font color=\"red\">类</font>，人属于人类，车属于车类</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是C++面向对象的三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的食物</li>\n<li>对属性和行为加以权限控制</li>\n</ul>\n<h5 id=\"封装意义1\"><a href=\"#封装意义1\" class=\"headerlink\" title=\"封装意义1\"></a><strong>封装意义1</strong></h5><p>​    在设计类的时候，行为和属性写在一起，表现事务</p>\n<p><strong>语法：</strong><code>class 类名 &#123; 访问权限 ： 属性 / 行为 &#125;;</code></p>\n<p>例：设计一个圆类，求圆的周长</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//访问权限-公共权限</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//类中的属性和行为，统一称为 成员</span></span><br><span class=\"line\">    <span class=\"comment\">//属性\t成员属性 成员变量</span></span><br><span class=\"line\">    <span class=\"comment\">//行为\t成员函数 成员方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_r;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//行为</span></span><br><span class=\"line\">    <span class=\"comment\">//获取圆的周长</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">calculateZC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span> * pi *m_r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;\t\t<span class=\"comment\">//记得分号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过圆类来创建一个具体的圆（对象）</span></span><br><span class=\"line\">    <span class=\"comment\">//实例化（通过一个类，创建一个对象的过程）</span></span><br><span class=\"line\">    Circle c1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//给圆对象 属性进行赋值操作</span></span><br><span class=\"line\">    c1.m_r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取圆的周长</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;圆的周长为：&quot;</span>&lt;&lt;c1.<span class=\"built_in\">calculateZC</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"封装意义2\"><a href=\"#封装意义2\" class=\"headerlink\" title=\"封装意义2\"></a><strong>封装意义2</strong></h5><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<ol>\n<li>public         公共权限</li>\n<li>protected   保护权限</li>\n<li>private        私有权限</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//公共权限 public \t\t成员 类内可以访问 类外可以访问</span></span><br><span class=\"line\"><span class=\"comment\">//保护权限 protected\t成员 类内可以访问 类外不可以访问 儿子可以访问父亲中保护内容</span></span><br><span class=\"line\"><span class=\"comment\">//私有权限 private \t\t成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中私有内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">Public:   </span><br><span class=\"line\">    <span class=\"comment\">//公共权限</span></span><br><span class=\"line\">    string m_Name;\t<span class=\"comment\">//姓名</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Protected:</span><br><span class=\"line\">    <span class=\"comment\">//保护权限</span></span><br><span class=\"line\">    string m_car;\t<span class=\"comment\">//汽车</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Private:</span><br><span class=\"line\">    <span class=\"comment\">//私有权限</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> password;\t<span class=\"comment\">//密码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Public:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        m_Name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">        m_Car = <span class=\"string\">&quot;比亚迪&quot;</span>;</span><br><span class=\"line\">        m_password = <span class=\"string\">&quot;123456&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化一个具体的对象</span></span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    p1.m_Name = <span class=\"string\">&quot;李四&quot;</span>;\t\t<span class=\"comment\">//可以访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p1.m_Car = &quot;奔驰&quot;;\t\t//此时错误，保护权限在类外不可以访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p1.m_password = &quot;123&quot;;\t\t//错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>struct和class的区别</p>\n<p>在C++中struct和class的唯一区别就在于 <strong>默认的访问权限不同</strong></p>\n<p>区别：</p>\n<ul>\n<li>struct默认权限为公共</li>\n<li>class默认权限为私有</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//默认权限为私有  </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//默认权限为公共</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    C1 c1;</span><br><span class=\"line\">    <span class=\"comment\">//c1.m_A = 100;\t//错误,权限为私有</span></span><br><span class=\"line\">    C2 c2;</span><br><span class=\"line\">    c2.m_A = <span class=\"number\">100</span>;\t<span class=\"comment\">//正确，权限为公共</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"成员属性设置为私有\"><a href=\"#成员属性设置为私有\" class=\"headerlink\" title=\"成员属性设置为私有\"></a>成员属性设置为私有</h5><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己设置读写权限</p>\n<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">Public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置姓名</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">        m_Name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取姓名</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_Name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取年龄 可读可写\t如果想修改，年龄必须在0~150之间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//m_Age = 0;\t//初始化为0岁</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_Age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置年龄</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age &lt; <span class=\"number\">0</span> || age &gt; <span class=\"number\">150</span>)&#123;</span><br><span class=\"line\">            m_Age = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;年龄有误&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_Age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置情人 只写</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLover</span><span class=\"params\">(string lover)</span></span>&#123;</span><br><span class=\"line\">        m_Lover = lover;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">Private:</span><br><span class=\"line\">    <span class=\"comment\">//姓名\t可读可写</span></span><br><span class=\"line\">    String m_Name;</span><br><span class=\"line\">    <span class=\"comment\">//年龄\t只读</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">    <span class=\"comment\">//伴侣\t只写</span></span><br><span class=\"line\">    string m_Lover;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//p.m_Name = &quot;张三&quot;;\t//错误 私有权限不能访问</span></span><br><span class=\"line\">    p.<span class=\"built_in\">setName</span>(<span class=\"string\">&quot;张三&quot;</span>);\t<span class=\"comment\">//正确 公共权限函数访问</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;姓名为：&quot;</span>&lt;&lt;p.<span class=\"built_in\">getName</span>()&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//p.m_Age = 18;\t\t//错误 私有权限不能访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p.setAge(18);\t\t//错误 没有这个函数\t\t</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;年龄为：&quot;</span>&lt;&lt;p.<span class=\"built_in\">getAge</span>()&lt;&lt;endl; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置情人</span></span><br><span class=\"line\">    p.<span class=\"built_in\">setLover</span>(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//cout&lt;&lt;&quot;情人为：&quot;&lt;&lt;p.m_Lover&lt;&lt;endl;\t//错误 私有权限不能访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"头文件与源文件分离\"><a href=\"#头文件与源文件分离\" class=\"headerlink\" title=\"头文件与源文件分离\"></a>头文件与源文件分离</h5><p>头文件.h中写函数定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once\t\t<span class=\"comment\">//为了避免一个头文件被包含多次</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xxx.h&gt;</span>\t<span class=\"comment\">//若其中使用到了其他类的内容，只需要包含所用类的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;\t\t<span class=\"comment\">//只做函数声明</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>cpp文件中写函数实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xxx.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx::func</span><span class=\"params\">()</span></span>&#123;\t<span class=\"comment\">//xxx:: 说明是成员函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//函数实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"对象特性\"><a href=\"#对象特性\" class=\"headerlink\" title=\"对象特性\"></a>对象特性</h4><p>C++中的面对对象来源于生活，每个对象有初始设置和对象销毁前的清理数据的设置</p>\n<h5 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h5><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>\n<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​    同样的使用完一个对象或变量，没有即时清理，也会造成一定的安全问题</p>\n<p>C++利用构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器提供的构造和析构函数是空实现</strong></p>\n<ul>\n<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，由编译器自动调用，无须手动</li>\n<li>析构函数：主要作用在于对象<strong>销毁前</strong>自动调用，执行一些清理工作</li>\n</ul>\n<p>构造函数语法：<code>类名()&#123;&#125;</code></p>\n<ol>\n<li>构造函数，没有返回值也不写void</li>\n<li>函数名称和类名相同</li>\n<li>构造函数可以有参数，因此可以发生重载</li>\n<li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li>\n<li>前面要写作用域</li>\n</ol>\n<p>析构函数语法：<code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>析构函数，没有返回值也不写void</li>\n<li>函数名称和类名相同，在名称前面多加一个~</li>\n<li>析构函数不能有参数，不能发生重载</li>\n<li>程序在对象销毁前会自动调用析构，因此无须手动调用，而且只会调用一次</li>\n</ol>\n<h5 id=\"构造函数的分类及调用\"><a href=\"#构造函数的分类及调用\" class=\"headerlink\" title=\"构造函数的分类及调用\"></a>构造函数的分类及调用</h5><p>两种分类方式：</p>\n<p>​    按参数分为：有参构造和无参构造</p>\n<p>​    按类型分为：普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​    括号法</p>\n<p>​    显示法</p>\n<p>​    隐式转换法</p>\n<p>分类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:\t</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;无参函数构造调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a)&#123;</span><br><span class=\"line\">        age = a;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;有参函数构造调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)&#123;\t<span class=\"comment\">//避免对p本身进行修改，结构体中const的应用 类似</span></span><br><span class=\"line\">        <span class=\"comment\">//将传入的人身上的所有属性，拷贝到自身</span></span><br><span class=\"line\">        age = p.age;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~<span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1、括号法</span></span><br><span class=\"line\">    Person p1;\t<span class=\"comment\">//函数默认构造函数调用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;\t<span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数调用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p3</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//注意事项1</span></span><br><span class=\"line\">    <span class=\"comment\">//调用默认构造函数时，不要加括号（）</span></span><br><span class=\"line\">    <span class=\"comment\">//Person p1();\t//这行代码会被认为是函数的声明，不会认为是在创建对象</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2、显示法</span></span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    Person p2 = <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//有参构造</span></span><br><span class=\"line\">    Person p3 = <span class=\"built_in\">Person</span>(p2);\t<span class=\"comment\">//拷贝构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//匿名对象 特点，当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class=\"line\">    <span class=\"comment\">//注意事项2</span></span><br><span class=\"line\">    <span class=\"comment\">//不要利用拷贝构造函数 初始化匿名对象 编译器会认为Person(p3) === Person(p3);</span></span><br><span class=\"line\">    <span class=\"comment\">//编译器会认为是对象的声明</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(p3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3、隐式转换法</span></span><br><span class=\"line\">    Person p4 = <span class=\"number\">10</span>;\t<span class=\"comment\">//相当于写了 Person p4 = Person(10);</span></span><br><span class=\"line\">    Person p5 = p4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"拷贝构造函数调用时机\"><a href=\"#拷贝构造函数调用时机\" class=\"headerlink\" title=\"拷贝构造函数调用时机\"></a>拷贝构造函数调用时机</h5><p>C++中拷贝函数调用时机通常有三种情况</p>\n<ul>\n<li>使用一个已经创建完毕的对象来初始化一个对象</li>\n<li>值传递的方式给函数参数传值</li>\n<li>以值方式返回局部对象</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的默认构造函数调用&quot;</span>&lt;&lt;endl;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Peson</span>(<span class=\"keyword\">int</span> age)&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = p.m_Age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~<span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.值传递的方式给函数参数传值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person p)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"built_in\">doWork</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.值方式返回局部对象</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">doWork2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>*)&amp;p1&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tPerson p = <span class=\"built_in\">doWork2</span>();</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>*)p &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"构造函数的调用规则\"><a href=\"#构造函数的调用规则\" class=\"headerlink\" title=\"构造函数的调用规则\"></a>构造函数的调用规则</h5><p>默认情况下，c++编译器至少给类添加三个函数</p>\n<p>1.默认构造函数（无参，函数体为空）</p>\n<p>2.默认析构函数（无参，函数体为空）</p>\n<p>3.默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则：</p>\n<ul>\n<li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>\n<li>如果用户定义拷贝构造函数，c++不再提供其他构造函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数的调用规则</span></span><br><span class=\"line\"><span class=\"comment\">//1.创建一个类，c++编译器会给每个类都添加至少三个函数</span></span><br><span class=\"line\"><span class=\"comment\">//默认构造 （空实现）</span></span><br><span class=\"line\"><span class=\"comment\">//析构函数 （空实现）</span></span><br><span class=\"line\"><span class=\"comment\">//拷贝构造 （值拷贝）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = p.m_Age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.m_Age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;p2的年龄是：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Person p;\t<span class=\"comment\">//如果有 有参构造函数定义，没有自己定义的默认构造函数，就会报错，因为</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">//此时系统也不会提供默认构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h5><p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age, <span class=\"keyword\">int</span> height)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">        m_Height = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//自己实现拷贝构造函数 解决浅拷贝带来的问题</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt; <span class=\"string\">&quot;Person 拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = p.m_Age;</span><br><span class=\"line\">        <span class=\"comment\">//m_Height = p.m_Height;\t编译器默认实现就是这行代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//深拷贝操作</span></span><br><span class=\"line\">        m_Height = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*p.m_Height);\t<span class=\"comment\">//解引用来获得m_Height的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Person(const Person &amp;p)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t  cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t  m_Age = p.m_Age;</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m_Height != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_Height;</span><br><span class=\"line\">            m_Height = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//防止野指针出现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *m_Height; <span class=\"comment\">//new新建开辟到堆区，用指针接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>,<span class=\"number\">160</span>)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p1的年龄为:&quot;</span>&lt;&lt;p1.m_Age&lt;&lt;<span class=\"string\">&quot;  身高为:&quot;</span>&lt;&lt;p1.m_Height&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p2的年龄为:&quot;</span>&lt;&lt;p2.m_Age&lt;&lt;<span class=\"string\">&quot;  身高为:&quot;</span>&lt;&lt;p2.m_Height&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//此时会出错 默认拷贝函数将 int *m_Height 中的全部内容拷贝过去</span></span><br><span class=\"line\">    <span class=\"comment\">//p2 和 p1 在函数运行结束后都会进行析构函数释放 m_Height 内存的操作 </span></span><br><span class=\"line\">    <span class=\"comment\">//重复释放，非法操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>浅拷贝带来的问题就是堆区的内存重复释放</p>\n<p><font color=\"red\"> 浅拷贝的问题，要利用深拷贝来进行解决</font>，即给使用拷贝构造的函数也申请一块新的内存空间</p>\n<p><strong>总结：</strong></p>\n<p><font color=\"red\">如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</font></p>\n<h5 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h5><p>作用：用来初始化属性</p>\n<p><strong>语法：</strong><code> 构造函数():属性1(值1)，属性2(值2)...&#123;&#125;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//传统初始化操作</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_A = a;</span><br><span class=\"line\">        m_B = b;</span><br><span class=\"line\">        m_C = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_C;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化列表初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>():<span class=\"built_in\">m_A</span>(<span class=\"number\">10</span>),<span class=\"built_in\">m_B</span>(<span class=\"number\">20</span>).<span class=\"built_in\">m_C</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//更灵活的方式初始化列表初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c):<span class=\"built_in\">m_A</span>(a),<span class=\"built_in\">m_B</span>(b).<span class=\"built_in\">m_C</span>(c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Person p(10,20,30);\t普通构造</span></span><br><span class=\"line\">    Person p;\t\t\t\t初始化列表构造</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">30</span>,<span class=\"number\">20</span>,<span class=\"number\">10</span>)</span></span>;\t\t第三种构造</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_A = &quot;</span>&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_B = &quot;</span>&lt;&lt;p.m_B&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_C = &quot;</span>&lt;&lt;p.m_C&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"类对象作为类成员\"><a href=\"#类对象作为类成员\" class=\"headerlink\" title=\"类对象作为类成员\"></a>类对象作为类成员</h5><p>C++中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">\tA a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>B类中有对象A作为成员，A为对象成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">phone</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">phone</span>(string PName)&#123;</span><br><span class=\"line\">\t\tm_PName = pName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstring m_PName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Phone m_Phone = pName;\t隐式转换法</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(string name, string pName):<span class=\"built_in\">m_Name</span>(name),<span class=\"built_in\">m_Phone</span>(PName)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//姓名</span></span><br><span class=\"line\">\tstring m_Nname;</span><br><span class=\"line\">\t<span class=\"comment\">//手机</span></span><br><span class=\"line\">\tPhone m_Phone;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"string\">&quot;张三&quot;</span>,<span class=\"string\">&quot;苹果&quot;</span>)</span>；</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><font color=\"red\">其他类的对象作为本类的成员时，构造时候先构造类对象，再构造自身，析构的顺序与构造相反，先析构本类，然后在析构其他类</font></p>\n<h5 id=\"静态成员和静态成员函数\"><a href=\"#静态成员和静态成员函数\" class=\"headerlink\" title=\"静态成员和静态成员函数\"></a>静态成员和静态成员函数</h5><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>\n<p>静态成员分为：</p>\n<ul>\n<li>静态成员变量<ul>\n<li>所有对象共享同一份数据</li>\n<li>在编译阶段分配内存</li>\n<li>类内声明，类外初始化</li>\n</ul>\n</li>\n<li>静态成员函数<ul>\n<li>所有对象共享同一个函数</li>\n<li>静态成员函数只能访问静态成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//静态成员函数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">        m_A = <span class=\"number\">100</span>; <span class=\"comment\">//静态成员函数可以访问静态成员变量</span></span><br><span class=\"line\">        <span class=\"comment\">//m_B = 200; //静态成员函数 不可以访问 非静态成员变量，无法区分到底是哪个对象的m_B属性</span></span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;static void func调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//静态成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_B; <span class=\"comment\">//非静态成员变量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//静态成员函数也是有访问权限的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;static void func2()调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::m_A = <span class=\"number\">0</span>; <span class=\"comment\">//类外初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//两种访问方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1.通过对象访问</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    p.<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    <span class=\"comment\">//2.通过类名访问</span></span><br><span class=\"line\">    Person::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Person::func2();\t//类外访问不到私有静态成员函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    test01;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"C-对象模型和this指针\"><a href=\"#C-对象模型和this指针\" class=\"headerlink\" title=\"C++对象模型和this指针\"></a>C++对象模型和this指针</h4><h5 id=\"成员变量和成员函数分开存储\"><a href=\"#成员变量和成员函数分开存储\" class=\"headerlink\" title=\"成员变量和成员函数分开存储\"></a>成员变量和成员函数分开存储</h5><p>在C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//非静态成员变量 属于类的对象上 只要不是空，就是原大小</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m_B;\t<span class=\"comment\">//静态成员变量 不属于类的对象上</span></span><br><span class=\"line\">    <span class=\"number\">88</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;&#125;\t<span class=\"comment\">//非静态成员函数 不属于类的对象上</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;&#125;\t<span class=\"comment\">//静态成员函数 不属于类的对象上</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\t<span class=\"comment\">//空对象占用空间内存空间为：1</span></span><br><span class=\"line\">    <span class=\"comment\">//C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class=\"line\">    <span class=\"comment\">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;size of p = &quot;</span>&lt;&lt;<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(p)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;size of p = &quot;</span>&lt;&lt;<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(p)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//test01();</span></span><br><span class=\"line\">    <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"this指针概念\"><a href=\"#this指针概念\" class=\"headerlink\" title=\"this指针概念\"></a>this指针概念</h5><p> 每一个非静态成员函数只会诞生一份函数实例，即多个同类型的对象会共用同一块代码，那么这一块代码如何区分哪个对象调用自己呢？</p>\n<p>C++通过提供特殊的对象指针，this指针来解决该问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>\n<p>this指针是隐含在每一个非静态成员函数内的一种指针</p>\n<p>this指针不需要定义，直接使用即可</p>\n<p>this指针的用途：</p>\n<ul>\n<li>当形参和成员变量同名时，可以用this指针来区分</li>\n<li>在类的非静态成员函数中返回对象本身，可以使用return *this</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">Public:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tage = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;\t<span class=\"comment\">//与构造函数中的参数相同了，应该加以区分 可以使用m_Age</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//m代表member</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//这里要加&amp;符号 不加&amp;代表以值的方式返回，会复制一份新的数据返回</span></span><br><span class=\"line\">    <span class=\"comment\">//相当于返回的不是p2 而是p2&#x27;\t引用的方式不会创建新的对象</span></span><br><span class=\"line\">    <span class=\"function\">Person&amp; <span class=\"title\">PersonAddAge</span><span class=\"params\">(Person &amp;p)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age += p.age;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//this是指向p2的指针，而*this指向的就是p2这个对象本体</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">正确的写法：</span><br><span class=\"line\">Public:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//this指针指向被调用的成员函数所属的对象\t这里this指向p1</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.解决名称冲突</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p1的年龄为：&quot;</span>&lt;&lt;p1.age&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.返回对象本身用 *this\t可以一直做追加操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链式编程思想</span></span><br><span class=\"line\">    p2.<span class=\"built_in\">PersonAddAge</span>(p1).<span class=\"built_in\">PersonAddAge</span>(p1).<span class=\"built_in\">PersonAddAge</span>(p1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.age&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">test01</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础入门\"><a href=\"#C-基础入门\" class=\"headerlink\" title=\"C++基础入门\"></a>C++基础入门</h2><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>作用：用于记录程序中不可更改的数据</p>\n<p>C++中定义常量两种方式：</p>\n<ol>\n<li><p>#define 宏常量    <code>define 常量名 常量值</code></p>\n<p><strong>通常在文件上方定义</strong>，表示一个常量</p>\n</li>\n<li><p>const 修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>\n<p><strong>通常在变量定义前加上关键字const</strong>，修饰该变量为常量，不可修改</p>\n</li>\n</ol>\n<h3 id=\"sizeof关键字\"><a href=\"#sizeof关键字\" class=\"headerlink\" title=\"sizeof关键字\"></a>sizeof关键字</h3><p>作用：统计数据类型所占内存的大小</p>\n<p>语法：<code>sizeof( 数据类型 / 变量 )</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span>（<span class=\"keyword\">short</span>）</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><h4 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h4><p>作用：表示小数</p>\n<ol>\n<li>单精度float</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> f1 = <span class=\"number\">3.14f</span>;   <span class=\"comment\">//在使用的时候在数字后面加上一个f</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>双精度double</li>\n</ol>\n<p>两者的<strong>区别</strong>在于表示的有效数字范围不同</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>占用空间</th>\n<th>有效数字范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float</td>\n<td>4字节</td>\n<td>7位有效数字</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>15~16位有效数字</td>\n</tr>\n</tbody></table>\n<p>有效数字：第一个不为零的数字开始往后数，同时最后一位要四舍五入。</p>\n<p><strong>默认情况下，输出一个小数，会显示6位有效数字</strong></p>\n<ul>\n<li>科学计数法</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> f2 = <span class=\"number\">3e2</span>;   <span class=\"comment\">//3*10^2</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> f3 = <span class=\"number\">3e-2</span>;  <span class=\"comment\">//3*(0.1)^2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h4><p>作用：显示单个字符</p>\n<p>语法：<code>char ch = &#39;a&#39;</code></p>\n<ul>\n<li>用单引号括起来，不用双引号</li>\n<li>单引号内只能有一个字符，不能是字符串</li>\n<li>字符型变量只占用一个字节</li>\n<li>字符型变量是将字符对应的ASCII码放到存储单元中存储</li>\n</ul>\n<p>‘A’的ASCII码：65         </p>\n<p>‘a’的ASCII码：97</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p>换行：<code>\\n</code></p>\n<p>反斜杠：<code>\\\\</code></p>\n<p>水平制表符：<code>\\t</code>   作用：在输出的时候可以让代码对齐</p>\n<h4 id=\"字符串型\"><a href=\"#字符串型\" class=\"headerlink\" title=\"字符串型\"></a>字符串型</h4><p>作用：用于表示一串字符</p>\n<ol>\n<li>C风格字符串：<code>char 变量名[] = &quot;字符串值&quot;</code></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str1[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>C++风格字符串：<code>string 变量名 = &quot;字符串值&quot;</code></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span>  <span class=\"comment\">//在C++风格字符串的时候，要包含这个文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">string str2 = <span class=\"string\">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"布尔类型bool\"><a href=\"#布尔类型bool\" class=\"headerlink\" title=\"布尔类型bool\"></a>布尔类型bool</h4><p>作用：布尔数据类型代表真或假的值</p>\n<p>bool类型只有两个值：</p>\n<ul>\n<li>true ：真（本质是1）</li>\n<li>false：假（本质是0）</li>\n</ul>\n<p><strong>bool类型只占用1个字节大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><h4 id=\"取模运算\"><a href=\"#取模运算\" class=\"headerlink\" title=\"取模运算\"></a>取模运算</h4><h5 id=\"：求余数\"><a href=\"#：求余数\" class=\"headerlink\" title=\"%：求余数\"></a>%：求余数</h5><ul>\n<li>两个数相除除数不能为0</li>\n<li>两个小数不能进行取模运算</li>\n</ul>\n<h4 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h4><p>作用：通过三目运算符实现简单的判断</p>\n<p>语法：<code>表达式1 ？ 表达式2 ： 表达式3</code></p>\n<p>解释：</p>\n<p>如果表达式1的值为真，执行表达式2，并返回结果；</p>\n<p>如果表达式1的值为假，执行表达式3，并返回结果。</p>\n<p><strong>在C++中，三目运算符返回的是变量，可以继续赋值</strong></p>\n<h3 id=\"程序流程结构\"><a href=\"#程序流程结构\" class=\"headerlink\" title=\"程序流程结构\"></a>程序流程结构</h3><h4 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h4><p>格式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (整型/字符型)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> n:</span><br><span class=\"line\">   &#123;xxxxx;&#125;\t <span class=\"comment\">//如果代码很长的话要加花括号</span></span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;   <span class=\"comment\">//重点要记得写break语句</span></span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"keyword\">case</span> i:</span><br><span class=\"line\">\txxxxx;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\txxxxx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>if 和 switch 的区别：</p>\n<ul>\n<li>switch缺点：判断的时候只能是整型或者字符型，不能是一个区间</li>\n<li>switch优点：结构清晰，执行效率高</li>\n</ul>\n<h4 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h4><p>随机数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span>    <span class=\"comment\">//头文件添加</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样</span></span><br><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)<span class=\"built_in\">time</span>(<span class=\"literal\">NULL</span>));    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"built_in\">rand</span>()% <span class=\"number\">100</span> + <span class=\"number\">1</span>    <span class=\"comment\">//在0~100之间随机生成一个数</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h4><h5 id=\"break语句\"><a href=\"#break语句\" class=\"headerlink\" title=\"break语句\"></a>break语句</h5><p>作用：用于跳出<strong>选择结构</strong>或者<strong>循环结构</strong></p>\n<p>使用的时机：</p>\n<ul>\n<li>出现在switch语句中，作用是终止case并跳出switch</li>\n<li>出现在循环语句中，作用是跳出当前的循环语句</li>\n<li>出现在嵌套循环中，跳出最近的内层循环语句</li>\n</ul>\n<h5 id=\"continue语句\"><a href=\"#continue语句\" class=\"headerlink\" title=\"continue语句\"></a>continue语句</h5><p>作用：在<strong>循环语句</strong>中，跳过本次循环余下尚未执行的语句，继续执行下一次循环</p>\n<h5 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h5><p>作用：可以无条件跳转语句</p>\n<p>语法：<code>goto 标记;</code></p>\n<p>解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语句<span class=\"number\">1</span>；</span><br><span class=\"line\">语句<span class=\"number\">2</span>；</span><br><span class=\"line\"><span class=\"keyword\">goto</span> FLAG；<span class=\"comment\">//运行到此时跳转到下方标记处</span></span><br><span class=\"line\">语句<span class=\"number\">3</span>；</span><br><span class=\"line\">语句<span class=\"number\">4</span>；</span><br><span class=\"line\">FLAG；  </span><br><span class=\"line\">语句<span class=\"number\">5</span>；</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h4><p>一维数组名称用途：</p>\n<ol>\n<li>可以统计整个数组在内存中的长度<code>sizeof(array)</code></li>\n<li>可以获取数组在内存中的首地址<code>可以通过cout &lt;&lt; array直接得到</code></li>\n</ol>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>作用：</strong>最常用的算法，对数组内的元素进行排序</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换这两个元素</li>\n<li>对每一对相邻的元素做相同的工作，执行完一轮后，找到数组中最大的元素</li>\n<li>重复以上步骤，每一轮后需要比较的次数减一，直到不需要比较</li>\n</ol>\n<p><strong>示例：</strong>将数组{4，2，8，0，5，7，1，3，9} 进行升序排序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">9</span>] = &#123;<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span> - <span class=\"number\">1</span>; i++)  <span class=\"comment\">//最外层循环，一共要执行排序的轮次，元素数减1</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span> - <span class=\"number\">1</span> - i; j++)   <span class=\"comment\">// 内层每对元素之间依次向后比较</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])\t\t\t<span class=\"comment\">//比较交换</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h4><p>二维数组定义的四种方式：</p>\n<ol>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2&#125; ，&#123;数据3，数据4&#125; &#125;;</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4 &#125;;</code></li>\n<li><code>数据类型 数组名[  ][ 列数 ] = &#123; 数据1， 数据2， 数据3， 数据4 &#125;;</code></li>\n</ol>\n<blockquote>\n<p>第二种更加直观，提高代码的可读性</p>\n</blockquote>\n<p>二维数组数组名</p>\n<ul>\n<li>查看二维数组所占程序空间</li>\n<li>获取二维数组首地址</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr)        <span class=\"comment\">//查看二维数组占用内存空间</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>])     <span class=\"comment\">//查看二维数组第一行占用内存空间</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>])  <span class=\"comment\">//查看第一个元素占用内存空间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr) / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>])       <span class=\"comment\">//查看二维数组行数</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>]) / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) <span class=\"comment\">//查看二维数组列数</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr;     <span class=\"comment\">//查看二维数组首地址</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr[<span class=\"number\">0</span>];  <span class=\"comment\">//查看二维数组第一行首地址   不强制转换为int的话就直接输出数据了</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)arr[<span class=\"number\">1</span>];  <span class=\"comment\">//查看二维数组第二行首地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)&amp;arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]  <span class=\"comment\">//查看第一个元素首地址</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">int</span>)&amp;arr[<span class=\"number\">0</span>][<span class=\"number\">1</span>]  <span class=\"comment\">//查看第二个元素首地址</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>作用：将一段经常使用的代码封装起来，减少重复代码</p>\n<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>\n<h4 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回值类型 函数名（参数列表）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t函数体语句</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn表达式</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h4><p>语法： 函数名称（参数）</p>\n<h4 id=\"函数值传递\"><a href=\"#函数值传递\" class=\"headerlink\" title=\"函数值传递\"></a>函数值传递</h4><p>函数的形参发生改变，并不会影响实参</p>\n<h4 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h4><p>作用：告诉编译器函数名称及如何调用函数，函数的实际主题可以单独定义</p>\n<ul>\n<li>函数的声明可以有多次，但是函数的定义只能有一次</li>\n</ul>\n<h4 id=\"函数的分文件编写\"><a href=\"#函数的分文件编写\" class=\"headerlink\" title=\"函数的分文件编写\"></a>函数的分文件编写</h4><p>作用：让代码结构更加清晰</p>\n<p>步骤：</p>\n<ol>\n<li>创建后缀名为.h的文件</li>\n<li>创建后缀名为.cpp的源文件</li>\n<li>在头文件中写函数的声明</li>\n<li>在源文件中写函数的定义</li>\n</ol>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"指针的基本概念\"><a href=\"#指针的基本概念\" class=\"headerlink\" title=\"指针的基本概念\"></a>指针的基本概念</h4><p>作用：可以通过指针间接访问内存</p>\n<h4 id=\"指针变量的定义和使用\"><a href=\"#指针变量的定义和使用\" class=\"headerlink\" title=\"指针变量的定义和使用\"></a>指针变量的定义和使用</h4><p>指针变量定义语法：<code>数据类型 * 变量名;</code></p>\n<p>解引用： *p 取指针指向地址的值</p>\n<h4 id=\"指针所占内存空间\"><a href=\"#指针所占内存空间\" class=\"headerlink\" title=\"指针所占内存空间\"></a>指针所占内存空间</h4><p>各种类型的指针所占的内存空间相同</p>\n<p>在32位操作系统下占4个字节</p>\n<p>在64位操作系统下占8个字节</p>\n<h4 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h4><p>指针变量指向内存中编号为0的空间</p>\n<p>用途：初始化指针变量</p>\n<p>注意：空指针指向的内存是不可以访问的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">0~255号内存编号是系统占用的，不可以访问</font></p>\n<h4 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h4><p>指针变量指向非法的内存空间</p>\n<p><font color=\"red\">在程序中要避免出现野指针</font></p>\n<h4 id=\"const修饰指针\"><a href=\"#const修饰指针\" class=\"headerlink\" title=\"const修饰指针\"></a>const修饰指针</h4><ol>\n<li><p>const修饰指针     常量指针</p>\n<ul>\n<li>特点：指针的指向可以修改，指针指向的值不可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p;</span><br></pre></td></tr></table></figure></li>\n<li><p>const修饰常量     指针常量</p>\n<ul>\n<li>特点：指针的指向不可以修改，指针指向的值可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p;</span><br></pre></td></tr></table></figure></li>\n<li><p>const既修饰指针，又修饰常量</p>\n<ul>\n<li>特点：指针的指向和指针指向的值都不可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h4><p>利用指针访问数组中的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;\t<span class=\"comment\">//arr就是数组首地址</span></span><br><span class=\"line\">cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//输出数组中的第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">p++;\t\t\t<span class=\"comment\">//指针向后偏移4个字节</span></span><br><span class=\"line\">cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//此时输出的是数组中的第二个元素</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"指针和函数\"><a href=\"#指针和函数\" class=\"headerlink\" title=\"指针和函数\"></a>指针和函数</h4><ol>\n<li><p>值传递</p>\n</li>\n<li><p>地址传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *p1,<span class=\"keyword\">int</span> *p2)</span></span>&#123;\t<span class=\"comment\">//用指针来接收参数，因为参数是地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *p1;\t\t\t<span class=\"comment\">//用星号来解引用</span></span><br><span class=\"line\">\t*p1 = *p2;</span><br><span class=\"line\">\t*p2 = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(&amp;a,&amp;b);\t\t\t<span class=\"comment\">//传入地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><h4 id=\"结构体的基本概念\"><a href=\"#结构体的基本概念\" class=\"headerlink\" title=\"结构体的基本概念\"></a>结构体的基本概念</h4><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>\n<h4 id=\"结构体的定义和使用\"><a href=\"#结构体的定义和使用\" class=\"headerlink\" title=\"结构体的定义和使用\"></a>结构体的定义和使用</h4><p>语法：<code>struct 结构体名 &#123;结构体成员列表&#125;;</code></p>\n<p>通过结构体创建变量的方式有三种：</p>\n<ul>\n<li>struct 结构体名 变量名 (再通过   .成员名   来进行赋值 )</li>\n<li>struct 结构体名 变量名 = {成员1值，成员2值……}</li>\n<li>定义结构体时顺便创建变量</li>\n</ul>\n<p>总结：</p>\n<ol>\n<li>定义结构体时的关键字是struct，不能省略</li>\n<li>创建结构体变量时，关键字struct可以省略</li>\n</ol>\n<h4 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h4><p>作用：将自定义的结构体放入到数组中方便维护</p>\n<p>语法：<code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125; , &#123;&#125; , &#123;&#125; , ...&#123;&#125; &#125;</code></p>\n<p>​            在{}中就将数据元素的值全部定义完成</p>\n<p><font color=\"red\">结构体数组传入函数参数中的是地址</font></p>\n<h4 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h4><p>作用：通过指针访问结构体中的成员</p>\n<ul>\n<li>利用操作符-&gt;可以通过结构体指针访问结构体属性</li>\n</ul>\n<h4 id=\"结构体嵌套结构体\"><a href=\"#结构体嵌套结构体\" class=\"headerlink\" title=\"结构体嵌套结构体\"></a>结构体嵌套结构体</h4><p>先定义被嵌套的结构体，然后再定义嵌套结构体</p>\n<p>访问的时候直接用两个 . 号来访问嵌套结构体中的内容</p>\n<h4 id=\"结构体做函数参数\"><a href=\"#结构体做函数参数\" class=\"headerlink\" title=\"结构体做函数参数\"></a>结构体做函数参数</h4><ol>\n<li><p>值传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent1</span><span class=\"params\">(struct student s)</span></span>&#123;</span><br><span class=\"line\">\tcout&lt;&lt;s.name&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;s.age&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;s.score&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span></span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ts = ...;</span><br><span class=\"line\">    <span class=\"built_in\">printstudent1</span>(s);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>地址传递</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent2</span><span class=\"params\">(struct student *p)</span></span>&#123;\t\t\t\t<span class=\"comment\">//用一个指针来接收地址</span></span><br><span class=\"line\">\tcout&lt;&lt;p-&gt;name&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;p-&gt;age&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;p-&gt;score&lt;&lt;endl;\t<span class=\"comment\">//用箭头访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span></span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ts = ...;</span><br><span class=\"line\">    <span class=\"built_in\">printstudent</span>(&amp;s);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"结构体中const使用场景\"><a href=\"#结构体中const使用场景\" class=\"headerlink\" title=\"结构体中const使用场景\"></a>结构体中const使用场景</h4><p>作用：用const来防止误操作</p>\n<p>在用结构体做函数参数时，用地址传递，可以节省内存空间，而且不会复制一个新的副本出来</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printstudent</span><span class=\"params\">(<span class=\"keyword\">const</span> student *p)</span></span>&#123;\t<span class=\"comment\">//用const可以避免对数据进行误修改</span></span><br><span class=\"line\">\tp-&gt;name = <span class=\"string\">&quot;李四&quot;</span>;\t\t<span class=\"comment\">//此时修改不合法</span></span><br><span class=\"line\">\tcout&lt;&lt;p-&gt;name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"C-核心编程\"><a href=\"#C-核心编程\" class=\"headerlink\" title=\"C++核心编程\"></a>C++核心编程</h2><p>针对C++面向对象编程技术</p>\n<h3 id=\"内存分区模型\"><a href=\"#内存分区模型\" class=\"headerlink\" title=\"内存分区模型\"></a>内存分区模型</h3><p>C++程序在执行时，将内存大方向划分为四个区域</p>\n<ul>\n<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>\n<li>全局区：存放全局变量和静态变量以及常量</li>\n<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>\n</ul>\n<p><strong>内存四区意义：</strong></p>\n<p>不同区域存放的数据，赋予不同的生命周期，使编程更灵活</p>\n<h4 id=\"程序运行前\"><a href=\"#程序运行前\" class=\"headerlink\" title=\"程序运行前\"></a>程序运行前</h4><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>\n<p><strong>代码区：</strong></p>\n<p>​        存放CPU执行的机器指令</p>\n<p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p><strong>全局区：</strong></p>\n<p>​        全局变量和静态变量存放在此</p>\n<p>​        全局区还包括了常量区，字符串常量和其他常量也存放在此</p>\n<p>​        该区域的数据在程序结束后由操作系统释放</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局变量，存放在全局区中</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//const修饰的全局变量，全局常量，存放在常量区中（全局区）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c_g_a = <span class=\"number\">10</span>；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部变量，不在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//静态变量，存放在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//常量</span></span><br><span class=\"line\">    <span class=\"comment\">//字符串常量,存放在常量区（全局区）中</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;字符串常量的地址为：&quot;</span>&lt;&lt;(<span class=\"keyword\">int</span>)&amp;<span class=\"string\">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">   \t</span><br><span class=\"line\">    <span class=\"comment\">//const修饰的变量</span></span><br><span class=\"line\">    <span class=\"comment\">//const修饰的全局变量,存放在全局区中</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//const修饰的局部变量,局部常量，不存放在全局区中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c_l_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"程序运行后\"><a href=\"#程序运行后\" class=\"headerlink\" title=\"程序运行后\"></a>程序运行后</h4><p><strong>栈区：</strong></p>\n<p>​        由编译器自动分配释放，存放函数的参数值，局部变量等</p>\n<p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//形参数据也会放在栈区</span></span><br><span class=\"line\">    b = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;\t<span class=\"comment\">//局部变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;a;\t<span class=\"comment\">//返回局部变量地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//接收func函数的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//第一次可以打印是因为编译器做了保留</span></span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;\t<span class=\"comment\">//第二次数据不再保留</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>堆区：</strong></p>\n<p>​        由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>\n<p>​        在C++中主要利用new在堆区开辟内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//利用new关键字，可以将数据开辟到堆区</span></span><br><span class=\"line\">    <span class=\"comment\">//指针 本质也是局部变量，放在栈上，指针保存的数据是放在堆区</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> *p =  <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"new操作符\"><a href=\"#new操作符\" class=\"headerlink\" title=\"new操作符\"></a>new操作符</h4><p>C++中利用new操作符在堆区开辟数据</p>\n<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p>\n<p>语法：<code>new 数据类型</code></p>\n<p>利用new创建的数据，会返回该数据类型对应的类型的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、new的基本语法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在堆区创建整型数据</span></span><br><span class=\"line\">    <span class=\"comment\">//new 返回是该数据类型的指针</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//堆区的数据 由程序员开辟由程序员释放</span></span><br><span class=\"line\">    <span class=\"comment\">//如果想释放堆区的数据，利用关键字delete</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    <span class=\"comment\">//cout&lt;&lt;*p&lt;&lt;endl;//内存已经被释放，不能再次访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、在堆区用new开辟数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在堆区创建10个整型数据的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];\t<span class=\"comment\">//10代表元素个数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//释放堆区数组，要加入中括号</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> test01;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> test02;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><h4 id=\"引用的基本使用\"><a href=\"#引用的基本使用\" class=\"headerlink\" title=\"引用的基本使用\"></a>引用的基本使用</h4><p><strong>作用：</strong>给变量起别名</p>\n<p><strong>语法：</strong><code>数据类型 &amp;别名 = 原名</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用注意事项\"><a href=\"#引用注意事项\" class=\"headerlink\" title=\"引用注意事项\"></a>引用注意事项</h4><ul>\n<li>引用必须初始化</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;b; <span class=\"comment\">//错误</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>引用在初始化后不能发生改变</li>\n</ul>\n<h4 id=\"引用做函数参数\"><a href=\"#引用做函数参数\" class=\"headerlink\" title=\"引用做函数参数\"></a>引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p><strong>优点：</strong>可以简化指针修改实参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//值传递,形参不改变实参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap01</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap02</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引用传递,形参修饰实参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap03</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a,<span class=\"keyword\">int</span> &amp;b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap01</span>(a,b);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">swap02</span>(&amp;a,&amp;b);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">swap03</span>(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用做函数返回值\"><a href=\"#引用做函数返回值\" class=\"headerlink\" title=\"引用做函数返回值\"></a>引用做函数返回值</h4><p><strong>注意：</strong>不要返回局部变量的引用（与 内存分区模型-程序运行后-栈区 中的例子类似，不能返回局部变量的地址）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//局部变量，存放在栈区</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = <span class=\"built_in\">test01</span>();\t<span class=\"comment\">//test01函数的返回值也是引用类型  但是这种做法是错误的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>函数调用可以作为左值存在</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;\t<span class=\"comment\">//静态变量，存放在全局区，程序结束后由系统释放</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">test02</span>() = <span class=\"number\">1000</span>;\t<span class=\"comment\">//函数返回变量的引用，相当于返回变量，相当于 a = 1000；</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h4><p><strong>本质：</strong>引用的本质在C++内部实现是一个指针常量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;ref)</span></span>&#123;</span><br><span class=\"line\">    ref = <span class=\"number\">100</span>;\t<span class=\"comment\">//ref是引用，转换为*ref = 100；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//自动转换为int * const ref = &amp;a; 指针常量是指针的指向不能改，引用不能改的原因</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = a;</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;\t<span class=\"comment\">//内部发现ref是引用，转换为 *ref = 20;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作都由编译器完成</p>\n<h4 id=\"常量引用\"><a href=\"#常量引用\" class=\"headerlink\" title=\"常量引用\"></a>常量引用</h4><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作（结构体-结构体中const使用场景类似）</p>\n<p>在函数参数列表中，可以加const修饰形参，防止形参改变实参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShowValue</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; val)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//val = 1000;\t如果形参中不加const 会对实参进行修改</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;val=&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;ref = <span class=\"number\">10</span>;\t<span class=\"comment\">//错误，10在常量区，不是引用合法内存空间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;ref = a;\t<span class=\"comment\">//正确</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//加上const之后，编译器将代码修改为 int temp = 10;int &amp;ref = temp;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ref = <span class=\"number\">10</span>;\t</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;\t<span class=\"comment\">//错误，加入const后变为只读，不能修改</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">ShowValue</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"函数提高\"><a href=\"#函数提高\" class=\"headerlink\" title=\"函数提高\"></a>函数提高</h3><h4 id=\"函数默认参数\"><a href=\"#函数默认参数\" class=\"headerlink\" title=\"函数默认参数\"></a>函数默认参数</h4><p>语法：<code>返回值类型 函数名 （形参 = 默认值）&#123;&#125;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项：</p>\n<p>1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</p>\n<p>2、如果函数的声明有了默认参数，函数实现就不能有默认参数（声明和实现只能一个有默认参数）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func2(int a = 10,int b = 10);\t//函数声明</span><br><span class=\"line\"></span><br><span class=\"line\">int func2(int a,int b)&#123;\t\t\t\t//函数实现，此时就不能再用默认参数了</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数占位参数\"><a href=\"#函数占位参数\" class=\"headerlink\" title=\"函数占位参数\"></a>函数占位参数</h4><p>函数的形参列表中可以有占位参数，但是函数调用时必须填补该位置</p>\n<p>语法：<code>返回值类型 函数名 （数据类型） &#123;&#125;</code></p>\n<p>占位参数可以有默认参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;this is func&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//占位参数有默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">    ......;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前用不到，后面会用到</p>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><h5 id=\"函数重载概述\"><a href=\"#函数重载概述\" class=\"headerlink\" title=\"函数重载概述\"></a>函数重载概述</h5><p><strong>作用：</strong>函数名可以相同，提高复用性</p>\n<p><strong>函数重载满足条件：</strong></p>\n<ul>\n<li>同一个作用域下（全局、局部）</li>\n<li>函数名称相同</li>\n<li>函数参数 <strong>类型不同</strong> 或者<strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>\n</ul>\n<p><strong>注意：</strong>函数的返回值不可以作为函数重载的条件</p>\n<h5 id=\"函数重载注意事项\"><a href=\"#函数重载注意事项\" class=\"headerlink\" title=\"函数重载注意事项\"></a>函数重载注意事项</h5><ul>\n<li>引用作为重载条件</li>\n<li>函数重载碰到默认参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、引用作为重载的条件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a)</span></span>&#123;\t<span class=\"comment\">//int &amp;a = 10; 不合法，10在常量区</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;func(int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;a)</span></span>&#123;\t<span class=\"comment\">//const int &amp;a = 10; 编译器优化，创建临时空间，合法</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;func(const int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(a);\t<span class=\"comment\">//调用第一个函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//调用第二个函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、函数重载碰到默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;func2的调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;func2的调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func2</span>(<span class=\"number\">10</span>);\t\t<span class=\"comment\">//错误，此时两个函数都能被调用，出现二义性，尽量避免</span></span><br><span class=\"line\">&#125;\t\t\t\t\t<span class=\"comment\">//函数重载时尽量不用默认参数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h3><p>C++面向对象的三大特性为：封装、继承、多态</p>\n<p>C++认为万事万物都是对象，对象上有其属性和行为</p>\n<p><strong>例：</strong></p>\n<p>​    人可以作为对象，属性有姓名、年龄、性别…行为有走、跑、跳、吃饭</p>\n<p>​    车也可以作为对象，属性有轮胎、方向盘…行为有载人、开空调、放音乐</p>\n<p>​    具有<font color=\"red\">相同性质的对象</font>，我们可以抽象为<font color=\"red\">类</font>，人属于人类，车属于车类</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是C++面向对象的三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的食物</li>\n<li>对属性和行为加以权限控制</li>\n</ul>\n<h5 id=\"封装意义1\"><a href=\"#封装意义1\" class=\"headerlink\" title=\"封装意义1\"></a><strong>封装意义1</strong></h5><p>​    在设计类的时候，行为和属性写在一起，表现事务</p>\n<p><strong>语法：</strong><code>class 类名 &#123; 访问权限 ： 属性 / 行为 &#125;;</code></p>\n<p>例：设计一个圆类，求圆的周长</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//访问权限-公共权限</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//类中的属性和行为，统一称为 成员</span></span><br><span class=\"line\">    <span class=\"comment\">//属性\t成员属性 成员变量</span></span><br><span class=\"line\">    <span class=\"comment\">//行为\t成员函数 成员方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_r;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//行为</span></span><br><span class=\"line\">    <span class=\"comment\">//获取圆的周长</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">calculateZC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span> * pi *m_r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;\t\t<span class=\"comment\">//记得分号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过圆类来创建一个具体的圆（对象）</span></span><br><span class=\"line\">    <span class=\"comment\">//实例化（通过一个类，创建一个对象的过程）</span></span><br><span class=\"line\">    Circle c1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//给圆对象 属性进行赋值操作</span></span><br><span class=\"line\">    c1.m_r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取圆的周长</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;圆的周长为：&quot;</span>&lt;&lt;c1.<span class=\"built_in\">calculateZC</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"封装意义2\"><a href=\"#封装意义2\" class=\"headerlink\" title=\"封装意义2\"></a><strong>封装意义2</strong></h5><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<ol>\n<li>public         公共权限</li>\n<li>protected   保护权限</li>\n<li>private        私有权限</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//公共权限 public \t\t成员 类内可以访问 类外可以访问</span></span><br><span class=\"line\"><span class=\"comment\">//保护权限 protected\t成员 类内可以访问 类外不可以访问 儿子可以访问父亲中保护内容</span></span><br><span class=\"line\"><span class=\"comment\">//私有权限 private \t\t成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中私有内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">Public:   </span><br><span class=\"line\">    <span class=\"comment\">//公共权限</span></span><br><span class=\"line\">    string m_Name;\t<span class=\"comment\">//姓名</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Protected:</span><br><span class=\"line\">    <span class=\"comment\">//保护权限</span></span><br><span class=\"line\">    string m_car;\t<span class=\"comment\">//汽车</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Private:</span><br><span class=\"line\">    <span class=\"comment\">//私有权限</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> password;\t<span class=\"comment\">//密码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">Public:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        m_Name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">        m_Car = <span class=\"string\">&quot;比亚迪&quot;</span>;</span><br><span class=\"line\">        m_password = <span class=\"string\">&quot;123456&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化一个具体的对象</span></span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    p1.m_Name = <span class=\"string\">&quot;李四&quot;</span>;\t\t<span class=\"comment\">//可以访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p1.m_Car = &quot;奔驰&quot;;\t\t//此时错误，保护权限在类外不可以访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p1.m_password = &quot;123&quot;;\t\t//错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>struct和class的区别</p>\n<p>在C++中struct和class的唯一区别就在于 <strong>默认的访问权限不同</strong></p>\n<p>区别：</p>\n<ul>\n<li>struct默认权限为公共</li>\n<li>class默认权限为私有</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//默认权限为私有  </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//默认权限为公共</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    C1 c1;</span><br><span class=\"line\">    <span class=\"comment\">//c1.m_A = 100;\t//错误,权限为私有</span></span><br><span class=\"line\">    C2 c2;</span><br><span class=\"line\">    c2.m_A = <span class=\"number\">100</span>;\t<span class=\"comment\">//正确，权限为公共</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"成员属性设置为私有\"><a href=\"#成员属性设置为私有\" class=\"headerlink\" title=\"成员属性设置为私有\"></a>成员属性设置为私有</h5><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己设置读写权限</p>\n<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\">Public:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置姓名</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">        m_Name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取姓名</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_Name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取年龄 可读可写\t如果想修改，年龄必须在0~150之间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//m_Age = 0;\t//初始化为0岁</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_Age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置年龄</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age &lt; <span class=\"number\">0</span> || age &gt; <span class=\"number\">150</span>)&#123;</span><br><span class=\"line\">            m_Age = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;年龄有误&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m_Age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置情人 只写</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLover</span><span class=\"params\">(string lover)</span></span>&#123;</span><br><span class=\"line\">        m_Lover = lover;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">Private:</span><br><span class=\"line\">    <span class=\"comment\">//姓名\t可读可写</span></span><br><span class=\"line\">    String m_Name;</span><br><span class=\"line\">    <span class=\"comment\">//年龄\t只读</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">    <span class=\"comment\">//伴侣\t只写</span></span><br><span class=\"line\">    string m_Lover;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"comment\">//p.m_Name = &quot;张三&quot;;\t//错误 私有权限不能访问</span></span><br><span class=\"line\">    p.<span class=\"built_in\">setName</span>(<span class=\"string\">&quot;张三&quot;</span>);\t<span class=\"comment\">//正确 公共权限函数访问</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;姓名为：&quot;</span>&lt;&lt;p.<span class=\"built_in\">getName</span>()&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//p.m_Age = 18;\t\t//错误 私有权限不能访问</span></span><br><span class=\"line\">    <span class=\"comment\">//p.setAge(18);\t\t//错误 没有这个函数\t\t</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;年龄为：&quot;</span>&lt;&lt;p.<span class=\"built_in\">getAge</span>()&lt;&lt;endl; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置情人</span></span><br><span class=\"line\">    p.<span class=\"built_in\">setLover</span>(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//cout&lt;&lt;&quot;情人为：&quot;&lt;&lt;p.m_Lover&lt;&lt;endl;\t//错误 私有权限不能访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"头文件与源文件分离\"><a href=\"#头文件与源文件分离\" class=\"headerlink\" title=\"头文件与源文件分离\"></a>头文件与源文件分离</h5><p>头文件.h中写函数定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once\t\t<span class=\"comment\">//为了避免一个头文件被包含多次</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xxx.h&gt;</span>\t<span class=\"comment\">//若其中使用到了其他类的内容，只需要包含所用类的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;\t\t<span class=\"comment\">//只做函数声明</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>cpp文件中写函数实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xxx.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx::func</span><span class=\"params\">()</span></span>&#123;\t<span class=\"comment\">//xxx:: 说明是成员函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//函数实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"对象特性\"><a href=\"#对象特性\" class=\"headerlink\" title=\"对象特性\"></a>对象特性</h4><p>C++中的面对对象来源于生活，每个对象有初始设置和对象销毁前的清理数据的设置</p>\n<h5 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h5><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>\n<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​    同样的使用完一个对象或变量，没有即时清理，也会造成一定的安全问题</p>\n<p>C++利用构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器提供的构造和析构函数是空实现</strong></p>\n<ul>\n<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，由编译器自动调用，无须手动</li>\n<li>析构函数：主要作用在于对象<strong>销毁前</strong>自动调用，执行一些清理工作</li>\n</ul>\n<p>构造函数语法：<code>类名()&#123;&#125;</code></p>\n<ol>\n<li>构造函数，没有返回值也不写void</li>\n<li>函数名称和类名相同</li>\n<li>构造函数可以有参数，因此可以发生重载</li>\n<li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li>\n<li>前面要写作用域</li>\n</ol>\n<p>析构函数语法：<code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>析构函数，没有返回值也不写void</li>\n<li>函数名称和类名相同，在名称前面多加一个~</li>\n<li>析构函数不能有参数，不能发生重载</li>\n<li>程序在对象销毁前会自动调用析构，因此无须手动调用，而且只会调用一次</li>\n</ol>\n<h5 id=\"构造函数的分类及调用\"><a href=\"#构造函数的分类及调用\" class=\"headerlink\" title=\"构造函数的分类及调用\"></a>构造函数的分类及调用</h5><p>两种分类方式：</p>\n<p>​    按参数分为：有参构造和无参构造</p>\n<p>​    按类型分为：普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​    括号法</p>\n<p>​    显示法</p>\n<p>​    隐式转换法</p>\n<p>分类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:\t</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;无参函数构造调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a)&#123;</span><br><span class=\"line\">        age = a;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;有参函数构造调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)&#123;\t<span class=\"comment\">//避免对p本身进行修改，结构体中const的应用 类似</span></span><br><span class=\"line\">        <span class=\"comment\">//将传入的人身上的所有属性，拷贝到自身</span></span><br><span class=\"line\">        age = p.age;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~<span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1、括号法</span></span><br><span class=\"line\">    Person p1;\t<span class=\"comment\">//函数默认构造函数调用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;\t<span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数调用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p3</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//注意事项1</span></span><br><span class=\"line\">    <span class=\"comment\">//调用默认构造函数时，不要加括号（）</span></span><br><span class=\"line\">    <span class=\"comment\">//Person p1();\t//这行代码会被认为是函数的声明，不会认为是在创建对象</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2、显示法</span></span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    Person p2 = <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//有参构造</span></span><br><span class=\"line\">    Person p3 = <span class=\"built_in\">Person</span>(p2);\t<span class=\"comment\">//拷贝构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//匿名对象 特点，当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class=\"line\">    <span class=\"comment\">//注意事项2</span></span><br><span class=\"line\">    <span class=\"comment\">//不要利用拷贝构造函数 初始化匿名对象 编译器会认为Person(p3) === Person(p3);</span></span><br><span class=\"line\">    <span class=\"comment\">//编译器会认为是对象的声明</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(p3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3、隐式转换法</span></span><br><span class=\"line\">    Person p4 = <span class=\"number\">10</span>;\t<span class=\"comment\">//相当于写了 Person p4 = Person(10);</span></span><br><span class=\"line\">    Person p5 = p4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"拷贝构造函数调用时机\"><a href=\"#拷贝构造函数调用时机\" class=\"headerlink\" title=\"拷贝构造函数调用时机\"></a>拷贝构造函数调用时机</h5><p>C++中拷贝函数调用时机通常有三种情况</p>\n<ul>\n<li>使用一个已经创建完毕的对象来初始化一个对象</li>\n<li>值传递的方式给函数参数传值</li>\n<li>以值方式返回局部对象</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的默认构造函数调用&quot;</span>&lt;&lt;endl;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Peson</span>(<span class=\"keyword\">int</span> age)&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = p.m_Age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~<span class=\"built_in\">Person</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Person的析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.值传递的方式给函数参数传值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person p)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    <span class=\"built_in\">doWork</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.值方式返回局部对象</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">doWork2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>*)&amp;p1&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tPerson p = <span class=\"built_in\">doWork2</span>();</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>*)p &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"构造函数的调用规则\"><a href=\"#构造函数的调用规则\" class=\"headerlink\" title=\"构造函数的调用规则\"></a>构造函数的调用规则</h5><p>默认情况下，c++编译器至少给类添加三个函数</p>\n<p>1.默认构造函数（无参，函数体为空）</p>\n<p>2.默认析构函数（无参，函数体为空）</p>\n<p>3.默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则：</p>\n<ul>\n<li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>\n<li>如果用户定义拷贝构造函数，c++不再提供其他构造函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数的调用规则</span></span><br><span class=\"line\"><span class=\"comment\">//1.创建一个类，c++编译器会给每个类都添加至少三个函数</span></span><br><span class=\"line\"><span class=\"comment\">//默认构造 （空实现）</span></span><br><span class=\"line\"><span class=\"comment\">//析构函数 （空实现）</span></span><br><span class=\"line\"><span class=\"comment\">//拷贝构造 （值拷贝）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = p.m_Age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.m_Age = <span class=\"number\">18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;p2的年龄是：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Person p;\t<span class=\"comment\">//如果有 有参构造函数定义，没有自己定义的默认构造函数，就会报错，因为</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">//此时系统也不会提供默认构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h5><p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age, <span class=\"keyword\">int</span> height)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\tm_Age = age;</span><br><span class=\"line\">        m_Height = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//自己实现拷贝构造函数 解决浅拷贝带来的问题</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> Person &amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt; <span class=\"string\">&quot;Person 拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        m_Age = p.m_Age;</span><br><span class=\"line\">        <span class=\"comment\">//m_Height = p.m_Height;\t编译器默认实现就是这行代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//深拷贝操作</span></span><br><span class=\"line\">        m_Height = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*p.m_Height);\t<span class=\"comment\">//解引用来获得m_Height的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Person(const Person &amp;p)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t  cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t  m_Age = p.m_Age;</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m_Height != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_Height;</span><br><span class=\"line\">            m_Height = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//防止野指针出现</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Person的默认析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_Age;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *m_Height; <span class=\"comment\">//new新建开辟到堆区，用指针接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>,<span class=\"number\">160</span>)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p1的年龄为:&quot;</span>&lt;&lt;p1.m_Age&lt;&lt;<span class=\"string\">&quot;  身高为:&quot;</span>&lt;&lt;p1.m_Height&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p2的年龄为:&quot;</span>&lt;&lt;p2.m_Age&lt;&lt;<span class=\"string\">&quot;  身高为:&quot;</span>&lt;&lt;p2.m_Height&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//此时会出错 默认拷贝函数将 int *m_Height 中的全部内容拷贝过去</span></span><br><span class=\"line\">    <span class=\"comment\">//p2 和 p1 在函数运行结束后都会进行析构函数释放 m_Height 内存的操作 </span></span><br><span class=\"line\">    <span class=\"comment\">//重复释放，非法操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>浅拷贝带来的问题就是堆区的内存重复释放</p>\n<p><font color=\"red\"> 浅拷贝的问题，要利用深拷贝来进行解决</font>，即给使用拷贝构造的函数也申请一块新的内存空间</p>\n<p><strong>总结：</strong></p>\n<p><font color=\"red\">如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</font></p>\n<h5 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h5><p>作用：用来初始化属性</p>\n<p><strong>语法：</strong><code> 构造函数():属性1(值1)，属性2(值2)...&#123;&#125;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//传统初始化操作</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_A = a;</span><br><span class=\"line\">        m_B = b;</span><br><span class=\"line\">        m_C = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_B;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_C;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化列表初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>():<span class=\"built_in\">m_A</span>(<span class=\"number\">10</span>),<span class=\"built_in\">m_B</span>(<span class=\"number\">20</span>).<span class=\"built_in\">m_C</span>(<span class=\"number\">30</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//更灵活的方式初始化列表初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c):<span class=\"built_in\">m_A</span>(a),<span class=\"built_in\">m_B</span>(b).<span class=\"built_in\">m_C</span>(c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Person p(10,20,30);\t普通构造</span></span><br><span class=\"line\">    Person p;\t\t\t\t初始化列表构造</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">30</span>,<span class=\"number\">20</span>,<span class=\"number\">10</span>)</span></span>;\t\t第三种构造</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_A = &quot;</span>&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_B = &quot;</span>&lt;&lt;p.m_B&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;m_C = &quot;</span>&lt;&lt;p.m_C&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"类对象作为类成员\"><a href=\"#类对象作为类成员\" class=\"headerlink\" title=\"类对象作为类成员\"></a>类对象作为类成员</h5><p>C++中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">\tA a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>B类中有对象A作为成员，A为对象成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">phone</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">phone</span>(string PName)&#123;</span><br><span class=\"line\">\t\tm_PName = pName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstring m_PName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Phone m_Phone = pName;\t隐式转换法</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(string name, string pName):<span class=\"built_in\">m_Name</span>(name),<span class=\"built_in\">m_Phone</span>(PName)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//姓名</span></span><br><span class=\"line\">\tstring m_Nname;</span><br><span class=\"line\">\t<span class=\"comment\">//手机</span></span><br><span class=\"line\">\tPhone m_Phone;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"string\">&quot;张三&quot;</span>,<span class=\"string\">&quot;苹果&quot;</span>)</span>；</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><font color=\"red\">其他类的对象作为本类的成员时，构造时候先构造类对象，再构造自身，析构的顺序与构造相反，先析构本类，然后在析构其他类</font></p>\n<h5 id=\"静态成员和静态成员函数\"><a href=\"#静态成员和静态成员函数\" class=\"headerlink\" title=\"静态成员和静态成员函数\"></a>静态成员和静态成员函数</h5><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>\n<p>静态成员分为：</p>\n<ul>\n<li>静态成员变量<ul>\n<li>所有对象共享同一份数据</li>\n<li>在编译阶段分配内存</li>\n<li>类内声明，类外初始化</li>\n</ul>\n</li>\n<li>静态成员函数<ul>\n<li>所有对象共享同一个函数</li>\n<li>静态成员函数只能访问静态成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//静态成员函数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">        m_A = <span class=\"number\">100</span>; <span class=\"comment\">//静态成员函数可以访问静态成员变量</span></span><br><span class=\"line\">        <span class=\"comment\">//m_B = 200; //静态成员函数 不可以访问 非静态成员变量，无法区分到底是哪个对象的m_B属性</span></span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;static void func调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//静态成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_B; <span class=\"comment\">//非静态成员变量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//静态成员函数也是有访问权限的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;static void func2()调用&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Person::m_A = <span class=\"number\">0</span>; <span class=\"comment\">//类外初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//两种访问方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1.通过对象访问</span></span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">    p.<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    <span class=\"comment\">//2.通过类名访问</span></span><br><span class=\"line\">    Person::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Person::func2();\t//类外访问不到私有静态成员函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    test01;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"C-对象模型和this指针\"><a href=\"#C-对象模型和this指针\" class=\"headerlink\" title=\"C++对象模型和this指针\"></a>C++对象模型和this指针</h4><h5 id=\"成员变量和成员函数分开存储\"><a href=\"#成员变量和成员函数分开存储\" class=\"headerlink\" title=\"成员变量和成员函数分开存储\"></a>成员变量和成员函数分开存储</h5><p>在C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_A;\t<span class=\"comment\">//非静态成员变量 属于类的对象上 只要不是空，就是原大小</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m_B;\t<span class=\"comment\">//静态成员变量 不属于类的对象上</span></span><br><span class=\"line\">    <span class=\"number\">88</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;&#125;\t<span class=\"comment\">//非静态成员函数 不属于类的对象上</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;&#125;\t<span class=\"comment\">//静态成员函数 不属于类的对象上</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\t<span class=\"comment\">//空对象占用空间内存空间为：1</span></span><br><span class=\"line\">    <span class=\"comment\">//C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class=\"line\">    <span class=\"comment\">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;size of p = &quot;</span>&lt;&lt;<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(p)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;size of p = &quot;</span>&lt;&lt;<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(p)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//test01();</span></span><br><span class=\"line\">    <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"this指针概念\"><a href=\"#this指针概念\" class=\"headerlink\" title=\"this指针概念\"></a>this指针概念</h5><p> 每一个非静态成员函数只会诞生一份函数实例，即多个同类型的对象会共用同一块代码，那么这一块代码如何区分哪个对象调用自己呢？</p>\n<p>C++通过提供特殊的对象指针，this指针来解决该问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>\n<p>this指针是隐含在每一个非静态成员函数内的一种指针</p>\n<p>this指针不需要定义，直接使用即可</p>\n<p>this指针的用途：</p>\n<ul>\n<li>当形参和成员变量同名时，可以用this指针来区分</li>\n<li>在类的非静态成员函数中返回对象本身，可以使用return *this</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">Public:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tage = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;\t<span class=\"comment\">//与构造函数中的参数相同了，应该加以区分 可以使用m_Age</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//m代表member</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//这里要加&amp;符号 不加&amp;代表以值的方式返回，会复制一份新的数据返回</span></span><br><span class=\"line\">    <span class=\"comment\">//相当于返回的不是p2 而是p2&#x27;\t引用的方式不会创建新的对象</span></span><br><span class=\"line\">    <span class=\"function\">Person&amp; <span class=\"title\">PersonAddAge</span><span class=\"params\">(Person &amp;p)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age += p.age;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//this是指向p2的指针，而*this指向的就是p2这个对象本体</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">正确的写法：</span><br><span class=\"line\">Public:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"keyword\">int</span> age)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//this指针指向被调用的成员函数所属的对象\t这里this指向p1</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.解决名称冲突</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p1的年龄为：&quot;</span>&lt;&lt;p1.age&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.返回对象本身用 *this\t可以一直做追加操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链式编程思想</span></span><br><span class=\"line\">    p2.<span class=\"built_in\">PersonAddAge</span>(p1).<span class=\"built_in\">PersonAddAge</span>(p1).<span class=\"built_in\">PersonAddAge</span>(p1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.age&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">test01</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"ttt","date":"2021-08-02T07:24:52.000Z","_content":"","source":"_posts/ttt.md","raw":"---\ntitle: ttt\ndate: 2021-08-02 15:24:52\ntags:\ncategories: 学习\n---\n","slug":"ttt","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flq000b80u62pqt55kt","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"test","wrong_pass_message":"密码错误哦~","date":"2021-09-07T04:53:07.000Z","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","description":null,"password":null,"sticky":null,"_content":"","source":"_posts/test.md","raw":"---\ntitle: test\nwrong_pass_message: 密码错误哦~\ndate: 2021-09-07 12:53:07\ntags:\ncategories:\ncover:\ndescription:\npassword:\nsticky:\n---\n","slug":"test","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fls000e80u65jhx949z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"哲学","date":"2021-08-03T15:01:50.000Z","description":"密码测试","password":"young","message":"输入密码查看！","wrong_pass_message":"密码错误哦~","sticky":null,"_content":"\n现在是两个电脑公用测试\n\n","source":"_posts/哲学.md","raw":"---\ntitle: 哲学\ndate: 2021-08-03 23:01:50\ntags:\ncategories: 感悟\ndescription: 密码测试\npassword: young\nmessage: 输入密码查看！\nwrong_pass_message: 密码错误哦~\nsticky: \n---\n\n现在是两个电脑公用测试\n\n","slug":"哲学","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flu000g80u6esz34spy","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"密码错误哦~\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\r\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"f2827d23a9f0e36abdaed027bd0dc2eb862c026f8035bfd07c6b7a7a026aff31\">6adc09e8c8e9d40ea8a65820195e72f53de78c023eb2d954a9a68907c51883b52a8991b93bea457abe02a90c6057a1082b6c24f061c8411f0a0fad748408cbf488b1533484c3184b34b527086a85d46d</script>\r\n  <div class=\"hbe hbe-content\">\r\n    <div class=\"hbe hbe-input hbe-input-default\">\r\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\r\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\r\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入密码查看！</span>\r\n      </label>\r\n    </div>\r\n  </div>\r\n</div>\r\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<p>现在是两个电脑公用测试</p>\n","encrypt":true},{"title":"关于蕾塞","date":"2021-08-06T07:53:13.000Z","description":"根据知乎“远川行”文章借鉴而写","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/pic2.zhimg.jpeg","_content":"\n乡下的老鼠和都市的老鼠，你选哪边？\n\n作为一个被强行进行人体实验而诞生的改造恶魔、游荡的亡国战士，波姆接近电次只是为了电锯恶魔的心脏。她的思想已经得到了解放，作为蕾塞的她想要爱与和平。在与电次接触的过程中她的想法摇摆了很多次，无论是表现出来的行为还是内心隐藏的感情，合二为一才是她。\n\n蕾塞的动机并不复杂，孤独限制了她的想象力。\n\n与电次的相遇是一场意想不到的邂逅。现代世界中的她是一个异端，但她遇到了因为种种原因同样是异端的电次，他们的心如此相似。她不知如何面对，她需要时间去确认，去想。没有人能拒绝有趣的同类，尤其是相似的灵魂。在电次身上能看到天真无知又不幸的自己，她被深深地吸引了，想要和他一起去完成心中的期望。她敞开了自己的心。\n\n她想做乡下的老鼠，因为乡下安逸，没有危险，不用生活在担惊受怕中。而单纯的电次只是因为想吃更好吃的食物选择了都市的老鼠，她也明白他的单纯，所以她不在意。她想去都市中带走电次，但是都市中有玛奇玛，一直绝对不能碰的猫，于是她又开始了思考。\n\n即使人互相之间很难理解，但是对蕾塞来说，这是她最后的机会。于是她决定哪怕只有心脏，也要带电次走。就算用暴力也要带走这只向往大都市的老鼠。此时她想带走的不是电锯恶魔的心脏而是电次的心脏。她想得到电次的“心”。\n\n直白而隐晦的话语，是她的表白。在喜欢的人面前，她永远是少女。爱可以言说，但是难以传递。如果不将愿望寄托在行动上，她可能就再也没有机会了。即使知道他的心里还有其他人，但是没关系，电次会是她的救赎，电次能填上她空洞的心。不知不觉执念已经生长起来。与电次的战斗，爆炸还没结束，但她想教给电次的东西还远远不够。\n\n两个人在海底纠缠，链锯让两个人拥抱在一起。\n\n在沙滩上睁开眼，她醒了。世界如此宽广，却没有两个人的容身之地。她进入了他的心，但是那里也装着她的天敌。蕾塞之前对电次还有其他目的，但现在她眼里只有电次。这些她都明白，所以她决定走了。带不走他的心，也带不走他的人，消失是最好的结局。但这一次，竟是电次来迟的接近。他慢了一步，此时她再不走，她怕自己会反悔。他约她在咖啡馆见面，她笑着拒绝然后消失在视野中。但她终究是反悔了。\n\n电次独自抱着花坐在咖啡馆中，直到天黑了蕾塞也没有来。他不知道的是，就在店外一个街道之隔的小巷中，蕾塞已经被猫抓走了。这一次，是电次醒了。他心意已决，但他才刚刚上路。她没有来，如同她最后的承诺。他们要怎么互相理解呢？况且他们也从来不是老鼠。对不起。他还什么都不知道。\n\n40话恋·花·电锯到52话失恋·花·电锯。这短短13话是《电锯人》真正打动我的地方。蕾塞，我的超人！\n\n对我而言，我也选择乡下的老鼠，我渴望平静而安逸的生活，但我也想要孤寂的灵魂间的碰撞，希望能和ta一起逃离都市。\n（PS：最近喜欢的角色都是短头发的，我觉得我xp改变了。我觉得短头发的女生都好独立勇敢！）\n","source":"_posts/关于蕾塞.md","raw":"---\ntitle: 关于蕾塞\ndate: 2021-08-06 15:53:13\ntags: \ncategories: 感悟\ndescription: 根据知乎“远川行”文章借鉴而写\ncover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/pic2.zhimg.jpeg\n---\n\n乡下的老鼠和都市的老鼠，你选哪边？\n\n作为一个被强行进行人体实验而诞生的改造恶魔、游荡的亡国战士，波姆接近电次只是为了电锯恶魔的心脏。她的思想已经得到了解放，作为蕾塞的她想要爱与和平。在与电次接触的过程中她的想法摇摆了很多次，无论是表现出来的行为还是内心隐藏的感情，合二为一才是她。\n\n蕾塞的动机并不复杂，孤独限制了她的想象力。\n\n与电次的相遇是一场意想不到的邂逅。现代世界中的她是一个异端，但她遇到了因为种种原因同样是异端的电次，他们的心如此相似。她不知如何面对，她需要时间去确认，去想。没有人能拒绝有趣的同类，尤其是相似的灵魂。在电次身上能看到天真无知又不幸的自己，她被深深地吸引了，想要和他一起去完成心中的期望。她敞开了自己的心。\n\n她想做乡下的老鼠，因为乡下安逸，没有危险，不用生活在担惊受怕中。而单纯的电次只是因为想吃更好吃的食物选择了都市的老鼠，她也明白他的单纯，所以她不在意。她想去都市中带走电次，但是都市中有玛奇玛，一直绝对不能碰的猫，于是她又开始了思考。\n\n即使人互相之间很难理解，但是对蕾塞来说，这是她最后的机会。于是她决定哪怕只有心脏，也要带电次走。就算用暴力也要带走这只向往大都市的老鼠。此时她想带走的不是电锯恶魔的心脏而是电次的心脏。她想得到电次的“心”。\n\n直白而隐晦的话语，是她的表白。在喜欢的人面前，她永远是少女。爱可以言说，但是难以传递。如果不将愿望寄托在行动上，她可能就再也没有机会了。即使知道他的心里还有其他人，但是没关系，电次会是她的救赎，电次能填上她空洞的心。不知不觉执念已经生长起来。与电次的战斗，爆炸还没结束，但她想教给电次的东西还远远不够。\n\n两个人在海底纠缠，链锯让两个人拥抱在一起。\n\n在沙滩上睁开眼，她醒了。世界如此宽广，却没有两个人的容身之地。她进入了他的心，但是那里也装着她的天敌。蕾塞之前对电次还有其他目的，但现在她眼里只有电次。这些她都明白，所以她决定走了。带不走他的心，也带不走他的人，消失是最好的结局。但这一次，竟是电次来迟的接近。他慢了一步，此时她再不走，她怕自己会反悔。他约她在咖啡馆见面，她笑着拒绝然后消失在视野中。但她终究是反悔了。\n\n电次独自抱着花坐在咖啡馆中，直到天黑了蕾塞也没有来。他不知道的是，就在店外一个街道之隔的小巷中，蕾塞已经被猫抓走了。这一次，是电次醒了。他心意已决，但他才刚刚上路。她没有来，如同她最后的承诺。他们要怎么互相理解呢？况且他们也从来不是老鼠。对不起。他还什么都不知道。\n\n40话恋·花·电锯到52话失恋·花·电锯。这短短13话是《电锯人》真正打动我的地方。蕾塞，我的超人！\n\n对我而言，我也选择乡下的老鼠，我渴望平静而安逸的生活，但我也想要孤寂的灵魂间的碰撞，希望能和ta一起逃离都市。\n（PS：最近喜欢的角色都是短头发的，我觉得我xp改变了。我觉得短头发的女生都好独立勇敢！）\n","slug":"关于蕾塞","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flv000m80u63y0edp2v","content":"<p>乡下的老鼠和都市的老鼠，你选哪边？</p>\n<p>作为一个被强行进行人体实验而诞生的改造恶魔、游荡的亡国战士，波姆接近电次只是为了电锯恶魔的心脏。她的思想已经得到了解放，作为蕾塞的她想要爱与和平。在与电次接触的过程中她的想法摇摆了很多次，无论是表现出来的行为还是内心隐藏的感情，合二为一才是她。</p>\n<p>蕾塞的动机并不复杂，孤独限制了她的想象力。</p>\n<p>与电次的相遇是一场意想不到的邂逅。现代世界中的她是一个异端，但她遇到了因为种种原因同样是异端的电次，他们的心如此相似。她不知如何面对，她需要时间去确认，去想。没有人能拒绝有趣的同类，尤其是相似的灵魂。在电次身上能看到天真无知又不幸的自己，她被深深地吸引了，想要和他一起去完成心中的期望。她敞开了自己的心。</p>\n<p>她想做乡下的老鼠，因为乡下安逸，没有危险，不用生活在担惊受怕中。而单纯的电次只是因为想吃更好吃的食物选择了都市的老鼠，她也明白他的单纯，所以她不在意。她想去都市中带走电次，但是都市中有玛奇玛，一直绝对不能碰的猫，于是她又开始了思考。</p>\n<p>即使人互相之间很难理解，但是对蕾塞来说，这是她最后的机会。于是她决定哪怕只有心脏，也要带电次走。就算用暴力也要带走这只向往大都市的老鼠。此时她想带走的不是电锯恶魔的心脏而是电次的心脏。她想得到电次的“心”。</p>\n<p>直白而隐晦的话语，是她的表白。在喜欢的人面前，她永远是少女。爱可以言说，但是难以传递。如果不将愿望寄托在行动上，她可能就再也没有机会了。即使知道他的心里还有其他人，但是没关系，电次会是她的救赎，电次能填上她空洞的心。不知不觉执念已经生长起来。与电次的战斗，爆炸还没结束，但她想教给电次的东西还远远不够。</p>\n<p>两个人在海底纠缠，链锯让两个人拥抱在一起。</p>\n<p>在沙滩上睁开眼，她醒了。世界如此宽广，却没有两个人的容身之地。她进入了他的心，但是那里也装着她的天敌。蕾塞之前对电次还有其他目的，但现在她眼里只有电次。这些她都明白，所以她决定走了。带不走他的心，也带不走他的人，消失是最好的结局。但这一次，竟是电次来迟的接近。他慢了一步，此时她再不走，她怕自己会反悔。他约她在咖啡馆见面，她笑着拒绝然后消失在视野中。但她终究是反悔了。</p>\n<p>电次独自抱着花坐在咖啡馆中，直到天黑了蕾塞也没有来。他不知道的是，就在店外一个街道之隔的小巷中，蕾塞已经被猫抓走了。这一次，是电次醒了。他心意已决，但他才刚刚上路。她没有来，如同她最后的承诺。他们要怎么互相理解呢？况且他们也从来不是老鼠。对不起。他还什么都不知道。</p>\n<p>40话恋·花·电锯到52话失恋·花·电锯。这短短13话是《电锯人》真正打动我的地方。蕾塞，我的超人！</p>\n<p>对我而言，我也选择乡下的老鼠，我渴望平静而安逸的生活，但我也想要孤寂的灵魂间的碰撞，希望能和ta一起逃离都市。<br>（PS：最近喜欢的角色都是短头发的，我觉得我xp改变了。我觉得短头发的女生都好独立勇敢！）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>乡下的老鼠和都市的老鼠，你选哪边？</p>\n<p>作为一个被强行进行人体实验而诞生的改造恶魔、游荡的亡国战士，波姆接近电次只是为了电锯恶魔的心脏。她的思想已经得到了解放，作为蕾塞的她想要爱与和平。在与电次接触的过程中她的想法摇摆了很多次，无论是表现出来的行为还是内心隐藏的感情，合二为一才是她。</p>\n<p>蕾塞的动机并不复杂，孤独限制了她的想象力。</p>\n<p>与电次的相遇是一场意想不到的邂逅。现代世界中的她是一个异端，但她遇到了因为种种原因同样是异端的电次，他们的心如此相似。她不知如何面对，她需要时间去确认，去想。没有人能拒绝有趣的同类，尤其是相似的灵魂。在电次身上能看到天真无知又不幸的自己，她被深深地吸引了，想要和他一起去完成心中的期望。她敞开了自己的心。</p>\n<p>她想做乡下的老鼠，因为乡下安逸，没有危险，不用生活在担惊受怕中。而单纯的电次只是因为想吃更好吃的食物选择了都市的老鼠，她也明白他的单纯，所以她不在意。她想去都市中带走电次，但是都市中有玛奇玛，一直绝对不能碰的猫，于是她又开始了思考。</p>\n<p>即使人互相之间很难理解，但是对蕾塞来说，这是她最后的机会。于是她决定哪怕只有心脏，也要带电次走。就算用暴力也要带走这只向往大都市的老鼠。此时她想带走的不是电锯恶魔的心脏而是电次的心脏。她想得到电次的“心”。</p>\n<p>直白而隐晦的话语，是她的表白。在喜欢的人面前，她永远是少女。爱可以言说，但是难以传递。如果不将愿望寄托在行动上，她可能就再也没有机会了。即使知道他的心里还有其他人，但是没关系，电次会是她的救赎，电次能填上她空洞的心。不知不觉执念已经生长起来。与电次的战斗，爆炸还没结束，但她想教给电次的东西还远远不够。</p>\n<p>两个人在海底纠缠，链锯让两个人拥抱在一起。</p>\n<p>在沙滩上睁开眼，她醒了。世界如此宽广，却没有两个人的容身之地。她进入了他的心，但是那里也装着她的天敌。蕾塞之前对电次还有其他目的，但现在她眼里只有电次。这些她都明白，所以她决定走了。带不走他的心，也带不走他的人，消失是最好的结局。但这一次，竟是电次来迟的接近。他慢了一步，此时她再不走，她怕自己会反悔。他约她在咖啡馆见面，她笑着拒绝然后消失在视野中。但她终究是反悔了。</p>\n<p>电次独自抱着花坐在咖啡馆中，直到天黑了蕾塞也没有来。他不知道的是，就在店外一个街道之隔的小巷中，蕾塞已经被猫抓走了。这一次，是电次醒了。他心意已决，但他才刚刚上路。她没有来，如同她最后的承诺。他们要怎么互相理解呢？况且他们也从来不是老鼠。对不起。他还什么都不知道。</p>\n<p>40话恋·花·电锯到52话失恋·花·电锯。这短短13话是《电锯人》真正打动我的地方。蕾塞，我的超人！</p>\n<p>对我而言，我也选择乡下的老鼠，我渴望平静而安逸的生活，但我也想要孤寂的灵魂间的碰撞，希望能和ta一起逃离都市。<br>（PS：最近喜欢的角色都是短头发的，我觉得我xp改变了。我觉得短头发的女生都好独立勇敢！）</p>\n"},{"title":"感悟","date":"2021-08-02T06:02:02.000Z","_content":"\n **事情的结果是这样子的**\n\n\n\n`Hello world`\n\n\n\n```c++\nprintfasasdasd\nasdda\n```\n\n\n\n------\n\n> 但是\n\n\n\n\n\n","source":"_posts/感悟.md","raw":"---\ntitle: 感悟\ndate: 2021-08-02 14:02:02\ntags:\ncategories: 哲学\n---\n\n **事情的结果是这样子的**\n\n\n\n`Hello world`\n\n\n\n```c++\nprintfasasdasd\nasdda\n```\n\n\n\n------\n\n> 但是\n\n\n\n\n\n","slug":"感悟","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7flx000o80u6ac03c4ln","content":"<p> <strong>事情的结果是这样子的</strong></p>\n<p><code>Hello world</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printfasasdasd</span><br><span class=\"line\">asdda</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<blockquote>\n<p>但是</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":"<p> <strong>事情的结果是这样子的</strong></p>\n<p><code>Hello world</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printfasasdasd</span><br><span class=\"line\">asdda</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<blockquote>\n<p>但是</p>\n</blockquote>\n"},{"title":"唱歌","wrong_pass_message":"密码错误哦~","date":"2021-08-07T15:35:09.000Z","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","description":null,"password":null,"sticky":null,"_content":"\n测试\n","source":"_posts/唱歌.md","raw":"---\ntitle: 唱歌\nwrong_pass_message: 密码错误哦~\ndate: 2021-08-07 23:35:09\ntags: \ncategories: 唱歌\ncover:\ndescription:\npassword:\nsticky:\n---\n\n测试\n","slug":"唱歌","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fly000r80u6b2yg5i5c","content":"<p>测试</p>\n","site":{"data":{}},"excerpt":"","more":"<p>测试</p>\n"},{"title":"计算机网络","wrong_pass_message":"密码错误哦~","date":"2021-09-24T06:49:24.000Z","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","description":null,"password":null,"sticky":null,"_content":"","source":"_posts/计算机网络.md","raw":"---\ntitle: 计算机网络\nwrong_pass_message: 密码错误哦~\ndate: 2021-09-24 14:49:24\ntags:\ncategories:\ncover:\ndescription:\npassword:\nsticky:\n---\n","slug":"计算机网络","published":1,"updated":"2021-09-24T06:49:24.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fm0000u80u63j398oub","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"阅读测试","date":"2021-08-04T02:20:42.000Z","_content":"","source":"_posts/阅读测试.md","raw":"---\ntitle: 阅读测试\ndate: 2021-08-04 10:20:42\ntags: \ncategories: 阅读\n---\n","slug":"阅读测试","published":1,"updated":"2021-09-13T03:15:48.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fm1000x80u6e6kb95c1","content":"","site":{"data":{}},"cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/top_img.png","excerpt":"","more":""},{"title":"数据结构","date":"2021-08-04T09:54:42.000Z","cover":"https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/DataStructure.png","description":"青岛大学-王卓《数据结构与算法基础》学习记录","_content":"\n<center>数据结构</center>\n\n---\n\n## <center>绪论</center>\n\n### 🎈数据结构的研究内容\n\n**计算机解决问题的步骤：**\n\n* 将问题抽象为<font color=\"red\">数学模型</font>\n* 设计算法\n* 编程、调试、运行\n\n\n\n**早期，计算机应用于数值计算：**\n\n* 分析问题，找出对象以及对象之间的关系\n* 建立数学方程\n* 求解\n\n\n\n**随着计算机应用领域的扩展，越来越多被用于非数值计算：**\n\n* 线性表\n* 树\n* 图\n\n以上都是“非数值计算”的程序设计问题\n\n\n\n> 综上所述，数据结构是一门研究<font color=\"red\">非数值计算的</font>程序设计中计算机的<font color=\"red\">操作对象</font>以及他们之间的<font color=\"red\">关系</font>和<font color=\"red\">操作</font>的学科。\n\n### 🎈基本概念和术语\n\n#### 数据、数据元素、数据项和数据对象\n\n1. 数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。\n\n   包括：\n\n* 数值型数据：整数、实数等\n* 非数值型数据：文字、图像、图形、声音等\n\n2. 数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。\n3. 数据项：构成数据元素的不可分割的最小单位\n\n> <font color=\"red\">以上三者之间的关系：</font>数据>数据元素>数据项\n\n4. 数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。\n\n   数据元素和数据对象与数据的关系的区别：\n\n* 数据元素是集合的个体\n* 数据对象是集合的子集\n\n#### 数据结构\n\n* 数据元素互相之间的关系称为<font color=\"red\">结构</font>\n\n* 是指相互之间存在一种或多种特定关系的数据元素集合\n\n* <font color=\"red\">包含以下三方面内容：</font>\n\n  1. 数据元素之间的逻辑关系，也称为<font color=\"red\">逻辑结构</font>\n  2. 数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color=\"red\">物理结构</font>或数据的<font color=\"red\">存储结构</font>\n  3. 数据的<font color=\"red\">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现\n\n* 数据结构的两个层次：\n\n  1. <font color=\"red\">逻辑结构：</font>是指数据对象中数据元素之间的互相关系\n\n     **逻辑结构的种类：**\n\n     划分方法一：\n\n     1. <font color=\"red\">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。\n     2. <font color=\"red\">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。\n\n     划分方法二：\n\n     1. <font color=\"red\">集合结构：</font>其中的数据元素只有<font color=\"red\">只属于一个集合</font>的关系\n     2. <font color=\"red\">线性结构：</font>数据元素存在<font color=\"red\">一对一</font>的线性关系\n     3. <font color=\"red\">树形结构：</font>数据元素存在<font color=\"red\">一对多</font>的线性关系\n     4. <font color=\"red\">图状/网状结构：</font>数据元素存在<font color=\"red\">多对多</font>的线性关系\n\n  2. <font color=\"red\">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式\n\n     **存储结构的种类：**\n\n     ​\t<font color=\"red\">四种基本的存储结构：</font>\n\n     ​\t1.<font color=\"red\">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示\n\n     ​\t2.<font color=\"red\">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示\n\n     ​\t3.<font color=\"red\">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）\n\n     ​\t4.<font color=\"red\">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址\n\n     **逻辑结构和存储结构之间的关系：**\n\n     * 存储结构是逻辑关系的映像与元素本身的映像\n     * 逻辑结构是数据结构的抽象，存储结构是数据结构的实现\n     * 两者综合起来建立了数据元素之间的结构关系\n\n\n#### 数据类型\n\n数据类型(Data Type):是指一组性质相同的<font color=\"red\">值的集合</font>及定义在此集合上的<font color=\"red\">一组操作</font>的总称\n\n> 数据类型 = 值的集合 + 值集合上的一组操作\n\n**在C语言中，按照取值的不同，可以分为两类：**\n\n* 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等\n* 结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的\n\n#### 抽象数据类型\n\n{% label 抽象是指抽取出事物具有的普遍性的本质。 red %}\n\n通过对已有的数据类型进行抽象得到。\n\n抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。\n\n* 由用户定义，从问题中抽象出<font color=\"red\">数据模型</font>（逻辑结构）。\n* 还包括定义在数据模型上的一组<font color=\"red\">抽象运算</font>（相关操作）。\n\n**抽象数据类型的形式定义：**\n\n抽象数据类型可以用（D，S，P）<font color=\"red\">三元组</font>表示。\n\n其中：D是数据对象；\n\n​\t\t\tS是D上的关系集；\n\n​\t\t\tP是对D的基本操作集。\n\n**抽象数据类型的定义格式如下：**\n\n```c++\nADT 抽象数据类型名\n{\n\t数据对象：<数据对象的定义>\t\t//其中，数据对象和数据关系用伪代码描述\n\t数据关系：<数据关系的定义>\t\t//基本操作的定义格式为：\n\t基本操作：<基本操作的定义>\t\t// 基本操作名（参数表）\n}ADT 抽象数据类型名\t\t\t   // 初始条件：<初始条件描述>\n    \t\t\t\t\t\t\t// 操作结果：<操作结果描述>                     \n```\n\n------\n\n**基本操作**定义格式说明：\n\n参数表：赋值参数 只为操作提供输入值\n\n​\t\t\t\t引用参数 以&打头，除可提供输入值外，还将返回操作结果\n\n初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。\n\n操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。\n\n```\nADT 抽象数据类型名{\nData\n\t数据对象的定义\n\t数据元素之间逻辑关系的定义\nOperation\n\t操作1\n\t\t初始条件\n\t\t操作结果描述\n\t操作2\n\t\t...\n\t操作n\n\t\t...\n\t\t\n}ADT 抽象数据类型名\n```\n\n\n\n## <center>算法</center>\n\n**数据额结构和算法的关系是相互依赖不可分割的。**\n\n### 🎈算法定义\n\n算法是解决特定问题**求解方法和步骤**的描述，在计算机中表现为<font color=\"red\">指令</font>的有限<font color=\"red\">序列</font>，并且每条指令表示一个或多个操作。\n\n**算法的描述：**\n\n* 自然语言：中文、英语\n* 流程图\n* 伪代码\n* 程序代码\n\n**算法与程序：**\n\n**算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法\n\n**程序**是用某种程序设计语言对算法的具体实现\n\n> 程序 = 数据结构 + 算法\n\n### 🎈算法的特性\n\n#### 输入输出\n\n* 算法具有零个或多个输入\n* 算法至少有一个或多个输出\n\n#### 有穷性\n\n算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。\n\n#### 确定性\n\n算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。\n\n#### 可行性\n\n算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。\n\n### 🎈算法设计的要求\n\n#### 正确性\n\n算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。\n\n可以分为四个层次：\n\n1. 算法程序<font color=\"red\">不含语法错误</font>\n2. 算法程序对于<font color=\"red\">几组输入数据</font>能够产生满足要求的输出结果。\n3. 算法程序对于<font color=\"red\">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。\n4. 算法程序对于<font color=\"red\">一切合法的输入数据</font>都有满足要求的输出结果。\n\n一般情况下，把<font color=\"red\">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。\n\n#### 可读性\n\n算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试\n\n#### 健壮性\n\n* 当<font color=\"red\">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。\n* 处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。\n\n#### 时间效率高和存储量低\n\n设计算法应该尽量满足时间效率高和存储量低的需求。\n\n### 🎈算法效率的度量方法\n\n**算法效率从以下两个方面来考虑：**\n\n<font color=\"red\">1.时间效率： </font>指的是算法所耗费的时间\n\n<font color=\"red\">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间\n\n**时间效率和空间效率有时候是矛盾的**\n\n#### 事后统计方法\n\n将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。\n\n#### 事前分析估算方法\n\n**<font color=\"red\">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font>**\n\n在计算机程序编制前，依据统计方法对算法进行估算。\n\n程序在计算机上运行时所消耗的时间取决于下列因素：\n\n1. 算法采用的策略、方法\n2. 编译产生的代码质量\n3. 问题的输入规模\n4. 机器指令执行的速度\n\n> 抛开软件和硬件的因素，一个程序的运行时间，依赖于**算法的好坏和问题的输入规模**。问题输入规模是指输入量的多少。\n\n**在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。**\n\n### 🎈函数的渐近增长\n\n> 定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n>N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。\n\n结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。\n\n### 🎈算法时间复杂度\n\n#### 算法时间复杂度定义\n\n> 在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color=\"red\">**渐进时间复杂度**</font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，用T（n）表示。\n\n这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。\n\n一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。\n\n**分析算法时间复杂度的基本方法：**\n\n1. 找出<font color=\"red\">语句频度最大</font>的那条语句作为<font color=\"red\">基本语句</font>\n2. 计算<font color=\"red\">基本语句</font>的频度得到问题规模n的某个函数f（n）\n3. 取其数量级用符号“O”表示\n\n#### 推导大O阶方法\n\n1. 用常数1取代运行时间中的所有加法常数。\n2. 在修改后的运行次数函数中，只保留最高阶项\n3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数\n4. 得到的结果就是大O阶\n\n#### 常数阶\n\n如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。\n\n{% label 即执行次数恒定，不会随着n的变大而发生变化 red %}\n\n#### 线性阶\n\n要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要**分析算法的复杂度，关键就是要分析循环结构的运行情况**。\n\n下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。\n\n```c++\nint i;\nfor(i = 0; i < n; i++)\n{\n\t/* 时间复杂度为O（1）的程序步骤序列 */\n}\n```\n\n#### 对数阶\n\n```c++\nint count = 1;\nwhile(count < n)\n{\n\tcount = count * 2;\n\t/* 时间复杂度为O（1）的程序步骤序列 */\n}\n```\n\n有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。\n\n#### 平方阶\n\n```c++\nint i,j;\nfor (i = 0; i < n; i++)\n{\n\tfor (j = 0; j < n; J++)\n\t{\n\t\t/* 时间复杂度为O（1）的程序步骤序列 */\n\t}\n}\n```\n\n它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。\n\n如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。\n\n总结得出，<font color=\"red\">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。\n\n对于下面这个循环嵌套：\n\n```c++\nint i,j;\nfor(i = 0; i < n; i++)\n{\n\tfor (j = i; j < n; j++) /* 注意int j = i 而不是0 */\n\t{\n\t\t/* 时间复杂度为O（1）的程序步骤序列 */\n\t}\n}\n```\n\n当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：\n\n<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>\n\n用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。\n\n\n\n#### 算法的加法法则和乘法法则\n\n* 加法法则\n\n  T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )\n\n* 乘法法则\n\n  T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )\n\n#### 🎈常用的时间复杂度\n\n|            执行次数函数            |           阶           |     非正式术语      |\n| :--------------------------------: | :--------------------: | :-----------------: |\n|                 12                 |         O（1）         |       常数阶        |\n|                2n+3                |         O（n）         |       线性阶        |\n|        3n<sup>2</sup>+2n+1         |   O（n<sup>2</sup>）   |       平方阶        |\n|        5log<sub>2</sub>n+20        | O（log<sub>2</sub>n）  |       对数阶        |\n|      2n+3nlog<sub>2</sub>n+19      | O（nlog<sub>2</sub>n） | nlog<sub>2</sub>n阶 |\n| 6n<sup>3</sup>+2n<sup>2</sup>+3n+4 |   O（n<sup>3</sup>）   |       立方阶        |\n|           2<sup>n</sup>            |   O（2<sup>n</sup>）   |       指数阶        |\n\n常用的时间复杂度所耗费的时间从小到大依次是：\n\n> O（1）<O（log<sub>2</sub>n）< O（n）<O（nlog<sub>2</sub>n）<O（n<sup>2</sup>）<O（n<sup>3</sup>）<O（2<sup>n</sup>）<O（n！）<O（n<sup>n</sup>）\n\n### 🎈最坏情况与平均情况\n\n* **最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。**\n* 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）\n\n### 🎈算法空间复杂度\n\n算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。\n\n**算法要占据的空间：**\n\n* 算法本身要占据的空间，输入/输出，指令，常数，变量等\n* 算法要使用<font color=\"red\">辅助空间</font>\n\n------\n\n## <center>🍟线性表</center>\n\n### 🎵线性表的定义和特点\n\n**线性表(Linear List):**\n\n* 由n个数据元素（结点）组成的<font color=\"red\">有限序列</font>\n* 其中数据元素的个数n定义为表的长度\n* 当n=0时称为空表\n* 数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同\n\n<font color=\"red\">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font>\n\n#### **线性表的逻辑特征**\n\n1. 非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继\n2. 有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱\n3. 其余的内部结点有且只有一个直接前驱和一个直接后继\n\n<font color=\"red\">线性表是一种典型的线性结构</font>\n\n**总结：**\n\n* 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**\n* 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序\n* 从具体应用中抽象处共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**\n\n\n\n#### **顺序表的类型定义**\n\n* 抽象数据类型线性表的定义如下：\n\n```c++\nADT List{\n\t数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}\n\t数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标\n\t基本操作：\n\tInitList(&L);\n\tListInsert(&L,i,e);\n\tDestroyList(&L);\n\tListDelete(&L,i,&e);\n\t......等等\n}ADT List\n```\n\n\n\n### 🎵基本操作\n\n* InitList(&L)   (Initiallization List)\n\n  * 操作结果：构造一个空的线性表L\n\n* DestroyList(&L)\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：销毁线性表L\n\n* ClearList(&L)\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：将线性表L重置为空表\n\n* ListEmpty(L);\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE\n\n* ListLength(L\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：返回线性表L中的数据元素的个数\n\n* GetElem(L,i,&e)\n\n  * 初始条件：线性表L已经存在，1 <= i <= ListLength(L)\n  * 操作结果：用e返回线性表L中第i个数据元素的值\n\n* LocateElem(L,e,compare())\n\n  * 初始条件：线性表L已经存在，compare()是数据元素判定函数\n  * 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0\n\n* PriorElem(L,cur_e,&pre_e)\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义\n\n* NextElem(L,cur_e,&next_e)\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义\n\n* ListInsert(&L,i,e)\n\n  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) + 1\n  * 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1\n\n* ListDelete(&L,i,&e)\n\n  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) \n  * 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一\n\n* ListTraverse(&L,visited())\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：依次对线性表中每个元素调用visited()\n\n\n\n**以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。**\n\n\n\n\n\n### 🎵线性表的顺序存储表示\n\n顺序表的顺序表示又称为<font color=\"red\">顺序存储结构</font>或<font color=\"red\">顺序映像</font>\n\n#### <font color=\"red\">**顺序存储定义**</font>\n\n把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构\n\n* 依次存储，地址连续——中间<font color=\"red\">没有空出存储单元</font>\n\n* 线性表顺序存储结构<font color=\"red\">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置\n\n\n\n#### **顺序表中元素存储位置的计算**\n\n* 假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color=\"red\">LOC(a~i+1~) = LOC(a~i~) + K</font>\n\n* 所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color=\"red\">LOC(a~i~) = LOC(a~1~) + (i-1) * K </font>。其中<font color=\"red\">LOC(a~1~) </font>称为<font color=\"red\">基地址</font>。\n\n\n\n#### **顺序表的特点**\n\n<font color=\"red\">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）\n\n顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color=\"red\">用一维数组表示顺序表</font>\n\n但线性表长度可变（删除），数组长度不可动态定义\n\n一维数组定义方式：``类型说明符 数组名[常量表达式]``\n\n说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color=\"red\">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。\n\n\n\n#### **定义顺序表类型**\n\n```\n#define MAXSIZE 100\ntypedef struct{\n\tElemType *elem;\n\tint length;\n}SqList;  //定义数据表类型\n\nSqList L; //定义变量L\n```\n\n\n\n### **🎵顺序表基本操作的实现**\n\n#### 操作算法中用到的预定义常量和类型\n\n```c++\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status 是函数类型\ntypedef int Status;\n```\n\n#### 线性表L的初始化\n\n```c++\nStatus InitList_Sq(SqList &L){\n\tL.elem = new ElemType[MAXSIZE];\n\tif(!L.elem)exit(OVERFLOW);\n\tL.length=0;\n\treturn OK;\n}\n```\n\n#### 销毁线性表\n\n```c++\nvoid DestoryList(SqList &L){\n\tif(L.elem) delete L.elem;\n}\n```\n\n#### 清空线性表\n\n```c++\nvoid ClearList(SqList &L){\n\tL.length = 0;\n}\n```\n\n#### 求线性表长度\n\n```c++\nint GetLength(SqList L){\n\treturn(L.length);\n}\n```\n\n#### 判断线性表L是否为空\n\n```c++\nint IsEmpty(SqList L){\n\tif(L.length == 0) return 1;\n\telse return 0;\n}\n```\n\n#### 顺序表取值\n\n```c++\nint GetElem(SqList L,int i,ElemType &e){\n\tif(i<1||i>L.length) return ERROR;  //判断i的值是否合理\n\te = L.elem[i-1];\n\treturn OK;\n}\n```\n\n#### 顺序表的查找\n\n```c++\nint LocateElem(SqList L,ElemType e){     //查找值为e的元素，返回其序号\n\tfor(i=0;i<L.length;i++){\n\t\tif(L.elem[i] == e) return i+1;\n\t}\n\treturn 0;\n}\n```\n\n**顺序表的查找算法分析**\n\n平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。\n\n* 用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加\n\n(1/n)*[(n+1)(n) / 2]\n\n顺序表查找的时间复杂度为O（n）\n\n\n\n#### 顺序表的删除\n\n```c++\nStatus ListDelete_Sq(SqList &L,int i){\n\tif((i<1)||(i>L.length)) return ERROR;\n\tfor(j=i;j<=L.length;j++){\n\t\tL.elem[j-1]=L.elem[j];\n\t}\n\tL.length--;\n\treturn OK;\n}\n```\n\n#### **顺序表的删除算法分析**\n\n(1/n)*[(n-1)n / 2]\n\n顺序表删除的时间复杂度O（n）\n\n\n\n### 🎵线性表的链式存储表示\n\n* 用一组<font color=\"red\">物理位置任意的存储单元</font>来存放线性表的数据元素\n* 这组存储单元既可以是<font color=\"red\">连续</font>的，也可以是<font color=\"red\">不连续</font>的，甚至是零散分布在内存中的任意位置上的\n* 链表中元素的<font color=\"red\">逻辑次序和物理次序不一定相同</font>\n\n\n\n#### **与链式存储有关的术语**\n\n1. <font color=\"red\">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成\n2. <font color=\"red\">链表：</font>n个结点由<font color=\"red\">指针链</font>组成一个链表\n3. <font color=\"red\">单链表、双链表、循环链表：</font>\n   * 结点只有一个指针域的链表，称为单链表或线性链表\n   * 结点有两个指针域的链表，称为双链表\n   * 首尾相接的链表称为循环链表\n4. <font color=\"red\">头指针、头结点、首元结点</font>\n\n\n\n#### <font color=\"red\">**讨论**</font>\n\n**如何表示空表？**\n\n* 无头结点时，<font color=\"red\">头指针为空</font>表示空表\n* 有头结点时，<font color=\"red\">当头结点的指针域为空时</font>表示空表\n\n**在链表中设置<font color=\"red\">头结点</font>有什么好处？**\n\n* 便于<font color=\"red\">首元结点</font>的处理\n* 便于<font color=\"red\">空表与非空表</font>的统一处理\n\n**头结点的<font color=\"red\">数据域</font>中装的是什么？**\n\n头结点的<font color=\"red\">数据域</font>可以为空，也可以存放线性<font color=\"red\">表长度</font>等附加信息，但此结点不能计入链表长度\n\n\n\n#### <font color=\"red\">链表（链式存储结构）的特点</font>\n\n1. 结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻\n2. 访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等\n\n这种数据元素的存储方法称为<font color=\"red\">顺序存取法</font>\n\n\n\n#### 单链表的定义和表示\n\n单链表是<font color=\"red\">由表头</font>唯一确定，因此单链表可以用<font color=\"red\">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color=\"red\">表L</font>。\n\n**单链表的存储结构：**\n\n```c++\ntypedef struct Lnode{\n\tElemType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\n```\n\n虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color=\"red\">LinkList L 创建链表</font>，用<font color=\"red\">Lnode *p 来创建指向结点的指针</font>。\n\n\n\n### 🎵单链表基本操作的实现\n\n#### 单链表的初始化\n\n```c++\nStatus InitList_L(LinkList &L){\n\tL = new LNode;   //从内存中申请一个存放LNode类型的空间，L指向它\n\tL->next = NULL;\n\treturn OK;\n}\n```\n\n#### 判断链表是否为空\n\n```c++\nint ListEmpty(LinkList L){\t//若表为空，返回1；不为空，返回0\n\tif(L->next)\n\t\treturn 0;\t//非空\n\telse\n\t\treturn 1;\n}\n```\n\n#### 单链表的销毁\n\n从头指针开始，依次释放所有结点\n\n用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。\n\n```c++\nStatus DestoryList_L(LinkList &L){\n\tLNode *P;\n\twhile(L){\n\t\tp = L;\n\t\tL = L->next;\n\t\tdelete p;\n\t}\n    return OK;\n}\n```\n\n#### 清空单链表\n\n链表仍存在，但链表中没有元素，只有头指针和头结点\n\n```c++\nStatus ClearList(LinkList &L){\n\tLnode *p, *q;\n\tp = L->next;\t//p指向首元结点\n\twhile(p){\n\t\tq = p->next;\n\t\tdelete p;\n        p = q;\n\t}\n\tL->next = NULL;\t//头结点的指针域指向空\n    return OK;\n}\n```\n\n#### 求单链表表长\n\n* 头结点不计入\n\n```c++\nint ListLength_L(LinkList L){\n\tLnode *p;\n\tint i = 0;\n\tp = L->next;\n\twhile(p){\n\t\ti++;\n\t\tp = p->next;\n\t}\n\treturn i;\n}\n```\n\n#### 单链表取值\n\n```c++\nStatus GetElem_L(LinkList L;int i;ElemType &e){\n\tLnode *p;p = L;int j = 0;\t//初始化\n\twhile(p && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i) return ERROR;\t//这里j>i是指i为0或者负数的情况 !p有两种情况\n\te = p->data;\t\t\t\t//1.链表为空  2.i的值大于链表长度p指向空了\t\t\n\treturn OK;\n}\n```\n\n#### 单链表的按值查找\n\n返回指针（地址）\n\n```c++\nLnode *LocateElem_L(LinkList L,ElemType e){\n\tLnode *p;p = L->next;\n\twhile(p && p->data != e){\n\t\tp = p->next;\n\t}\n\treturn p;\n}\n```\n\n返回<font color=\"red\">位置序号</font>\n\n```c++\nint LocateElem_L(LinkList L,Elemtype e){\n\tLnode *p;p = L;int j = 0;\n\twhile(p && p->data != e){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(p) return j;\n    else return 0;\n}\n```\n\n#### 单链表的插入\n\n```c++\nStatus ListInsert_L(LinkList &L,ElemType e,int i){\n\tLnode *p;p = L;int j = 0;\n\twhile(p && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i) return ERROR;\n\t\n\ts = new Lnode;s->data = e;\t//这里一定要用new一块内存空间 如果只Lnode一个结点\n\ts->next = p->next;\t\t\t//只是一个函数中的临时变量\n\tp->next = s;\n\t\n\treturn OK;\n}\n```\n\n单链表的删除\n\n```c++\nStatus ListDelete_L(LinkList &L,int i,ElemType &e){\n\tLnode *p;p = L;int j = 0;Lnode *q;\n\twhile(p && j<i-1){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i-1) return ERROR;\n\t\n\tq = p->next;\n\te = p->next->data;\n\tp->next = p->next->next;\n\tdelete q;\n\treturn OK;\n}\n```\n\n\n\n#### 单链表的查找、插入、删除算法时间效率分析\n\n1. 查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color=\"red\">O（n）</font>\n2. 插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color=\"red\">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color=\"red\">O（n）</font>\n\n\n\n#### 建立单链表\n\n* 头插法：元素插在链表的头部(倒位序)\n\n```c++\nvoid CreateList_H(LinkList &L,int n){\n\tLnode *p;\n\tL = new Lnode;\n\tL->next = NULL;\n\t\n\tfor(i=n;i>0;i--){\n\t\tp = new Lnode;\n\t\tcin>>p->data;\n\t\tp->next = L->next;\n\t\tL->next = p;\n\t}\n}\n```\n\n* 尾插法：元素插在链表的尾部(正位序)\n\n```c++\nvoid CreateList_R(LinkList &L,int n){\n\tLnode *p;Lnode *r;\t\t//需要创建一个指针来指向尾结点\n    L = new Lnode;L->next = NULL;\n    r = L;\n\t\n    for(i=0;i<n;i++){\n        p = new Lnode;\n        cin>>p->data;\n        p->next = NULL;\n        r->next = p;\n        r = p;\n    }\n}\n```\n\n\n\n### 🎵循环链表\n\n定义：是一种头尾相接的链表（表中最后一个结点指向<font color=\"red\">头结点</font>）\n\n优点：可以从表中任意结点出发均可找到表中其他结点\n\n注意：\n\n1. 由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p->next是否为空，而是<font color=\"red\">判断它们是否等于头指针</font>\n\n```\np != L;\np->next != NULL;\n```\n\n2. 表的操作常常是在表的首尾进行\n\n   若用头指针表示单循环链表，寻找a~n~的时间复杂度为O（n），不方便\n\n   所以经常用尾指针来表示单循环链表,使得寻找a~1~和a~n~的时间复杂度都为O（1）\n\n   a~1~的存储位置：R->next->next\n\n   a~n~的存储位置：R\n\n\n\n**带尾指针的循环链表的合并**\n\n```c++\nLinkList Connect(LinkList Ta,LinkList Tb){\n\tp = Ta->next;\t\t\t\t//存储表头结点\n\tTa->next = Tb->next->next;\t//Tb表头连接Ta表尾\n\tdelete Tb->next;\t\t\t//释放Tb表头结点\n\tTb->next = p;\t\t\t\t//修改指针\n\treturn Tb;\t\t\t\t\t//因为return了新的表尾  所以形参不用引用符号\n}\n```\n\n\n\n### 🎵双向链表\n\n定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表\n\n双向链表的结构可定义如下：\n\n```\ntypedef struct DuLnode{\n\tElemType data;\n\tstruct DuLnode *prior,*next;\n}DuLnode,*DuLinkList;\n```\n\n#### 双向链表的插入\n\n```c++\nvoid ListInsert_DuL(DuLinkList &L,int i,ElemType e){\n\tif(!(p = GetElemP_DuL(L,i))) return ERROR;\t//用p指向第i个结点\n\tDuLnode *s;\n\ts = new DuLnode;\n\ts->data = e;\n\t\n\ts->prior = p->prior;\n\tp->prior->next = s;\n\ts->next = p;\n\tp->prior = s;\n\t\n\treturn OK;\n}\n```\n\n#### 双向链表的删除\n\n```c++\nvoid ListDelete_DuL(DuLinkList &L,int i,ElemType &e){\n\tif(!(p = GetElemP_DuL(L,i))) return ERROR;\t//寻找第i个元素的时间复杂度O(n)\n\te = p->data;\n\tp->prior->next = p->next;\t//删除元素所需要的时间复杂度为 O(1)\n\tp->next->prior = p->prior;\n\tdelete p;\n\treturn OK;\n}\n```\n\n### 🎵单链表、循环链表和双向链表的时间效率比较\n\n|                                   | 查找首元结点           | 查表表尾结点                         | 查找结点*p的前驱结点                   |\n| --------------------------------- | ---------------------- | ------------------------------------ | -------------------------------------- |\n| 带头结点的单链表L                 | L->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next无法找到前驱                |\n| 带头结点且仅设头指针L的循环单链表 | R->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next可以找到前驱 时间复杂度O(n) |\n| 带头结点且仅设尾指针R的循环单链表 | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | 通过p->next可以找到前驱 时间复杂度O(n) |\n| 带头结点的双向循环链表            | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | p->prior 时间复杂度O(1)                |\n\n* 带头结点的双向循环链表，本质上还是用空间换取时间效率\n\n\n\n### 🎵线性表的应用\n\n#### 线性表的合并\n\n思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后\n\n```c++\nvoid union(SqList &La,SqList Lb){\n\tLa_len = ListLength(La);\n\tLb_len = ListLength(Lb);\n\t\n\tfor(i=1;i<=Lb_len;i++){\n\t\tGetElem(Lb,i,e);\n\t\tif(!LocateElem(La,e)) ListInsert(&La,++La_len,e);\n\t}\n}\n```\n\n* 算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )\n\n\n\n#### 有序表的合并\n\n* 顺序表的实现\n\n```c++\nvoid MergeList_Sq(SqList La,SqList Lb,SqList &Lc){\n\tElemType *pa,*pb,*pc;\n\tElemType *La_last,*Lb_last;\t\t\t\t//指针类型要和元素类型对应\n\tpa = La.elem;\t\t\t\t\t\t\t//分别指向两个顺序表第一个元素的指针\n\tpb = Lb.elem;\n\t\n\tLc.length = La.length + Lb.length;\n\tLc.elem = new ElemType[Lc.length];\t\t//为新表分配一个数组空间\n\tpc = Lc.elem;\n\t\n\tpa_last = La.elem + La.length - 1;\t\t//分别指向表中的最后一个元素\n\tpb_last = Lb.elem + Lb.length - 1;\n\t\n\twhile(pa <= pa_last && pb <= pb_last){\t//两个表都非空\n\t\tif(*pa <= *pb) *pc++ = *pa++;\n\t\telse *pc++ = *pb++;\n\t}\n\t\n\twhile(pa <= pa_last) *pc++ = *pa++;\t\t//将剩余元素填入表c\n    while(pb <= pb_last) *pc++ = *pb++;\n\t\n}\n```\n\n算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和\n\n算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) \n\n* 链表实现\n\n```c++\nvoid MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){\n\tLnode *pa,*pb,*pc;\n\tpa = La->next;\tpb = Lb->next;\t\t//分别指向La和Lb的首元结点\n\tpc = Lc = La;\t//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针\n\t\n\twhile(pa && pb){\n\t\tif(pa->data <= pb->data){pc->next = pa; pc = pa; pa = pa->next;}\n\t\telse(pc->next = pb; pc = pb; pb = pb->next;)\n\t}\n\t//当La和Lb有一个表填完\n\tpc->next = pa ? pa:pb;\n\t\n\t//释放Lb的头结点\n\tdelete Lb;\n}\n```\n\n算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的\n\n算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到\n\n### **🎵补充**\n\n#### **数组定义**\n\n数组静态分布\n\n```c++\ntypedef struct{\n\tElemType data[maxsize];\n\tint length;\n}SqList;\n```\n\n数组动态分布\n\n```c++\ntypedef struct{\n\tElemType *data;\t//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量\n\tint length;\t\t//来存放数组的首地址\n}SqList;\n\nSqList L;\nL.data = (ElemType*)malloc(sizeof(ElemType)*maxsize);\n```\n\n#### **C语言动态存储分配**\n\n对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。\n\n<font color=\"red\">需要加载头文件：<stdlib.h></font>(C语言)\n\n\n\n#### **C++的动态存储分配**\n\n``new 类型名T(初值列表)``\n\n功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值\n\n成功：T类型的指针，指向新分配的内存\n\n失败：0（NULL）\n\n```c++\nint *p1 = new int;\t\t//不赋初值\nint *p1 = new int(10);\t//赋初值\n```\n\n``delete 指针p``\n\n功能：释放指针P所指向的内存。P必须是new操作的返回值。\n\n\n\n#### **C++中的参数传递**\n\n* 函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序\n* 参数传递有两种方式\n  * 传值方式（参数为整型、实型、字符型等）\n  * 传地址\n    * 参数为指针变量\n    * 参数为引用类型\n    * 参数为数组名\n\n\n\n#### **C++中 引用类型做参数**\n\n```c++\nvoid main()\n{\n\tint i = 5;\n\tint &j = i;\t\t//引用类型,j作为i的一个替代名字，会随着i的改变而改变\n\ti = 7;\n}\n\n\nvoid swap(float &m,float &n) //这里的m和n与主函数中的实参用的是同一块空间\n{\n    float temp;\n    temp = n;\n    n = m;\n    m = temp;\n}\n```\n\n\n\n#### **引用类型做形参的三种说明**\n\n1. 传递引用给函数与传递指针的效果是一样的，<font color=\"red\">形参变化实参也发生变化</font>。\n\n2. 引用类型做形参，在内存中并没有产生实参的副本，它<font color=\"red\">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color=\"red\">形参变量的值是实参变量的副本</font>。因此，当<font color=\"red\">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。\n3. 指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。\n\n\n\n\n\n## 栈和队列\n\n### 栈和队列的定义和特点\n\n* 栈和队列是两种常用的、重要的数据结构\n* 栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表\n\n栈\n\n```c++\nInsert(s,n+1,x)\t//插入和删除只能在表尾进行\nDelete(s,n)\n```\n\n队列\n\n```c++\nInsert(q,n+1,x)\t//插入在表尾进行\nDelete(q,1)\t\t//删除在表头进行\n```\n\n\n\n### 栈的定义和特点\n\n栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表\n\n又称为<font color=\"red\">后进先出</font>(Last In First Out)的线性表，简称<font color=\"red\">LIFO</font>结构。\n\n\n\n**栈的相关概念**\n\n* 表尾（即a~n~端）称为<font color=\"red\">栈顶</font>Top；表头（即a~1~端）称为<font color=\"red\">栈底</font>Base\n\n* 插入元素到栈顶（即表尾）的操作，称为<font color=\"red\">入栈</font>\t\tPUSH\n\n* 从栈顶删除一个元素的操作，称为<font color=\"red\">出栈</font>\t\t\t\t\tPOP\n\n* 逻辑结构：与线性表相同，仍为一对一关系\n* 存储结构：用顺序栈或链栈均可，但以顺序栈更常见\n* 运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则\n* 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同\n\n<font color=\"red\">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出\n\n\n\n### 队列的定义和特点\n\n队列(queue)是一种<font color=\"red\">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除\n\n\n\n**队列的相关概念**\n\n* 逻辑结构：一对一\n* 存储结构：顺序队或链队，以循环队列更常见\n* 运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则\n* 实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同\n\n\n\n\n\n### 栈的表示和实现\n\n#### 栈的抽象数据类型的类型定义\n\n```c++\nADT Stack{\n\t数据对象:\n\t\tD = {ai|ai∈ElemSet,i=1,2,3....n,n>=0}\n\t数据关系：\n\t\tR1 = {<ai-1,ai>|ai-1,ai∈D,i=2,3,4...n}\n\t\t约定an为栈顶，a1为栈底\n\t基本操作：\n\t\t初始化、进栈、出栈、取栈顶元素等\n}ADT Stack\n```\n\n\n\n#### 🍨顺序栈的表示和实现\n\n存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。\n\n* 附设<font color=\"red\">top</font>指针，指示栈顶元素在顺序栈中的位置\n* 另设<font color=\"red\">base</font>指针，指示栈底元素在顺序栈中的位置\n\n<font color=\"red\">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font>\n\n* 另外，用<font color=\"red\">stacksize</font>表示栈可用的最大容量\n\n\n\n空栈：base == top 是栈空标志\n\n栈满：top - base == stacksize\n\n栈满时的处理方法：\n\n1. 报错，返回操作系统\n2. 分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈\n\n\n\n使用数组作为顺序栈存储方式的特点：\n\n简单、方便，但易产生溢出\n\n* 上溢(overflow)：栈已经满，又要压入元素\n* 下溢(underflow)：栈已经空，又要弹出元素\n\n\n\n顺序栈的表示\n\n```c++\n#define MAXSIZE 100\ntypedef struct{\n\tSElemType *top;\n\tSElemType *base;\n\tint stacksize;\n}SqStack;\n```\n\n\n\n##### 顺序栈的初始化\n\n```c++\nStatus InitStack(SqStack &S){\n\tS.base = new SElemType[MAXSIZE];\t//分配内存空间\n\tif(!S.base) exit(OVERFLOW);\t\t\t//如果分配失败\n\t\n\tS.top = S.base;\t\t\t\t\t\t//栈顶指针等于栈底指针\n\tS.stacksize = MAXSIZE;\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈判断栈是否为空\n\n```c++\nStatus StackEmpty(SqStack s){\n\tif(S.top == S.base)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n```\n\n\n\n##### 求顺序栈长度\n\n```c++\nint StackLength(SqStack S){\n\treturn S.top-S.base;\n}\n```\n\n\n\n##### 清空顺序栈\n\n```c++\nStatus ClearStack(SqStack S){\n\tif(S.base) S.top == S.base;\t//如果没有base就不用清空了；不用删除元素，令栈顶指\n\treturn OK;\t\t\t\t\t//针等于栈底指针就相当于栈为空\n}\n```\n\n\n\n##### 销毁顺序栈\n\n```c++\nStatus DestoryStack(SqStack &s){\n\tif(S.base){\n\t\tdelete S.base;\n\t\tS.stacksize = 0;\n\t\tS.top = S.base = NULL;\n\t}\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈的入栈\n\n```c++\nStatus Push(SqStack &S,SElemType e){\n\tif(S.top-S.base == stacksize) return ERROR;\n\t\n\t*S.top++ = e;\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈的出栈\n\n```c++\nStatus Pop(SqStack &S,SElemType &e){\n\tif(S.top == S.base)\n\t\treturn ERROR;\n\te = *--S.top;\n\treturn OK;\n}\n```\n\n\n\n\n\n#### 🍨链栈的表示\n\n* 链栈是<font color=\"red\">运算受限</font>的单链表，只能在<font color=\"red\">链表头部</font>进行操作\n\n```c++\ntypedef struct StackNode{\n\tSElemType data;\n\tstruct StackNode *next;\n}StackNode,*LinkStack;\nLinkStack S;\n```\n\n* 链表的头指针就是栈顶\n* 不需要头结点\n* 基本不存在栈满的情况\n* 空栈相当于头指针指向空\n* 插入和删除仅在栈顶处执行\n\n\n\n##### 链栈的初始化\n\n```c++\nvoid InitStack(LinkStack &S){\n\t//构造一个空栈，栈顶指针置为空\n\tS = NULL;\n\treturn OK;\n}\n```\n\n\n\n##### 判断链栈是否为空\n\n```c++\nStatus StackEmpty(LinkStack S){\n\tif(S == NULL) return TRUE;\n\telse return FALSE;\n}\n```\n\n\n\n##### 链栈的入栈\n\n```c++\nStatus Push(LinkStack &S,SElemType e){\n\tStackNode *p;\n\tp = new StackNode;\n\tp->data = e;\n\tp->next = S;\n\tS = p;\n\treturn OK;\n}\n```\n\n\n\n##### 链栈的出栈\n\n```c++\nStatus Pop(LinkList &S,SElemType &e){\n\tif(S == NULL) return ERROR;\n\te = S->data;\n\t\n\tStacknode *p;\n\tp = S;\n\tS = S->next;\n\tdelete p;\n\treturn OK;\n}\n```\n\n\n\n##### 取栈顶元素\n\n```c++\nSElemType GetTop(LinkStack S){\n\tif(S != NULL) \n\treturn S->data;\n}\n```\n\n\n\n\n\n### 栈与递归\n\n#### 递归的定义\n\n* 若一个对象部分地<font color=\"red\">包含它自己</font>，或者用它<font color=\"red\">给自己定义</font>，则称这个对象是递归的\n* 若一个过程<font color=\"red\">直接或间接地调用自己</font>，则称这个过程是递归过程\n\n#### 以下这三种情况常常用到递归方法\n\n1. 递归定义的数学函数\n   * 阶乘函数\n   * 斐波那契数列\n2. 具有递归特性的数据结构\n   * 二叉树\n   * 广义表\n3. 可递归求解的问题\n   * 迷宫问题\n   * 汉诺塔问题\n\n#### 递归问题：用分治法求解\n\n分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解\n\n必备的三个条件：\n\n1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的\n2. 可以通过上述转化而使问题简化\n3. 必须有一个明确的递归出口，或称递归边界\n\n\n\n#### 分治法求解递归问题算法的一般形式\n\n```c++\nvoid p(参数表){\n\tif(递归结束条件) 可直接求解步骤;\t//基本项\n\telse p (较小的参数);\t//归纳项\n}\n```\n\n\n\n#### 函数调用过程\n\n调用前，系统完成：\n\n1. 将<font color=\"red\">实参，返回地址</font>等传递给被调用函数\n2. 为被调用函数的<font color=\"red\">局部变量</font>分配存储区\n3. 将控制转移到被调用函数的<font color=\"red\">入口</font>\n\n调用后，系统完成：\n\n1. 保存被调用函数的计算<font color=\"red\">结果</font>\n2. 释放被调用函数的<font color=\"red\">数据区</font>\n3. 依照被调用函数保存的<font color=\"red\">返回地址</font>将控制转移到调用函数\n\n\n\n#### 多个函数嵌套调用\n\n<font color=\"red\">遵循后调用的先返回</font>\n\n\n\n#### 递归函数调用的实现\n\n“层次”\n\n```\n主函数\t\t 0层\n第1次调用\t1层\n......\t\t\n第i次调用\ti层\n```\n\n“递归工作栈”\t——递归程序运行期间使用的数据存储区\n\n“工作记录”\t\t实际参数、局部变量、返回地址\n\n\n\n#### 递归的优缺点\n\n优点：结构清晰，程序易读\n\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n\n\n\n递归——>非递归\n\n方法1：尾递归、单向递归 ——>循环结构\n\n方法2：自用<font color=\"red\">栈</font>模拟系统的运行时候栈\n\n\n\n### 队列的表示和操作的实现\n\n#### 队列的抽象数据类型定义\n\n```\nADT Queue{\n\t数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}\n\t数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标\n\t基本操作：\n\t\tInitQueue(&Q);\n\t\tDestroyQueue(&Q);\n\t\t......\n}ADT Queue\n```\n\n\n\n#### 队列的顺序表示和实现\n\n用一维数组base[MAXQSIZE]\n\n```c++\n#define MAXQSIZE 100\ntypedef struct{\n\tQElemType *base;\t//指向数组首地址\n\tint front;\t\t\t//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标\n\tint rear;\t\t\t//尾指针\n}\n```\n\n\n\n**解决假上溢的方法：**\n\n1. 将队中元素依次向队头方向移动\n\n   缺点：浪费时间。每移动一次，队中元素都要移动\n\n2. 将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间\n\nbase[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；\n\n实现方法：利用<font color=\"red\">模运算（mod,c语言中：%）</font>\n\n\n\n**区分队空和队满**\n\n1. 另外设置一个标志来区分队空、队满\n\n2. 另设一个变量，记录元素个数\n\n3. <font color=\"red\">少用一个元素空间</font>\n\n   用第三种方法时：\n\n   队空：front == rear\n\n   队满：（rear+1）% MAXQSIZE == front\t\t\t//无论对front下标在哪都适用\n\n\n\n##### 队列的初始化\n\n```c++\nStatus InitQueue(SqQueue &Q){\n\tQ.base = new QElemType[MAXQSIZE];\n\tif(!Q.base) exit(OVERFLOW);\n\tQ.front = Q.rear = 0;\n\treturn OK;\n}\n```\n\n\n\n##### 求队列的长度\n\n```c++\nint QueueLength(SqQueue &Q){\n\treturn((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);\n}\n```\n\n\n\n##### 循环队列入队\n\n```c++\nStatus EnQueue(&Q,QElemType e){\n\tif( (Q.rear+1) % MAXQSIZE == Q.front) return ERROR;\n    Q.base[Q.rear] = e;\n\tQ.rear = (Q.rear + 1) % MAXQSIZE;\n    return OK;\n}\n```\n\n\n\n##### 循环队列出队\n\n```c++\nStatus DeQueue(&Q,&QElemType e){\n\tif(Q.front == Q.rear) return ERROR;\n\te = Q.base[Q.front];\n\tQ.front = (Q.front + 1) % MAXQSIZE;\n\treturn OK;\n}\n```\n\n\n\n##### 取队头元素\n\n```c++\nQElemType GetHead(Q){\n\tif(Q.front != Q.rear)\treturn Q.base[front];\n}\n```\n\n\n\n#### 队列的链式表示和实现\n\n若用户无法估计所用队列的长度，宜采用链队列\n\n* 带头结点\n\n\n\n##### 链队列的类型定义\n\n```c++\n#define MAXQSIZE 100\ntypedef struct Qnode{\n\tQElemType data;\n\tstruct Qnode *next;\n}Qnode,*QueuePtr;\n\ntypedef struct{\n    QueuePtr front;\t\t//头指针\n    QueuePtr rear;\t\t//尾指针\n}LinkQueue;\n```\n\n\n\n##### 链队列初始化\n\n```c++\nStatus InitQueue(LinkQueue &Q){\n\tQ.front = Q.rear = new Qnode;\n\tif(!Q.front) exit(OVERFLOW);\n\tQ.front->next = NULL;\n\treturn OK;\n}\n```\n\n\n\n##### 链队列的销毁\n\n```c++\nStatus DestroyQueue(LinkQueue &Q){\n\tQnode *p;\n\twhile(Q.front){\n\t\tp = Q.front->next;\n\t\tdelete Q.front;\n\t\tQ.front = p;\n\t}//这里Q.rear 没什么用，可以直接用它来代替p\n\treturn OK;\n}\n```\n\n\n\n##### 链队列入队\n\n```c++\nStatus EnQueue(LinkQueue &Q,QElemType e){\n\tQnode *p;\n\tp = new Qnode;\n    if(!p) exit(OVERFLOW);\n\tp->data = e;\n\tp->next = NULL;\n\t\n\tQ.rear->next = p;\n    Q.rear = p;\n\treturn OK;\n}\n```\n\n\n\n##### 链队列出队\n\n```c++\nStatus DeQueue(LinkQueue &Q,QElemType &e){\n\tif(Q.front == Q.rear) return ERROR;\n\tQnode *p;\n\tp = Q.front->next;\n\te = p->data;\n\tQ.front->next = Q.front->next->next;\n\t\n\tif(Q.rear == p) Q.rear = Q.front;\t//如果恰好删除的是尾结点，那么尾指针也指向\n\t\t\t\t\t\t\t\t\t\t// 头结点\n\tdelete p;\n\treturn \n}\n```\n\n\n\n##### 求链队列队头元素\n\n```c++\nStatus GetHead(LinkQueue Q,QElemType &e){\n\tif(Q.front == Q.rear) return ERROR;\n\te = Q.front->next->data;\n\treturn OK;\n}\n```\n\n\n\n\n\n## 串\n\n### 串的定义\n\n串（string）：零个或多个任意字符组成的有限序列\n\ns = “a~1~a~2~···a~n~” (n>=0)\n\n串名：s\n\n串值：a~1~到a~n~\n\n串长：n\n\n空串：n=0\t用∅表示\n\n子串：串中任意个连续字符组成的子序列称为该串的子串\n\n真子串：不包含自身的所有子串\n\n主串：包含子串的串\n\n字符位置：字符在序列中的序号为该字符在串中的位置\n\n子串位置：子串中第一个字符在主串中的位置\n\n空格串：由一个或多个空格所构成的串，与空串不同\n\n串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等\n\n​\t\t\t\t所有的空串都是相等的\n\n\n\n### 串的类型定义\n\n```\nADT String{\n\t数据对象：字符\n\t数据关系：序偶关系\n\t基本操作：\n\t\t1.串赋值\n\t\t2.串比较\n\t\t3.求串长\n\t\t4.串连结\n\t\t5.求子串\n\t\t6.串拷贝\n\t\t7.清空串\n\t\t8.串判空\n\t\t9.子串的位置\n\t\t10.串替换\n\t\t11.子串插入\n\t\t12.子串删除\n\t\t13.串销毁\n}ADT String\n```\n\n\n\n### 串的存储结构\n\n串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）\n\n#### 串的顺序存储结构\n\n```c++\n#define MAXLEN 255\ntypedef struct{\n\tchar ch[MAXLEN+1];\t//0号位置不用\n\tint length;\n}SString\n```\n\n\n\n#### 串的链式存储结构\n\n与单链表类似\t优点：操作方便\t\t缺点：存储密度较低\n\n为了克服缺点，可将多个字符放在一个结点中，称为<font color=\"red\">块</font>\n\n```\n#define CHUNKSIZE 80\ntypedef struct Chunk{\n\tchar ch[CHUNKSIZE];\n\tstruct Chunk *next;\n}Chunk;\n\ntypedef struct{\n\tChunk *head,*tail;\t//串的头指针和尾指针\n\tint curlen;\t\t\t//串的当前长度\n}LString;\t\t\t\t//字符串的块链结构\n```\n\n\n\n### 串的模式匹配算法\n\n算法目的：确定主串中所含子串（模式串）第一次出现的位置\n\n算法应用：搜索引擎、拼写检查、语言翻译、数据压缩\n\n算法种类：BF算法、KMP算法\n\n\n\n#### BF算法\n\n简单匹配算法，采用穷举法的思路\n\n算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配\n\n\n\n##### 设计思想\n\nIndex (S,T,pos)\n\n* 将主串的第pos个字符和模式串的第一个字符比较\n* 若相等，继续逐个比较后续字符\n* 若不等，从主串的下一字符起，重新与模式串的第一个字符比较\n* 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功\n* 否则，匹配失败，返回值为0\n\n\n\n##### 算法描述\n\n```c++\nint Index_BF(SString S,SString T，int pos){\t//pos是从什么位置开始寻找\n\tint i=pos,j=1;\n\t\n\twhile(i<=S.length && j<=T.length){\n\t\tif(S.ch[i] == T.ch[j])\t{++i;++j;}\t//主串和子串依次匹配下一个字符\n\t\telse {j = 1; i = i - j + 2;}\t\t//主串、子串回溯开始下一次匹配\n\t}\n\tif(j>T.length) return i-T.length;\t\t//匹配成功返回第一个字符的下标\n\telse return 0;\t\t\t\t\t\t\t//匹配失败\n}\n```\n\n\n\n##### 算法时间复杂度\n\n主串长度为n，子串长度为m\n\n最好情况：O（m）\n\n最坏情况：O [ (n-m)*m + m ]\t若 m<<n，则算法复杂度为 O (m * n)\n\n\n\n#### KMP算法\n\n该算法较BF有较大改进，从而算法效率有了某种程度的提高\n\n\n\n##### 算法思想\n\n利用已经<font color=\"red\">部分匹配</font>的结果而加快模式串的滑动速度\n\n且主串S的指针<font color=\"red\">i不必回溯</font>，可提速到<font color=\"red\">O（m+n）</font>\n\n\n\n##### next[j]数组\n\n表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置\n\n​\t\t\t\t\tmax\t\n\nnext [j] = \t0\t当j=1时\n\n​\t\t\t\t\t1\t其他情况\n\n\n\n##### 算法描述\n\n```c++\nint Index_KMP(SString S,SString T，int pos){\n\tint i=pos,j=1;\n\t\n\twhile(i<=S.length && j<=T.length){\n\t\tif(S.ch[i] == T.ch[j])\t{++i;++j;}\t\n\t\telse \tj = next[j];\t\t//i不变，j后退 （与BF算法的区别）\n\t}\n\tif(j>T.length) return i-T.length;\n\telse return 0;\t\t\t\n}\n```\n\n获得next[j]数组的函数\n\n```c++\nvoid get_next(SString T,int &next[]){\n\ti = 1;next[1] = 0;j = 0;\n\twhile(i<T.length){\n\t\tif(j==0||T.ch[i]==T.ch[j]){\n\t\t\t++i;++j;\n\t\t\tnext[i] = j;  //如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1\n\t\t}\n\t\telse j = next[j]; //如果不相等，变成重新再找前j个字符的最长公共前缀子串，再\t\t\t\t\t\t  //移下一位看是否相等\n\t}\n}\n```\n\n理解：\n\n[(7条消息) KMP算法原理描述，告诉你为什么要“j = next[j\\]”_Leycaner的博客-CSDN博客_j=next[j]](https://blog.csdn.net/Leycaner/article/details/108301195)\n\n\n\n##### next函数的改进\n\n```c++\nvoid get_nextval(SString T,int &nextval[]){\n\ti = 1;nextval[1] = 0;j = 0;\n\twhile(i<T.length){\n\t\tif(j==0||T.ch[i]==T.ch[j]){\n\t\t\t++i;++j;\n\t\t\tif(T.ch[i]!=T.ch[j]) nextval = j;\n\t\t\telse nextval[i] = nextval[j];\n \t\t}\n\t\telse j = nextval[j]; \n\t}\n}\n```\n\n\n\n## 数组\n\n按一定格式排列起来的具有<font color=\"red\">相同类型</font>的数据元素的集合\n\n**结论：**线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展\n\n**特点：**结构固定\n\n**数组基本操作：**除了结构的初始化和销毁之外，只有取元素和修改元素值的操作\n\n\n\n### 数组的抽象数据类型定义\n\n<font color=\"red\">n维数组</font>的抽象数据类型\n\nADT Array{\n\n​\t数据对象： j~i~ = 0,······,b~i~-1\ti = 1,2,······n\t\t\t\tn为数组的维数，b~i~为数组第i维的长度\n\n​\t\t\t\t\t\tD = {a~j1j2······jn~|a~j1j2······jn~ ∈ElemSet}\n\n​\t数据关系：\n\n​\t\t\t\t\t\tR1 = {<a~j1······ji······jn~，a~j1······ji+1······jn~>|0<=j~k~<=b~k~-1 , 1<=k<=n, 且k≠i, 0<=j~i~<=b~k~-2,\n\n​\t\t\t\t\t\t\t\t\t<a~j1······ji······jn~，a~j1······ji+1······jn~>∈D ,i = 2,······,n}\n\n}\n\n\n\n基本操作\n\n```\n1.InitArray(&A,n,bound1,...boundn)\t\t//n是维数，boundn是每一维的上界\n2.DestoryArray(&A)\n3.Value(A,&e,index1,...indexn)\n4.Assign(A,&e,index,...indexn)\n}ADT Array\n```\n\n\n\n### 数组的顺序存储\n\n数组特点：结构固定\n\n数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作\n\n<font color=\"red\">所以：</font>一般都是用<font color=\"blue\">顺序存储结构</font>来表示数组\n\n注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的\n\n\n\n**一维数组**\n\n​\t\t\t\t\tLOC(0) = a\t\t\t\t\t\t\ti = 0\n\nLOC（i）=  \n\n​\t\t\t\t\tLOC(i-1) + L = a + i * L,\t\ti > 0\n\n\n\n**二维数组**\n\n两种存储方式：\n\n1. 以行序为主序\t\tLOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L \t\t\tn列数  m行数\n2. 以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L \n\n\n\n**三维数组**\n\n按 页/行/列 存放，页优先的顺序存储\n\na[m1] [m2] [m3] 各维元素个数为m1,m2,m3\n\n下标为i~1~,i~2~,i~3~的数组元素的存储位置\n\nLOC ( i~1~,i~2~,i~3~ ) = a + i~1~ * m2 * m3 + i~2~ * m3 + i~3~\n\n\n\n\n\n### 特殊矩阵的压缩存储\n\n矩阵的常规存储：描述为二维数组\n\n矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1\n\n不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多\n\n矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间\n\n1. 什么是压缩存储\n\n   若多个数据元素的<font color=\"red\">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间\n\n2. 什么样的矩阵能够压缩\n\n   一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等\n\n3. 什么叫稀疏矩阵\n\n   矩阵中非零元素很少（一般少于5%）\n\n\n\n#### 对称矩阵\n\n**特点：**对角线上下两边都对称，即a~ij~ = a~ji~  (1<=i,j<=n)\n\n**存储方法：**只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间\n\n**存储结构：**\n\n可以<font color=\"red\">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中\n\n一维数组中的元素，它前面有多少个元素它就在第几个位置\n\n假如求 a~ij~ 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1\t（下三角）\n\n\n\n#### 三角矩阵\n\n**特点：**对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c\n\n**存储方法：**重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间\n\n​\t\t\t\t\t类似于对称矩阵\n\n\n\n#### 对角矩阵\n\n**特点：**所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color=\"red\">对角矩阵</font>\n\n**存储方法：**用二维数组存储，每一个对角线上的所有元素存储为一行\n\n|      |  1   |  2   |  3   |  4   |  5   |  6   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  -2  |      |      |  3   |  3   |  8   |  5   |\n|  -1  |      |  2   |  0   |  6   |  1   |  2   |\n|  0   |  8   |  2   |  7   |  9   |  4   |  3   |\n|  1   |  4   |  7   |  6   |  1   |  8   |      |\n|  2   |  5   |  9   |  6   |  2   |      |      |\n\n其中主对角线存储在行标为0的行中\n\n\n\n#### 稀疏矩阵\n\n三元组法：三元组（i，j，a~ij~）唯一确定矩阵的一个非零元\n\n矩阵由所有三元组和矩阵维数（m，n）唯一确定\n\n**压缩存储原则：**存各非零元的值、行列位置和矩阵的行列数\n\n\n\n1、顺序存储结构：三元组顺序表\n\n|      | i（行数） |  j（列数）  |     v（元素值）     |\n| :--: | :-------: | :---------: | :-----------------: |\n|  0   | 6(总行数) | 6（总列数） | 8（非零元素总个数） |\n|  1   |     1     |      2      |         12          |\n|  2   |     1     |      3      |          9          |\n|  3   |     3     |      1      |         -3          |\n\n三元组顺序表又称<font color=\"red\">有序的双下标法</font>\n\n优点：非零元在表中按行序有序存储，因此<font color=\"red\">便于进行依行顺序处理的矩阵运算</font>\n\n缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找\n\n\n\n2.链式存储结构：十字链表\n\n优点：能够<font color=\"red\">灵活地插入</font>因运算而产生的新的非零元素，<font color=\"red\">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。\n\n表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）\n\nright：用于链接同一行中的下一个非零元素\n\ndown：用于链接同一列中的下一个非零元素\n\n| 头结点  | M.chead |      |      |      |\n| :-----: | :-----: | :--: | :--: | :--: |\n| M.rhead |  结点   |      |      | 结点 |\n|         |         | 结点 |      |      |\n|         |  结点   |      |      |      |\n\n\n\n\n\n\n\n## 广义表\n\n广义表（又称列表List）是n个元素的有限序列，其中每一个a~i~或者是<font color=\"red\">原子</font>或者是一个<font color=\"red\">广义表</font>\n\n拓宽了的线性表就是广义表。\n\n\n\n### 广义表的定义\n\n* 广义表通常记作：LS = （a~1~,a~2~,……,a~n~）\n\n​\t其中：LS为表名，n为表的长度，每一个a~i~为表的元素\n\n* 习惯上，一般用大写字母表示广义表，小写字母表示原子\n* 表头：若LS非空，则其第一个元素a~1~就是表头，记作head（LS） = a~1~ <font color=\"red\">注：</font>表头可以是原子或子表\n* 表尾：除表头之外<font color=\"red\">其他元素</font>组成的表，记作tail（LS） = （a~2~,……,a~n~） <font color=\"red\">注：</font>表尾不是最后一个元素，而是一个子表\n\n\n\n### 广义表的性质\n\n1. 广义表中的数据元素有相对 <font color=\"red\">次序</font>；一个直接前驱和一个直接后继\n2. 广义表的<font color=\"red\">长度</font>定义为最外层所包含元素的个数\n3. 广义表的<font color=\"red\">深度</font>定义为该广义表 <font color=\"blue\">展开后所含括号的重数；</font>  <font color=\"red\">注：</font>“原子”的深度为0；“空表”的深度为1\n4. 广义表可以为其他广义表<font color=\"red\">共享</font>\n5. 广义表可以是一个 <font color=\"red\">递归</font>的表。<font color=\"red\">注：</font>递归表的深度是无穷值，长度是有限值\n6. 广义表是<font color=\"red\">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表\n\n\n\n### 广义表和线性表的区别\n\n广义表可以看成是线性表的推广，线性表是广义表的特例\n\n广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构\n\n\n\n### 广义表的基本运算\n\n1. 求表头GetHead（L)，可以是一个原子也可以是一个子表\n2. 求表尾GetTail（L)，一定是一个子表\n\n\n\n### 广义表的存储\n\n因为表中元素的大小不固定，所以不用数组存储，一般用链表存储\n\n\n\n\n\n## ⛄树和二叉树\n\n### 树的定义\n\n树（Tree）是n（n>=0）个结点的有限集（递归定义）。\n\n若n=0，称为空树；\n\n若n>0，则它满足如下两个条件：\n\n\t1. 有且仅有一个特定的称为 根 的结点\n\t2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）\n\t3. \n\n\n\n\n\n### 树的基本术语\n\n结点：数据元素以及指向子树的分支\n\n根节点：非空树中无前驱结点的结点\n\n结点的度：结点拥有的子树数\n\n树的度：树内各结点的度的最大值\n\n叶子结点：度为0，也叫作终端节点\n\n分支结点：度不为0，非终端结点\n\n内部结点：根节点以外的分支结点\n\n结点的子树称为该结点的<font color=\"red\">孩子</font>，该结点称为孩子的<font color=\"red\">双亲</font>\n\n拥有同一个双亲的结点称为<font color=\"red\">兄弟结点</font>\n\n双亲在同一层但双亲不同的结点称为<font color=\"red\">堂兄弟结点</font>\n\n结点的<font color=\"red\">祖先</font>：从根到该结点所经分支上的所有结点\n\n结点的<font color=\"red\">子孙</font>：以某结点为根的子树中的任一结点\n\n树的<font color=\"red\">深度</font>：树中结点的最大层次\n\n<font color=\"red\">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）\n\n<font color=\"red\">无序树：</font>树中结点的各子树无次序\n\n<font color=\"red\">森林：</font>是m（m>=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树\n\n\n\n\n\n### 二叉树的定义\n\n为什么要研究二叉树？\n\n答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。\n\n\n\n**定义**\n\n二叉树是n（n>=0）个结点的有限集，它或者是空集，或者由一个<font color=\"blue\">根结点</font>及<font color=\"red\">两个互不相交</font>的分别称作这个根的<font color=\"blue\">左子树</font>和<font color=\"blue\">右子树</font>的二叉树组成。\n\n\n\n**特点**\n\n1. 每个结点最多有两个孩子<font color=\"red\">（二叉树中不存在度大于2的结点）</font>\n2. 子树有左右之分，其次序不能颠倒\n3. 二叉树可以是空集合，根可以有空的左子树或空的右子树\n\n\n\n<font color=\"red\">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。\n\n\n\n### 二叉树的抽象数据类型定义\n\n**二叉树的抽象数据类型定义**\n\n```\nADT BinaryTree{\n\t数据对象D：D是具有相同特性的数据元素的集合\n\t数据关系R：若D=∅，则R=∅\n\t\t\t  若D≠∅，则R={H},H是如下二元关系\n\t\t\t  1. root唯一//关于根的说明\n\t\t\t  2. ......//子树不相交\n\t\t\t  3. ......//关于数据元素的说明\n\t\t\t  4. ......//关于左子树和右子树的说明\n\t基本操作P：//至少有20个\n}ADT BinaryTree\n```\n\n**比较重要的几个操作：**\n\n```\nCreateBiTree(&T,definition)\n\t初始条件：definition给出二叉树T的定义\t//definition是指构造方式（先序...)\n\t操作结果：按definition构造二叉树T\nPreOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：先序遍历T，对每个结点访问一次\nInOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：中序遍历T，对每个结点访问一次\nPostOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：后序遍历T，对每个结点访问一次\n```\n\n\n\n\n\n### 二叉树的性质\n\n<font color=\"red\">性质1：</font>在二叉树的第i层上<font color=\"blue\">最多</font>有2^i-1^个结点（i>=1）\n\n<font color=\"red\">性质2：</font>深度为k的二叉树<font color=\"blue\">最多</font>有2^k^-1个结点（k>=1）\t<font color=\"red\">深度为k时至少有k个结点</font>\n\n<font color=\"red\">性质3：</font>对任意一颗二叉树T，如果其叶子数为n~0~，度为2的结点数为n~2~，则<font color=\"red\">n~0~=n~2~+1</font>\n\n从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）\n\n从上往下：B = n~2~ * 2 + n~1~ * 1\n\nB = n~2~ * 2 + n~1~ * 1 =  n - 1\n\nn = n~2~ * 2 + n~1~ * 1 + 1\n\n又因为n = n~0~ + n~1~ + n~2~\t两式相结合得到 n~0~=n~2~+1\n\n\n\n**两种特殊形式的二叉树**\n\n**满二叉树**\n\n一颗深度为k且有2^k^-1个结点的二叉树称为<font color=\"blue\">满二叉树</font>\n\n特点：1. 每层都满\t2. 叶子结点全部在最底层\n\n对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。\n\n* 满二叉树在同样深度的二叉树中<font color=\"red\">结点</font>个数最多\n* 满二叉树在同样深度的二叉树中<font color=\"red\">叶子结点</font>个数最多\n\n\n\n**完全二叉树**\n\n深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color=\"red\">一一对应</font>时，称为完全二叉树\n\n注：在满二叉树中，从最后一个结点开始<font color=\"red\">连续</font>去掉<font color=\"red\">任意</font>个结点，即是一棵完全二叉树\n\n特点：1. 叶子只可能分布在层次最大的两层上\n\n​\t\t\t2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1\n\n\n\n<font color=\"red\">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log~2~n ⌋ + 1\t\t(完全二叉树结点n与深度k的关系)\n\n<font color=\"red\">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log~2~n ⌋ + 1层，每层从左到右），则对任一结点i（1<=i<=n），有\n\n1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其<font color=\"red\">双亲结点是⌊ i / 2 ⌋</font>\n2. 如果2i>n，则结点i为叶子结点，无左孩子；否则，其<font color=\"red\">左孩子结点是2i</font>\n3. 如果2i + 1>n，则结点i无右孩子；否则，其<font color=\"red\">右孩子结点是2i+1</font>\n\n性质5表明了完全二叉树中<font color=\"red\">双亲结点编号</font>与<font color=\"red\">孩子结点编号</font>之间的关系\n\n<font color=\"red\">性质6：</font>\n\n\n\n\n\n### 二叉树的存储结构\n\n#### 二叉树的顺序存储\n\n按<font color=\"red\">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素\n\n```c++\n//二叉树顺序存储表示\n#define MAXTSIZE 100\ntypedef TElemType SqBiTree[MAXSIZE];\t//定义了一种数组类型，元素类型TElemType\nSqBiTree bt;\n```\n\n若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0\n\n二叉树的顺序存储缺点：\n\n最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组\n\n结点间关系蕴含在其存储位置中，浪费空间，适于存<font color=\"red\">满二叉树和完全二叉树</font>\n\n\n\n#### 二叉树的链式存储结构\n\n二叉链表存储结构\n\n```\ntypedef struct BiNode{\n\tTElemType data;\n\tstruct BiNode *lchild,*rchild;\t//左右孩子指针\n}BiNode,*BiTree;\n```\n\n\n\n在n个结点的二叉链表中，必有<font color=\"red\">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color=\"red\">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中\n\n<font color=\"red\">空指针数目= 2n - (n-1) = n +1</font>\n\n\n\n#### 三叉链表\n\n三个指针域：lchild、rchild、parent\n\n```c++\ntypedef struct TriTNode{\n    TElemType data;\n    struct TriTNode *lchid,*rchild,*parent;\n}TriTNode,*TriTree;\n```\n\n\n\n\n\n### 遍历二叉树\n\n<font color=\"red\">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]\n\n<font color=\"red\">遍历目的：</font>得到树中所有结点的一个线性排列\n\n<font color=\"red\">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心\n\n\n\n#### 遍历二叉树算法描述\n\n**遍历方法**\n\n若规定**先左后右**，则只有三种情况：\n\nDLR - 先序遍历\n\nLDR - 中序遍历\n\nLRD - 后序遍历\n\n|        先序遍历二叉树        |        中序遍历二叉树        |        后序遍历二叉树        |\n| :--------------------------: | :--------------------------: | :--------------------------: |\n| 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 |\n|         1.访问根结点         |       1.中序遍历左子树       |       1.后序遍历左子树       |\n|       2.先序遍历左子树       |         2.访问根结点         |       2.后序遍历右子树       |\n|       3.先序遍历右子树       |       3.中序遍历右子树       |         3.访问根结点         |\n\n\n\n#### 根据遍历序列确定二叉树\n\n* 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的\n* 由二叉树的<font color=\"red\">先序序列和中序序列</font>，或由二叉树的<font color=\"red\">后序序列和中序序列</font>可以确定唯一一颗二叉树\n\n\n\n**已知先序和中序序列求二叉树**\n\n分析：由先序序列确定根，由中序序列确定左右子树\n\n\n\n**已知中序和后序序列求二叉树**\n\n分析：由后序序列确定根，由中序序列确定左右子树\n\n\n\n\n\n#### 遍历的算法实现\n\n##### 先序遍历\n\n存储结构：二叉链表\n\n方法：递归\n\n```c++\nStatus PreOrderTraverse(BiTree T){\t\t//递归后传递进来的就是T->child的值了\n\tif(T==NULL) return OK;\n\telse{\n\t\tvisit(T);\t//访问根结点\t例如，输出根结点：cout<<T->data;\n\t\tPreOrderTraverse(T->lchild);\t//递归遍历左子树\n\t\tPreOrderTraverse(T->rchild);\t//递归遍历右子树\n\t}\n}\n```\n\n```c++\nvoid Pre(BiTree T){\t\t\t//例子\n\tif(T!=NULL){\n\t\tcout<<T->data;\n\t\tpre(T->lchild);\n\t\tpre(T->rchild);\n\t}\n}\n```\n\n\n\n\n\n##### 中序遍历\n\n```c++\nStatus InOrderTraverse(BiTree T){\t//中序遍历\n\tif(T==NULL) return OK;\n    else{\n        InOrderTraverse(T->lchild);\n        visit(T);\n        InOrderTraverse(T->rchild);\n    }\n}\n```\n\n\n\n##### 后序遍历\n\n```c++\nStatus PostOrderTraverse(BiTree T){\t//后序遍历\n\tif(T==NULL) return OK;\n\telse{\n\t\tPostOrderTraverse(T->lchild);\n\t\tPostOrderTraverse(T.>rchild);\n\t\tvisit(T);\n\t}\n}\n```\n\n\n\n#### 遍历算法的分析\n\n如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。\n\n第1次经过时访问 = 先序遍历\n\n第2次经过时访问 = 中序遍历\n\n第3次经过时访问 = 后序遍历\n\n\n\n时间复杂度O（n）\t//每个结点只访问一次\n\n空间复杂度O（n）\t//栈占用的最大辅助空间（都是左子树或者都是右子树）\n\n\n\n#### 遍历二叉树的非递归算法\n\n##### 中序遍历非递归算法\n\n关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树\n\n<font color=\"red\">基本思想：</font>\n\n1. 建立一个<font color=\"red\">栈</font>\n2. <font color=\"red\">根</font>结点<font color=\"red\">进栈</font>，遍历<font color=\"red\">左子树</font>\n3. <font color=\"red\">根</font>结点<font color=\"red\">出栈</font>，输出根结点，遍历<font color=\"red\">右子树</font>\n\n\n\n```c++\nStatus InOrderTraver(BiTree T){\t\t//T是根结点\n    BiTree p; InitStack(S); p = T;\t//p是当前要出栈或者入栈的结点\n    while(p||!StackEmpty(S)){\n        if(p) {push(S,p); p = p->lchild;}\n        else  {pop(S,q); cout<<q->data; p = q->rchild;}\t//q是栈顶元素\n    }\n    return OK;\n}\n```\n\n\n\n#### 二叉树的层次遍历\n\n对于一颗二叉树，从根结点开始，按<font color=\"red\">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。\n\n实现的关键：<font color=\"red\">顺序循环队列</font>\n\n队列类型定义如下\n\n```c++\ntypedef struct{\n\tBTNode data[MAXSIZE];\t//存放队中元素\n\tint front, rear;\t\t//队头和队尾指针\n}SqQueue;\n```\n\n层次遍历算法\n\n```c++\nvoid LevelOrder(BTNode &b){\n\tBTNode *p; SqQueue *qu;\tp = b;\n\tInitQueue(qu);\t\t\t\t//初始化队列\n\tenQueue(qu,b);\t\t\t\t//根结点指针进入队列\n\twhile(!QueueEmpty(qu)){\t\t//队不为空，则循环\n\t\tdeQueue(qu,p);\t\t\t//出队结点p（应该是队首元素）\n\t\tcout<<p->data;\t\t\t//访问结点p\n\t\tif(p->lchild != NULL) enQueue(qu,p->lchild);\t//有左孩子时将其进队\n\t\tif(p->rchild !=NULL) enQueue(qu,p->rchild);\t\t//有右孩子时将其进队\n\t}\n}\n```\n\n\n\n#### 二叉树的建立\n\n**按先序遍历建立二叉树的二叉链表**\n\n例：ABCDEGF\t如果只这么输入，树不是唯一的，所以<font color=\"red\">空结点用其他符号表示</font>\n\n```c++\nStatus CreateBiTree(BiTree &T){\n\tchar ch;\n    cin>>ch;\n    if(ch == '#') T == NULL;\n    else{\n        if(!(T = new BiTNode)) exit(OVERFLOW);\n        T->data = ch;\t\t\t\t//生成根结点\n        createBiTree(T->lchild);\t//构造左子树\n        createBiTree(T->rchild);\t//构造右子树\n    }\n    return OK;\n}\n```\n\n\n\n#### 复制二叉树\n\n**先序遍历复制二叉树**\n\n* 如果是空树，递归结束；\n* 否则，申请新结点空间，复制根结点\n  * 递归复制左子树\n  * 递归复制右子树\n\n```c++\nint Copy(BiTree, BiTree &NewT){\n\tif(BtTree == NULL){\n\t\tNewT = NULL; return 0;\t//如果是空树返回0\n\t}\n\telse{\n\t\tNewT = new BiTNode;\t\t//内存中申请一块新结点空间\n\t\tNewT->data = T->data;\t//将data域中的值复制到新结点当中\n\t\tCopy(T->lchild, NewT->lchild);\t//递归复制左子树\n\t\tCopy(T->rchild, NewT->rchild);\t//递归复制右子树\n\t}\n}\n```\n\n\n\n\n\n#### 计算二叉树深度\n\n* 如果是空树，深度为0\n* 否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1\n\n```c++\nint Depth(BiTree){\n\tif(T == NULL) return 0;\n\telse{\n\t\tm = Depth(T->lchild);\n\t\tn = Depth(T->rchild);\n\t\treturn m>n?m+1:n+1;\n\t}\n}\n```\n\n\n\n\n\n#### 计算二叉树结点总个数\n\n* 如果是空树，则结点个数为0\n* 否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）\n\n```c++\nint NodeCount(BiTree T){\n\tif(T == NULL) return 0;\n\telse return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;\n}\n```\n\n\n\n\n\n#### 计算二叉树叶子结点树\n\n* 如果是空树，叶子结点个数为0\n* 否则，为左子树的叶子结点树+右子树的叶子结点数\n\n```c++\nint LeafCount(BiTree T){\n\tif(T == NULL) return 0;\t\t//如果是空树返回0\n\tif(T->lchild == NULL && T->rchild == NULL) return 1; //如果是叶子结点返回1\n\telse return LeafCount(T->lchild)+LeafCount(T->rchild);\n}\n```\n\n\n\n\n\n\n\n### 线索二叉树\n\n**为什么要研究线索二叉树**？\n\n当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color=\"red\">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font>\n\n\n\n**如何寻找特定遍历序列中二叉树结点的前驱和后继？**\n\n解决方法：\n\n1. 通过遍历寻找\t\t\t\t\t\t费时间\n2. 添加前驱、后继指针域         费空间\n3. <font color=\"red\">利用二叉链表的空指针域</font>\n\n\n\n**二叉链表中空指针域的数量**\n\nn个结点的二叉树有2n个指针域，n个结点中有<font color=\"red\">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color=\"red\">n + 1 个指针域为空</font>\n\n\n\n**利用二叉链表中的空指针域**\n\n如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color=\"red\">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color=\"red\">指向其后继</font>\n\n这种<font color=\"red\">改变指向的指针</font>称为<font color=\"red\">“线索”</font>\n\n加上了线索的二叉树称为<font color=\"red\">线索二叉树</font>\n\n对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color=\"red\">线索化</font>\n\n\n\n\n\n**区分孩子指针和前驱后继指针**\n\n为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color=\"red\">每个结点增设两个标志域 ltag 和 rtag</font>\n\nltag = 0\tlchild指向该结点的左孩子\n\nltag = 1\tlchild指向该结点的前驱\n\nrtag = 0\trchild指向该结点的右孩子\n\nrtag = 1\trchild指向该结点的后继\n\n\n\n#### 结点的结构\n\n```c++\ntypedef struct BiThrNode{\n\tint data;\n    int ltag,rtag;\n    struct BiThrNode *lchild,*rchild;\n}BiThrNode,*BiThrTree;\n```\n\n\n\n#### **增加一个头结点**\n\n为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点\n\nltag=0，lchild指向根结点\n\nrtag=1，rchild指向遍历序列中的最后一个结点\n\n遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点\n\n\n\n\n\n\n\n### 树和森林\n\n#### 树的存储结构\n\n##### 1.双亲表示法\n\n实现：定义数据结构，每个结点含两个域\n\n数据域：存放结点本身信息\n\n双亲域：指示本结点的双亲结点在数组中的位置\n\nr = 0  根结点位置\tn = 10 结点数，方便定义数组\n\n特点：找双亲容易，找孩子难\n\n\n\n**结点的类型定义**\n\n结点结构：\n\n```c++\ntypedef struct PTNode{\n\tTElemType data;\n\tint parent;\n}PTNode;\n```\n\n树结构：\n\n```c++\n#define MAX_TREE_SIZE 100\ntypedef struct{\n\tPTNode nodes[MAX_TREE_SIZE];\n\tint r,n;\n}PTree;\n```\n\n\n\n\n\n##### 2.孩子链表\n\n把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。\n\n则n个结点有n个孩子链表（叶子的孩子链表为空表）。\n\n而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。\n\n特点：找孩子容易，找双亲难\n\n\n\n**类型定义**\n\n孩子结点结构\n\n```c++\ntypedef struct CTNode{\n\tint child;\n\tstruct CTNode *next;\n}*ChildPtr;\n```\n\n双亲结点结构\n\n```c++\ntypedef struct {\n\tTElemType data;\n\tChildPtr firstchild;\t//孩子链表头指针\n}CTBox;\n```\n\n树结构\n\n```c++\ntypedef struct {\n\tCTBox nodes[MAX_TREE_SIZE];\n\tint n,r;\t//结点数和根结点的位置\n}CTree;\n```\n\n\n\n为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color=\"red\">带双亲的孩子链表。</font>\n\n\n\n\n\n##### 3.孩子兄弟表示法\n\n实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color=\"red\">第一个孩子结点</font>和<font color=\"red\">下一个兄弟结点</font>\n\n```c++\ntypdedef struct CSNode{\n\tElemType data;\n\tstruct CSNode *firstchild,*nextsibling;\n}CSNode,*CSTree;\n```\n\n特点：查找孩子容易，查找双亲难\n\n\n\n\n\n####  树与二叉树的转换\n\n将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作\n\n由于树和二叉树都可以用二叉链表作存储结构，则<font color=\"red\">以二叉链表作媒介</font>可以导出树与二叉树之间的一个对应关系\n\n<font color=\"red\">给定一颗树，可以找到唯一的一棵二叉树与之对应</font>\n\n \n\n**将树转换成二叉树**\n\n1.加线：在兄弟之间加一条线\n\n2.抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系\n\n3.旋转：以树的根结点为轴心，将整树顺时针转45°\n\n\n\n**将二叉树转换成树**\n\n1.加线：若p结点是双亲结点的左孩子，则将p的有孩子，有孩子的有孩子……延分支找到所有的右孩子，都与p的双亲用线连起来\n\n2.抹线：抹掉原二叉树中双亲与右孩子之间的连线\n\n3.调整：将结点按层次排列，形成树结构\n\n\n\n\n\n#### 森林与二叉树的转化\n\n**森林转化成二叉树**\n\n1.将各棵树分别转换成二叉树\n\n2.将每棵树的根节点用线相连\n\n3.以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构\n\n\n\n**二叉树转化成森林**\n\n1.抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子建连线全部抹掉，使之变成孤立的二叉树\n\n2.还原：将孤立的二叉树还原成树\n\n\n\n#### 树和森林的遍历\n\n**1.树的遍历（三种方式）**\t\t 【二叉树的遍历有四种方式：先根、中根、后根、层次】\n\n* 先根遍历：\n\n  若树不空，则先访问根结点，然后依次先根遍历各棵子树\n\n* 后根遍历：\n\n  若树不空，则先依次后根遍历各棵子树，然后访问根结点\n\n* 参差遍历：\n\n  若树不空，则自上而下从左至右访问树中每个结点 \n\n\n\n**2.森林的遍历**\n\n将森林看做有三部分构成：\n\n1.森林中第一棵树的根结点；\n\n2.森林中第一棵树的子树森林；\n\n3.森林中其他树构成的森林\n\n\n\n**先序遍历：**\n\n若森林不空，则\n\n1.访问森林中第一棵树的根结点；\n\n2.先序遍历森林中第一棵树的子树森林；\n\n3.先序遍历森林中（除第一棵树之外）其余树构成的森林\n\n<font color=\"red\">即：依次从左至右对森林中每一棵树进行先根遍历</font>\n\n<font color=\"red\">还有一种很简单的方法：即对森林中每一棵树依次进行先序遍历</font>\n\n\n\n**中序遍历：**\n\n若森林不空，则\n\n1.中序遍历森里中第一棵树的子树森林；\n\n2.访问森林中第一棵树的根结点；\n\n3.中序遍历森林中（除第一棵树之外）其余树构成的森林\n\n<font color=\"red\">即：依次从左至右对森林中每一棵树进行中序遍历</font>\n\n  \n\n\n\n\n\n### 哈夫曼树及应用\n\n#### 哈夫曼树的基本概念\n\n<font color=\"red\">判断树：</font>用于描述分类过程的二叉树\n\n路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径\n\n路径的长度：两结点间路径上的分支数\n\n树的路径长度：从<font color=\"red\">树根</font>到每一个结点的<font color=\"red\">路径长度之和</font>。记作：TL\n\n<font color=\"red\">结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>路径长度最短的不一定是二叉树。\n\n权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<font color=\"red\">结点的权</font>\n\n结点的带权路径长度：从<font color=\"red\">根结点</font>到该结点之间的<font color=\"red\">路径长度</font>与该结点的<font color=\"red\">权</font>的<font color=\"red\">乘积</font>\n\n树的带权路径长度：树中所有<font color=\"red\">叶子</font>结点的<font color=\"red\">带权路径长度</font>。记作：WPL (Weighted Path Length)\n\n\n\n哈夫曼树：<font color=\"red\">最优树</font> 即带权路径长度最短的树\n\n“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。\n\n哈夫曼树：<font color=\"red\">最优二叉树</font> 带权路径长度最短的二叉树\n\n相应的算法称为哈夫曼算法\n\n\n\n特点：\n\n满二叉树不一定是哈夫曼树\n\n哈夫曼树中权越大的叶子离根越近\n\n具有相同带权结点的哈夫曼树不唯一\n\n\n\n#### 哈夫曼树的构造算法\n\n贪心算法：构造哈夫曼树时首先选择权值小的叶子结点\n\n<font color=\"red\">哈夫曼算法</font>\n\n1.根据n个给定的权值{w~1~,w~2~,…,w~n~}构成n棵二叉树的森林F={T~1~,T~2~,…,T~n~},其中T~i~只有一个带权为w~i~的根结点\n\n<font color=\"red\">构造森林全是根</font>\n\n2.在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右字数上根结点的权值之和\n\n<font color=\"red\">选用两小造新树</font>\n\n3.在F中删除这两棵树，同时将新得到的二叉树加入森林中\n\n<font color=\"red\">删除两小添新人</font>\n\n4.重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树\n\n<font color=\"red\">重复2、3剩单根</font>\n\n\n\n哈夫曼树的结点度数为0或2，没有度为1的结点\n\n包含n个叶子结点的哈夫曼树中共有2n-1个结点\n\n（包含n棵树的森林要经过n-1次和并才能形成哈夫曼树，共产生n-1个新结点）\n\n\n\n**总结：**\n\n1.在哈夫曼算法中，初始时有n棵二叉树，要经过<font color=\"red\">n-1</font>次合并最终形成哈夫曼树\n\n2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支节点\n\n可见：哈夫曼树中共有 n+n-1 =  <font color=\"red\">2n-1</font>个结点，且其所有的分支结点的度均不为1\n\n\n\n\n\n#### 哈夫曼树构造算法的实现\n\n采用顺序存储结构————一维结构数组\n\n结点类型定义\n\n```c++\ntypedef struct{\n\tint weight;\n\tint parent,lch,rch;\n}HTNode,*Huffman Tree;\n```\n\n| 哈夫曼树中结点下标i | weight | parent | lch  | rch  |\n| :-----------------: | :----: | :----: | :--: | :--: |\n|          1          |        |        |      |      |\n|          2          |        |        |      |      |\n|          3          |        |        |      |      |\n|          …          |        |        |      |      |\n|        2n-1         |        |        |      |      |\n\n哈夫曼树中共有2n-1个结点，不使用0下标，数组大小为2n\n\n\n\n步骤：\n\n1.初始化<font color=\"red\">HT[1……2n-1]</font> : lch = rch = parent = 0;\n\n2.输入初始<font color=\"red\">n个叶子结点</font>：置HT[1……n]的<font color=\"red\">weight值</font>\n\n```c++\nvoid CreateHuffmanTree(HuffmanTree HT,int n){ //构造哈夫曼树--哈夫曼算法\n\tif(n<=1) return;\n\tm = 2*n - 1;\t//数组共2n-1个元素\n\tHT = new HTNode[m+1];\t//0号单元未用，HT[m]表示根结点\n\tfor(i=1;i<=m;i++){\n\t\tHT[i].lch = 0;HT[i].rch = 0;HT[i].parent = 0;\n\t}\n\tfor(i=1;i<=n,++i) cin>>HT[i].weight;\t//输入前n个元素的weight值\n\t//初始化结束，下面开始建立哈夫曼树\n续\n```\n\n3.<font color=\"red\">进行以下n-1次合并，</font>依次产生n-1个结点HT[i], i=<font color=\"red\">n+1</font>…..2n-1;\n\n \ta.在HT[1…i-1]中选两个<font color=\"red\">未被选过</font>（从parent==0的结点中选）的weight最小的两个结\t\t点<font color=\"red\">HT[s1]</font>和<font color=\"red\">HT[s2]</font>,<font color=\"red\">s1、s2为两个最小结点下标</font>\n\n​\tb.修改HT[s1]和HT[s2]的parent值：HT[s1].parent = i; HT[s2].parent = i;\n\n​\tc.修改新产生的HT[i]：\n\n​\t\tHT[i].weight = HT[s1].weight + HT[s2].weight;\n\n​\t\tHT[i].lch = s1; HT[i].rch = s2;\n\n```c++\n续\nfor(i=n+1;i<=m;i++){\t\t//合并产生n-1个结点--构造Huffman树\n\tSelect(HT,i-1,s1,s2);\t//在HT[k](1<=k<=i-1)中选择两个其双亲域为0\n\t\t\t\t\t\t\t//且权值最小的结点，并返回它们在HT中的序号s1和s2\n\tHT[s1].parent = i; HT[s2].parent = i;\t//表示从F中删除s1,s2\n    HT[i].lch = s1; HT[i].rch = s2;\t\t\t//s1，s2分别作为i的左右孩子\n    HT[i].weight = HT[s1].weight+HT[s2].weight;//i的权值为左右孩子权值之和\n}\n}\n```\n\n\n\n\n\n#### 哈夫曼编码\n\n在远程通讯中，要将待传字符转换成由二进制的字符串\n\n若将编码设计为长度不等的二进制编码，即让待传字符串中<font color=\"red\">出现次数较多的字符采用尽可能短的编码，</font>则转换的二进制字符串便可能减少\n\n<font color=\"red\">关键：</font>要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀\n\n这种编码称作<font color=\"red\">前缀编码</font>\n\n\n\n问题：什么样的前缀码能使电文总长最短  ----<font color=\"red\">哈弗曼编码</font>\n\n1.<font color=\"red\">统计</font>字符集中<font color=\"red\">每个字符</font>在电文中<font color=\"red\">出现的</font>平均<font color=\"red\">概率</font>（概率越大，要求编码越短）。\n\n2.利用哈夫曼树的特点：权越大的叶子离根越近；<font color=\"red\">将每个字符的概率值作为权值，构造哈夫曼树。</font>则概率越大的结点，路径越短。\n\n3.在哈夫曼树的每个分支上标上0或1：\n\n​\t结点的<font color=\"red\">左分支标0，右分支标1</font>\n\n​\t把根到每个叶子的路径上的标号连接起来，作为该叶子代表的<font color=\"red\">字符的编码</font>\n\n\n\n**为什么哈弗曼编码能够保证是前缀编码？**\n\n因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀\n\n\n\n**为什么哈弗曼编码能够保证字符编码总长最短**\n\n因为哈夫曼树的带权路径长度最短，故字符编码的总长最短\n\n\n\n<font color=\"red\">哈夫曼编码的两个性质</font>\n\n1.哈弗曼编码是前缀码\n\n2.哈夫曼编码是最优前缀码\n\n\n\n#### 哈夫曼编码的算法实现\n\n```c++\nvoid CreateHuffmanCode(Huffman Tree HT,HuffmanCode &HC,int n){\n//从叶子到根逆向求每个字符的哈弗曼编码，存储在编码表HC中\n\tHC = new char *[n+1];\t//分配n个字符编码的头指针矢量\n\tcd = new char[n];\t\t//分配临时存放编码的动态数组空间\n\tcd[n-1] = '\\0';\t\t\t//编码结束符 （字符串结束符）\n\t\n\tfor(i=1;i<=n;++i){\n\t\tstart=n-1;c=i;f=Ht[i].parent;\n\t\twhile(f!=0){\t//从叶子结点开始向上回溯，直到根结点\n\t\t\t--start;\t//回溯一次start向前指一个位置\n\t\t\tif(HT[f].lchild == c) cd[start]='0'; //结点c是f的左孩子，0\n\t\t\telse cd[start]='1';\t\t\t\t\t //结点c是f的右孩子，1\n\t\t\tc = f; f = HT[f].parent;\t\t\t //继续向上回溯\n\t\t}\t//求出第i个字符的编码\n\t\tHC[i] = new char[n-start];\t\t//为第i个字符串编码分配空间大小是\n        \t\t\t\t\t\t\t\t// n-start 已占用的空间量\n\t\tstrcpy(HC[i],&cd[start]);\t\t//将求得的编码从临时空间cd复制到HC的当前行中\n\t}\n\tdelete cd;\t//释放临时空间\n}\n```\n\n\n\n\n\n#### 文件的编码和解码\n\n**编码**\n\n1.输入各字符及其权值\n\n2.构造哈夫曼树--HT[i]\n\n3.进行哈夫曼编码--HC[i]\n\n4.查HC[i]，得到各字符的哈弗曼编码\n\n\n\n**解码**\n\n1.构造哈夫曼树\n\n2.依次读入二进制码\n\n3.读入0，则走向左孩子；读入1，则走向右孩子\n\n4.一旦达到某叶子时，即可译出字符\n\n5.然后再从根出发继续译码，直到结束\n\n\n\n\n\n\n\n\n\n## 图\n\n### 图的定义和基本术语\n\n图：G=(V,E)\t\t\t\tGraph = （Vertex , Edge)\n\n​\t\tV：顶点（数据元素）的有穷非空集合；\n\n​\t\tE：边的有穷集合\n\n\n\n无向图：每条边都是无方向的\n\n有向图：每条边都是有方向的\n\n完全图：任意两个点都有一条边相连（无向完全图和有向完全图，其中有向完全图要两个方向都有边）\n\n\n\n无向完全图：<font color=\"red\">n个顶点，n(n-1)/2条边</font>\n\n有向完全图：<font color=\"red\">n个顶点，n(n-1)条边</font>\n\n\n\n稀疏图：有很少边或弧的图（e < nlog~n~）\n\n稠密图：有较多边或弧的图\n\n网：边/弧带权的图\n\n邻接：有边/弧相连的两个顶点之间的关系\n\n​\t\t\t存在（v~i~ , v~j~）, 则称v~i~ 和 v~j~互为邻接点\n\n​\t\t\t存在 <v~i~ , v~j~> , 则称 v~i~ 邻接到 v~j~ ，v~j~ 邻接于 v~i~ \n\n​\t\t\t圆括号表示无向图，尖括号表示有向图，从前面到后面\n\n关联（依附）：边/弧与顶点之间的关系\n\n​\t\t\t\t\t\t\t存在（v~i~ , v~j~） / <v~i~ , v~j~> , 则称该边/弧关联于v~i~ 和v~j~\n\n顶点的度：与该顶点相关联的边的数目，记为TD(v)\n\n​\t\t\t\t\t在<font color=\"red\">有向图</font>中，顶点的度等于该顶点的<font color=\"red\">入度</font>和<font color=\"red\">出度</font>之和\n\n​\t\t\t\t\t顶点<font color=\"red\">v的入度</font>是以v为终点的有向边的条数，记作ID(v)\n\n​\t\t\t\t\t顶点<font color=\"red\">v的出度</font>是以v为始点的有向边的条数，记作OD(v)\n\n","source":"_posts/数据结构.md","raw":"---\ntitle: 数据结构\ndate: 2021-08-04 17:54:42\ntags: 数据结构\ncategories: 学习\ncover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/DataStructure.png\ndescription: 青岛大学-王卓《数据结构与算法基础》学习记录\n---\n\n<center>数据结构</center>\n\n---\n\n## <center>绪论</center>\n\n### 🎈数据结构的研究内容\n\n**计算机解决问题的步骤：**\n\n* 将问题抽象为<font color=\"red\">数学模型</font>\n* 设计算法\n* 编程、调试、运行\n\n\n\n**早期，计算机应用于数值计算：**\n\n* 分析问题，找出对象以及对象之间的关系\n* 建立数学方程\n* 求解\n\n\n\n**随着计算机应用领域的扩展，越来越多被用于非数值计算：**\n\n* 线性表\n* 树\n* 图\n\n以上都是“非数值计算”的程序设计问题\n\n\n\n> 综上所述，数据结构是一门研究<font color=\"red\">非数值计算的</font>程序设计中计算机的<font color=\"red\">操作对象</font>以及他们之间的<font color=\"red\">关系</font>和<font color=\"red\">操作</font>的学科。\n\n### 🎈基本概念和术语\n\n#### 数据、数据元素、数据项和数据对象\n\n1. 数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。\n\n   包括：\n\n* 数值型数据：整数、实数等\n* 非数值型数据：文字、图像、图形、声音等\n\n2. 数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。\n3. 数据项：构成数据元素的不可分割的最小单位\n\n> <font color=\"red\">以上三者之间的关系：</font>数据>数据元素>数据项\n\n4. 数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。\n\n   数据元素和数据对象与数据的关系的区别：\n\n* 数据元素是集合的个体\n* 数据对象是集合的子集\n\n#### 数据结构\n\n* 数据元素互相之间的关系称为<font color=\"red\">结构</font>\n\n* 是指相互之间存在一种或多种特定关系的数据元素集合\n\n* <font color=\"red\">包含以下三方面内容：</font>\n\n  1. 数据元素之间的逻辑关系，也称为<font color=\"red\">逻辑结构</font>\n  2. 数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color=\"red\">物理结构</font>或数据的<font color=\"red\">存储结构</font>\n  3. 数据的<font color=\"red\">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现\n\n* 数据结构的两个层次：\n\n  1. <font color=\"red\">逻辑结构：</font>是指数据对象中数据元素之间的互相关系\n\n     **逻辑结构的种类：**\n\n     划分方法一：\n\n     1. <font color=\"red\">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。\n     2. <font color=\"red\">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。\n\n     划分方法二：\n\n     1. <font color=\"red\">集合结构：</font>其中的数据元素只有<font color=\"red\">只属于一个集合</font>的关系\n     2. <font color=\"red\">线性结构：</font>数据元素存在<font color=\"red\">一对一</font>的线性关系\n     3. <font color=\"red\">树形结构：</font>数据元素存在<font color=\"red\">一对多</font>的线性关系\n     4. <font color=\"red\">图状/网状结构：</font>数据元素存在<font color=\"red\">多对多</font>的线性关系\n\n  2. <font color=\"red\">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式\n\n     **存储结构的种类：**\n\n     ​\t<font color=\"red\">四种基本的存储结构：</font>\n\n     ​\t1.<font color=\"red\">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示\n\n     ​\t2.<font color=\"red\">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示\n\n     ​\t3.<font color=\"red\">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）\n\n     ​\t4.<font color=\"red\">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址\n\n     **逻辑结构和存储结构之间的关系：**\n\n     * 存储结构是逻辑关系的映像与元素本身的映像\n     * 逻辑结构是数据结构的抽象，存储结构是数据结构的实现\n     * 两者综合起来建立了数据元素之间的结构关系\n\n\n#### 数据类型\n\n数据类型(Data Type):是指一组性质相同的<font color=\"red\">值的集合</font>及定义在此集合上的<font color=\"red\">一组操作</font>的总称\n\n> 数据类型 = 值的集合 + 值集合上的一组操作\n\n**在C语言中，按照取值的不同，可以分为两类：**\n\n* 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等\n* 结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的\n\n#### 抽象数据类型\n\n{% label 抽象是指抽取出事物具有的普遍性的本质。 red %}\n\n通过对已有的数据类型进行抽象得到。\n\n抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。\n\n* 由用户定义，从问题中抽象出<font color=\"red\">数据模型</font>（逻辑结构）。\n* 还包括定义在数据模型上的一组<font color=\"red\">抽象运算</font>（相关操作）。\n\n**抽象数据类型的形式定义：**\n\n抽象数据类型可以用（D，S，P）<font color=\"red\">三元组</font>表示。\n\n其中：D是数据对象；\n\n​\t\t\tS是D上的关系集；\n\n​\t\t\tP是对D的基本操作集。\n\n**抽象数据类型的定义格式如下：**\n\n```c++\nADT 抽象数据类型名\n{\n\t数据对象：<数据对象的定义>\t\t//其中，数据对象和数据关系用伪代码描述\n\t数据关系：<数据关系的定义>\t\t//基本操作的定义格式为：\n\t基本操作：<基本操作的定义>\t\t// 基本操作名（参数表）\n}ADT 抽象数据类型名\t\t\t   // 初始条件：<初始条件描述>\n    \t\t\t\t\t\t\t// 操作结果：<操作结果描述>                     \n```\n\n------\n\n**基本操作**定义格式说明：\n\n参数表：赋值参数 只为操作提供输入值\n\n​\t\t\t\t引用参数 以&打头，除可提供输入值外，还将返回操作结果\n\n初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。\n\n操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。\n\n```\nADT 抽象数据类型名{\nData\n\t数据对象的定义\n\t数据元素之间逻辑关系的定义\nOperation\n\t操作1\n\t\t初始条件\n\t\t操作结果描述\n\t操作2\n\t\t...\n\t操作n\n\t\t...\n\t\t\n}ADT 抽象数据类型名\n```\n\n\n\n## <center>算法</center>\n\n**数据额结构和算法的关系是相互依赖不可分割的。**\n\n### 🎈算法定义\n\n算法是解决特定问题**求解方法和步骤**的描述，在计算机中表现为<font color=\"red\">指令</font>的有限<font color=\"red\">序列</font>，并且每条指令表示一个或多个操作。\n\n**算法的描述：**\n\n* 自然语言：中文、英语\n* 流程图\n* 伪代码\n* 程序代码\n\n**算法与程序：**\n\n**算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法\n\n**程序**是用某种程序设计语言对算法的具体实现\n\n> 程序 = 数据结构 + 算法\n\n### 🎈算法的特性\n\n#### 输入输出\n\n* 算法具有零个或多个输入\n* 算法至少有一个或多个输出\n\n#### 有穷性\n\n算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。\n\n#### 确定性\n\n算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。\n\n#### 可行性\n\n算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。\n\n### 🎈算法设计的要求\n\n#### 正确性\n\n算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。\n\n可以分为四个层次：\n\n1. 算法程序<font color=\"red\">不含语法错误</font>\n2. 算法程序对于<font color=\"red\">几组输入数据</font>能够产生满足要求的输出结果。\n3. 算法程序对于<font color=\"red\">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。\n4. 算法程序对于<font color=\"red\">一切合法的输入数据</font>都有满足要求的输出结果。\n\n一般情况下，把<font color=\"red\">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。\n\n#### 可读性\n\n算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试\n\n#### 健壮性\n\n* 当<font color=\"red\">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。\n* 处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。\n\n#### 时间效率高和存储量低\n\n设计算法应该尽量满足时间效率高和存储量低的需求。\n\n### 🎈算法效率的度量方法\n\n**算法效率从以下两个方面来考虑：**\n\n<font color=\"red\">1.时间效率： </font>指的是算法所耗费的时间\n\n<font color=\"red\">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间\n\n**时间效率和空间效率有时候是矛盾的**\n\n#### 事后统计方法\n\n将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。\n\n#### 事前分析估算方法\n\n**<font color=\"red\">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font>**\n\n在计算机程序编制前，依据统计方法对算法进行估算。\n\n程序在计算机上运行时所消耗的时间取决于下列因素：\n\n1. 算法采用的策略、方法\n2. 编译产生的代码质量\n3. 问题的输入规模\n4. 机器指令执行的速度\n\n> 抛开软件和硬件的因素，一个程序的运行时间，依赖于**算法的好坏和问题的输入规模**。问题输入规模是指输入量的多少。\n\n**在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。**\n\n### 🎈函数的渐近增长\n\n> 定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n>N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。\n\n结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。\n\n### 🎈算法时间复杂度\n\n#### 算法时间复杂度定义\n\n> 在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color=\"red\">**渐进时间复杂度**</font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，用T（n）表示。\n\n这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。\n\n一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。\n\n**分析算法时间复杂度的基本方法：**\n\n1. 找出<font color=\"red\">语句频度最大</font>的那条语句作为<font color=\"red\">基本语句</font>\n2. 计算<font color=\"red\">基本语句</font>的频度得到问题规模n的某个函数f（n）\n3. 取其数量级用符号“O”表示\n\n#### 推导大O阶方法\n\n1. 用常数1取代运行时间中的所有加法常数。\n2. 在修改后的运行次数函数中，只保留最高阶项\n3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数\n4. 得到的结果就是大O阶\n\n#### 常数阶\n\n如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。\n\n{% label 即执行次数恒定，不会随着n的变大而发生变化 red %}\n\n#### 线性阶\n\n要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要**分析算法的复杂度，关键就是要分析循环结构的运行情况**。\n\n下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。\n\n```c++\nint i;\nfor(i = 0; i < n; i++)\n{\n\t/* 时间复杂度为O（1）的程序步骤序列 */\n}\n```\n\n#### 对数阶\n\n```c++\nint count = 1;\nwhile(count < n)\n{\n\tcount = count * 2;\n\t/* 时间复杂度为O（1）的程序步骤序列 */\n}\n```\n\n有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。\n\n#### 平方阶\n\n```c++\nint i,j;\nfor (i = 0; i < n; i++)\n{\n\tfor (j = 0; j < n; J++)\n\t{\n\t\t/* 时间复杂度为O（1）的程序步骤序列 */\n\t}\n}\n```\n\n它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。\n\n如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。\n\n总结得出，<font color=\"red\">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。\n\n对于下面这个循环嵌套：\n\n```c++\nint i,j;\nfor(i = 0; i < n; i++)\n{\n\tfor (j = i; j < n; j++) /* 注意int j = i 而不是0 */\n\t{\n\t\t/* 时间复杂度为O（1）的程序步骤序列 */\n\t}\n}\n```\n\n当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：\n\n<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>\n\n用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。\n\n\n\n#### 算法的加法法则和乘法法则\n\n* 加法法则\n\n  T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )\n\n* 乘法法则\n\n  T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )\n\n#### 🎈常用的时间复杂度\n\n|            执行次数函数            |           阶           |     非正式术语      |\n| :--------------------------------: | :--------------------: | :-----------------: |\n|                 12                 |         O（1）         |       常数阶        |\n|                2n+3                |         O（n）         |       线性阶        |\n|        3n<sup>2</sup>+2n+1         |   O（n<sup>2</sup>）   |       平方阶        |\n|        5log<sub>2</sub>n+20        | O（log<sub>2</sub>n）  |       对数阶        |\n|      2n+3nlog<sub>2</sub>n+19      | O（nlog<sub>2</sub>n） | nlog<sub>2</sub>n阶 |\n| 6n<sup>3</sup>+2n<sup>2</sup>+3n+4 |   O（n<sup>3</sup>）   |       立方阶        |\n|           2<sup>n</sup>            |   O（2<sup>n</sup>）   |       指数阶        |\n\n常用的时间复杂度所耗费的时间从小到大依次是：\n\n> O（1）<O（log<sub>2</sub>n）< O（n）<O（nlog<sub>2</sub>n）<O（n<sup>2</sup>）<O（n<sup>3</sup>）<O（2<sup>n</sup>）<O（n！）<O（n<sup>n</sup>）\n\n### 🎈最坏情况与平均情况\n\n* **最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。**\n* 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）\n\n### 🎈算法空间复杂度\n\n算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。\n\n**算法要占据的空间：**\n\n* 算法本身要占据的空间，输入/输出，指令，常数，变量等\n* 算法要使用<font color=\"red\">辅助空间</font>\n\n------\n\n## <center>🍟线性表</center>\n\n### 🎵线性表的定义和特点\n\n**线性表(Linear List):**\n\n* 由n个数据元素（结点）组成的<font color=\"red\">有限序列</font>\n* 其中数据元素的个数n定义为表的长度\n* 当n=0时称为空表\n* 数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同\n\n<font color=\"red\">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font>\n\n#### **线性表的逻辑特征**\n\n1. 非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继\n2. 有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱\n3. 其余的内部结点有且只有一个直接前驱和一个直接后继\n\n<font color=\"red\">线性表是一种典型的线性结构</font>\n\n**总结：**\n\n* 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**\n* 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序\n* 从具体应用中抽象处共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**\n\n\n\n#### **顺序表的类型定义**\n\n* 抽象数据类型线性表的定义如下：\n\n```c++\nADT List{\n\t数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}\n\t数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标\n\t基本操作：\n\tInitList(&L);\n\tListInsert(&L,i,e);\n\tDestroyList(&L);\n\tListDelete(&L,i,&e);\n\t......等等\n}ADT List\n```\n\n\n\n### 🎵基本操作\n\n* InitList(&L)   (Initiallization List)\n\n  * 操作结果：构造一个空的线性表L\n\n* DestroyList(&L)\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：销毁线性表L\n\n* ClearList(&L)\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：将线性表L重置为空表\n\n* ListEmpty(L);\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE\n\n* ListLength(L\n\n  * 初始条件：线性表L已经存在\n\n  * 操作结果：返回线性表L中的数据元素的个数\n\n* GetElem(L,i,&e)\n\n  * 初始条件：线性表L已经存在，1 <= i <= ListLength(L)\n  * 操作结果：用e返回线性表L中第i个数据元素的值\n\n* LocateElem(L,e,compare())\n\n  * 初始条件：线性表L已经存在，compare()是数据元素判定函数\n  * 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0\n\n* PriorElem(L,cur_e,&pre_e)\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义\n\n* NextElem(L,cur_e,&next_e)\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义\n\n* ListInsert(&L,i,e)\n\n  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) + 1\n  * 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1\n\n* ListDelete(&L,i,&e)\n\n  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) \n  * 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一\n\n* ListTraverse(&L,visited())\n\n  * 初始条件：线性表L已经存在\n  * 操作结果：依次对线性表中每个元素调用visited()\n\n\n\n**以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。**\n\n\n\n\n\n### 🎵线性表的顺序存储表示\n\n顺序表的顺序表示又称为<font color=\"red\">顺序存储结构</font>或<font color=\"red\">顺序映像</font>\n\n#### <font color=\"red\">**顺序存储定义**</font>\n\n把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构\n\n* 依次存储，地址连续——中间<font color=\"red\">没有空出存储单元</font>\n\n* 线性表顺序存储结构<font color=\"red\">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置\n\n\n\n#### **顺序表中元素存储位置的计算**\n\n* 假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color=\"red\">LOC(a~i+1~) = LOC(a~i~) + K</font>\n\n* 所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color=\"red\">LOC(a~i~) = LOC(a~1~) + (i-1) * K </font>。其中<font color=\"red\">LOC(a~1~) </font>称为<font color=\"red\">基地址</font>。\n\n\n\n#### **顺序表的特点**\n\n<font color=\"red\">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）\n\n顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color=\"red\">用一维数组表示顺序表</font>\n\n但线性表长度可变（删除），数组长度不可动态定义\n\n一维数组定义方式：``类型说明符 数组名[常量表达式]``\n\n说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color=\"red\">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。\n\n\n\n#### **定义顺序表类型**\n\n```\n#define MAXSIZE 100\ntypedef struct{\n\tElemType *elem;\n\tint length;\n}SqList;  //定义数据表类型\n\nSqList L; //定义变量L\n```\n\n\n\n### **🎵顺序表基本操作的实现**\n\n#### 操作算法中用到的预定义常量和类型\n\n```c++\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status 是函数类型\ntypedef int Status;\n```\n\n#### 线性表L的初始化\n\n```c++\nStatus InitList_Sq(SqList &L){\n\tL.elem = new ElemType[MAXSIZE];\n\tif(!L.elem)exit(OVERFLOW);\n\tL.length=0;\n\treturn OK;\n}\n```\n\n#### 销毁线性表\n\n```c++\nvoid DestoryList(SqList &L){\n\tif(L.elem) delete L.elem;\n}\n```\n\n#### 清空线性表\n\n```c++\nvoid ClearList(SqList &L){\n\tL.length = 0;\n}\n```\n\n#### 求线性表长度\n\n```c++\nint GetLength(SqList L){\n\treturn(L.length);\n}\n```\n\n#### 判断线性表L是否为空\n\n```c++\nint IsEmpty(SqList L){\n\tif(L.length == 0) return 1;\n\telse return 0;\n}\n```\n\n#### 顺序表取值\n\n```c++\nint GetElem(SqList L,int i,ElemType &e){\n\tif(i<1||i>L.length) return ERROR;  //判断i的值是否合理\n\te = L.elem[i-1];\n\treturn OK;\n}\n```\n\n#### 顺序表的查找\n\n```c++\nint LocateElem(SqList L,ElemType e){     //查找值为e的元素，返回其序号\n\tfor(i=0;i<L.length;i++){\n\t\tif(L.elem[i] == e) return i+1;\n\t}\n\treturn 0;\n}\n```\n\n**顺序表的查找算法分析**\n\n平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。\n\n* 用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加\n\n(1/n)*[(n+1)(n) / 2]\n\n顺序表查找的时间复杂度为O（n）\n\n\n\n#### 顺序表的删除\n\n```c++\nStatus ListDelete_Sq(SqList &L,int i){\n\tif((i<1)||(i>L.length)) return ERROR;\n\tfor(j=i;j<=L.length;j++){\n\t\tL.elem[j-1]=L.elem[j];\n\t}\n\tL.length--;\n\treturn OK;\n}\n```\n\n#### **顺序表的删除算法分析**\n\n(1/n)*[(n-1)n / 2]\n\n顺序表删除的时间复杂度O（n）\n\n\n\n### 🎵线性表的链式存储表示\n\n* 用一组<font color=\"red\">物理位置任意的存储单元</font>来存放线性表的数据元素\n* 这组存储单元既可以是<font color=\"red\">连续</font>的，也可以是<font color=\"red\">不连续</font>的，甚至是零散分布在内存中的任意位置上的\n* 链表中元素的<font color=\"red\">逻辑次序和物理次序不一定相同</font>\n\n\n\n#### **与链式存储有关的术语**\n\n1. <font color=\"red\">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成\n2. <font color=\"red\">链表：</font>n个结点由<font color=\"red\">指针链</font>组成一个链表\n3. <font color=\"red\">单链表、双链表、循环链表：</font>\n   * 结点只有一个指针域的链表，称为单链表或线性链表\n   * 结点有两个指针域的链表，称为双链表\n   * 首尾相接的链表称为循环链表\n4. <font color=\"red\">头指针、头结点、首元结点</font>\n\n\n\n#### <font color=\"red\">**讨论**</font>\n\n**如何表示空表？**\n\n* 无头结点时，<font color=\"red\">头指针为空</font>表示空表\n* 有头结点时，<font color=\"red\">当头结点的指针域为空时</font>表示空表\n\n**在链表中设置<font color=\"red\">头结点</font>有什么好处？**\n\n* 便于<font color=\"red\">首元结点</font>的处理\n* 便于<font color=\"red\">空表与非空表</font>的统一处理\n\n**头结点的<font color=\"red\">数据域</font>中装的是什么？**\n\n头结点的<font color=\"red\">数据域</font>可以为空，也可以存放线性<font color=\"red\">表长度</font>等附加信息，但此结点不能计入链表长度\n\n\n\n#### <font color=\"red\">链表（链式存储结构）的特点</font>\n\n1. 结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻\n2. 访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等\n\n这种数据元素的存储方法称为<font color=\"red\">顺序存取法</font>\n\n\n\n#### 单链表的定义和表示\n\n单链表是<font color=\"red\">由表头</font>唯一确定，因此单链表可以用<font color=\"red\">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color=\"red\">表L</font>。\n\n**单链表的存储结构：**\n\n```c++\ntypedef struct Lnode{\n\tElemType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\n```\n\n虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color=\"red\">LinkList L 创建链表</font>，用<font color=\"red\">Lnode *p 来创建指向结点的指针</font>。\n\n\n\n### 🎵单链表基本操作的实现\n\n#### 单链表的初始化\n\n```c++\nStatus InitList_L(LinkList &L){\n\tL = new LNode;   //从内存中申请一个存放LNode类型的空间，L指向它\n\tL->next = NULL;\n\treturn OK;\n}\n```\n\n#### 判断链表是否为空\n\n```c++\nint ListEmpty(LinkList L){\t//若表为空，返回1；不为空，返回0\n\tif(L->next)\n\t\treturn 0;\t//非空\n\telse\n\t\treturn 1;\n}\n```\n\n#### 单链表的销毁\n\n从头指针开始，依次释放所有结点\n\n用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。\n\n```c++\nStatus DestoryList_L(LinkList &L){\n\tLNode *P;\n\twhile(L){\n\t\tp = L;\n\t\tL = L->next;\n\t\tdelete p;\n\t}\n    return OK;\n}\n```\n\n#### 清空单链表\n\n链表仍存在，但链表中没有元素，只有头指针和头结点\n\n```c++\nStatus ClearList(LinkList &L){\n\tLnode *p, *q;\n\tp = L->next;\t//p指向首元结点\n\twhile(p){\n\t\tq = p->next;\n\t\tdelete p;\n        p = q;\n\t}\n\tL->next = NULL;\t//头结点的指针域指向空\n    return OK;\n}\n```\n\n#### 求单链表表长\n\n* 头结点不计入\n\n```c++\nint ListLength_L(LinkList L){\n\tLnode *p;\n\tint i = 0;\n\tp = L->next;\n\twhile(p){\n\t\ti++;\n\t\tp = p->next;\n\t}\n\treturn i;\n}\n```\n\n#### 单链表取值\n\n```c++\nStatus GetElem_L(LinkList L;int i;ElemType &e){\n\tLnode *p;p = L;int j = 0;\t//初始化\n\twhile(p && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i) return ERROR;\t//这里j>i是指i为0或者负数的情况 !p有两种情况\n\te = p->data;\t\t\t\t//1.链表为空  2.i的值大于链表长度p指向空了\t\t\n\treturn OK;\n}\n```\n\n#### 单链表的按值查找\n\n返回指针（地址）\n\n```c++\nLnode *LocateElem_L(LinkList L,ElemType e){\n\tLnode *p;p = L->next;\n\twhile(p && p->data != e){\n\t\tp = p->next;\n\t}\n\treturn p;\n}\n```\n\n返回<font color=\"red\">位置序号</font>\n\n```c++\nint LocateElem_L(LinkList L,Elemtype e){\n\tLnode *p;p = L;int j = 0;\n\twhile(p && p->data != e){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(p) return j;\n    else return 0;\n}\n```\n\n#### 单链表的插入\n\n```c++\nStatus ListInsert_L(LinkList &L,ElemType e,int i){\n\tLnode *p;p = L;int j = 0;\n\twhile(p && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i) return ERROR;\n\t\n\ts = new Lnode;s->data = e;\t//这里一定要用new一块内存空间 如果只Lnode一个结点\n\ts->next = p->next;\t\t\t//只是一个函数中的临时变量\n\tp->next = s;\n\t\n\treturn OK;\n}\n```\n\n单链表的删除\n\n```c++\nStatus ListDelete_L(LinkList &L,int i,ElemType &e){\n\tLnode *p;p = L;int j = 0;Lnode *q;\n\twhile(p && j<i-1){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(!p || j>i-1) return ERROR;\n\t\n\tq = p->next;\n\te = p->next->data;\n\tp->next = p->next->next;\n\tdelete q;\n\treturn OK;\n}\n```\n\n\n\n#### 单链表的查找、插入、删除算法时间效率分析\n\n1. 查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color=\"red\">O（n）</font>\n2. 插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color=\"red\">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color=\"red\">O（n）</font>\n\n\n\n#### 建立单链表\n\n* 头插法：元素插在链表的头部(倒位序)\n\n```c++\nvoid CreateList_H(LinkList &L,int n){\n\tLnode *p;\n\tL = new Lnode;\n\tL->next = NULL;\n\t\n\tfor(i=n;i>0;i--){\n\t\tp = new Lnode;\n\t\tcin>>p->data;\n\t\tp->next = L->next;\n\t\tL->next = p;\n\t}\n}\n```\n\n* 尾插法：元素插在链表的尾部(正位序)\n\n```c++\nvoid CreateList_R(LinkList &L,int n){\n\tLnode *p;Lnode *r;\t\t//需要创建一个指针来指向尾结点\n    L = new Lnode;L->next = NULL;\n    r = L;\n\t\n    for(i=0;i<n;i++){\n        p = new Lnode;\n        cin>>p->data;\n        p->next = NULL;\n        r->next = p;\n        r = p;\n    }\n}\n```\n\n\n\n### 🎵循环链表\n\n定义：是一种头尾相接的链表（表中最后一个结点指向<font color=\"red\">头结点</font>）\n\n优点：可以从表中任意结点出发均可找到表中其他结点\n\n注意：\n\n1. 由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p->next是否为空，而是<font color=\"red\">判断它们是否等于头指针</font>\n\n```\np != L;\np->next != NULL;\n```\n\n2. 表的操作常常是在表的首尾进行\n\n   若用头指针表示单循环链表，寻找a~n~的时间复杂度为O（n），不方便\n\n   所以经常用尾指针来表示单循环链表,使得寻找a~1~和a~n~的时间复杂度都为O（1）\n\n   a~1~的存储位置：R->next->next\n\n   a~n~的存储位置：R\n\n\n\n**带尾指针的循环链表的合并**\n\n```c++\nLinkList Connect(LinkList Ta,LinkList Tb){\n\tp = Ta->next;\t\t\t\t//存储表头结点\n\tTa->next = Tb->next->next;\t//Tb表头连接Ta表尾\n\tdelete Tb->next;\t\t\t//释放Tb表头结点\n\tTb->next = p;\t\t\t\t//修改指针\n\treturn Tb;\t\t\t\t\t//因为return了新的表尾  所以形参不用引用符号\n}\n```\n\n\n\n### 🎵双向链表\n\n定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表\n\n双向链表的结构可定义如下：\n\n```\ntypedef struct DuLnode{\n\tElemType data;\n\tstruct DuLnode *prior,*next;\n}DuLnode,*DuLinkList;\n```\n\n#### 双向链表的插入\n\n```c++\nvoid ListInsert_DuL(DuLinkList &L,int i,ElemType e){\n\tif(!(p = GetElemP_DuL(L,i))) return ERROR;\t//用p指向第i个结点\n\tDuLnode *s;\n\ts = new DuLnode;\n\ts->data = e;\n\t\n\ts->prior = p->prior;\n\tp->prior->next = s;\n\ts->next = p;\n\tp->prior = s;\n\t\n\treturn OK;\n}\n```\n\n#### 双向链表的删除\n\n```c++\nvoid ListDelete_DuL(DuLinkList &L,int i,ElemType &e){\n\tif(!(p = GetElemP_DuL(L,i))) return ERROR;\t//寻找第i个元素的时间复杂度O(n)\n\te = p->data;\n\tp->prior->next = p->next;\t//删除元素所需要的时间复杂度为 O(1)\n\tp->next->prior = p->prior;\n\tdelete p;\n\treturn OK;\n}\n```\n\n### 🎵单链表、循环链表和双向链表的时间效率比较\n\n|                                   | 查找首元结点           | 查表表尾结点                         | 查找结点*p的前驱结点                   |\n| --------------------------------- | ---------------------- | ------------------------------------ | -------------------------------------- |\n| 带头结点的单链表L                 | L->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next无法找到前驱                |\n| 带头结点且仅设头指针L的循环单链表 | R->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next可以找到前驱 时间复杂度O(n) |\n| 带头结点且仅设尾指针R的循环单链表 | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | 通过p->next可以找到前驱 时间复杂度O(n) |\n| 带头结点的双向循环链表            | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | p->prior 时间复杂度O(1)                |\n\n* 带头结点的双向循环链表，本质上还是用空间换取时间效率\n\n\n\n### 🎵线性表的应用\n\n#### 线性表的合并\n\n思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后\n\n```c++\nvoid union(SqList &La,SqList Lb){\n\tLa_len = ListLength(La);\n\tLb_len = ListLength(Lb);\n\t\n\tfor(i=1;i<=Lb_len;i++){\n\t\tGetElem(Lb,i,e);\n\t\tif(!LocateElem(La,e)) ListInsert(&La,++La_len,e);\n\t}\n}\n```\n\n* 算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )\n\n\n\n#### 有序表的合并\n\n* 顺序表的实现\n\n```c++\nvoid MergeList_Sq(SqList La,SqList Lb,SqList &Lc){\n\tElemType *pa,*pb,*pc;\n\tElemType *La_last,*Lb_last;\t\t\t\t//指针类型要和元素类型对应\n\tpa = La.elem;\t\t\t\t\t\t\t//分别指向两个顺序表第一个元素的指针\n\tpb = Lb.elem;\n\t\n\tLc.length = La.length + Lb.length;\n\tLc.elem = new ElemType[Lc.length];\t\t//为新表分配一个数组空间\n\tpc = Lc.elem;\n\t\n\tpa_last = La.elem + La.length - 1;\t\t//分别指向表中的最后一个元素\n\tpb_last = Lb.elem + Lb.length - 1;\n\t\n\twhile(pa <= pa_last && pb <= pb_last){\t//两个表都非空\n\t\tif(*pa <= *pb) *pc++ = *pa++;\n\t\telse *pc++ = *pb++;\n\t}\n\t\n\twhile(pa <= pa_last) *pc++ = *pa++;\t\t//将剩余元素填入表c\n    while(pb <= pb_last) *pc++ = *pb++;\n\t\n}\n```\n\n算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和\n\n算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) \n\n* 链表实现\n\n```c++\nvoid MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){\n\tLnode *pa,*pb,*pc;\n\tpa = La->next;\tpb = Lb->next;\t\t//分别指向La和Lb的首元结点\n\tpc = Lc = La;\t//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针\n\t\n\twhile(pa && pb){\n\t\tif(pa->data <= pb->data){pc->next = pa; pc = pa; pa = pa->next;}\n\t\telse(pc->next = pb; pc = pb; pb = pb->next;)\n\t}\n\t//当La和Lb有一个表填完\n\tpc->next = pa ? pa:pb;\n\t\n\t//释放Lb的头结点\n\tdelete Lb;\n}\n```\n\n算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的\n\n算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到\n\n### **🎵补充**\n\n#### **数组定义**\n\n数组静态分布\n\n```c++\ntypedef struct{\n\tElemType data[maxsize];\n\tint length;\n}SqList;\n```\n\n数组动态分布\n\n```c++\ntypedef struct{\n\tElemType *data;\t//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量\n\tint length;\t\t//来存放数组的首地址\n}SqList;\n\nSqList L;\nL.data = (ElemType*)malloc(sizeof(ElemType)*maxsize);\n```\n\n#### **C语言动态存储分配**\n\n对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。\n\n<font color=\"red\">需要加载头文件：<stdlib.h></font>(C语言)\n\n\n\n#### **C++的动态存储分配**\n\n``new 类型名T(初值列表)``\n\n功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值\n\n成功：T类型的指针，指向新分配的内存\n\n失败：0（NULL）\n\n```c++\nint *p1 = new int;\t\t//不赋初值\nint *p1 = new int(10);\t//赋初值\n```\n\n``delete 指针p``\n\n功能：释放指针P所指向的内存。P必须是new操作的返回值。\n\n\n\n#### **C++中的参数传递**\n\n* 函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序\n* 参数传递有两种方式\n  * 传值方式（参数为整型、实型、字符型等）\n  * 传地址\n    * 参数为指针变量\n    * 参数为引用类型\n    * 参数为数组名\n\n\n\n#### **C++中 引用类型做参数**\n\n```c++\nvoid main()\n{\n\tint i = 5;\n\tint &j = i;\t\t//引用类型,j作为i的一个替代名字，会随着i的改变而改变\n\ti = 7;\n}\n\n\nvoid swap(float &m,float &n) //这里的m和n与主函数中的实参用的是同一块空间\n{\n    float temp;\n    temp = n;\n    n = m;\n    m = temp;\n}\n```\n\n\n\n#### **引用类型做形参的三种说明**\n\n1. 传递引用给函数与传递指针的效果是一样的，<font color=\"red\">形参变化实参也发生变化</font>。\n\n2. 引用类型做形参，在内存中并没有产生实参的副本，它<font color=\"red\">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color=\"red\">形参变量的值是实参变量的副本</font>。因此，当<font color=\"red\">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。\n3. 指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。\n\n\n\n\n\n## 栈和队列\n\n### 栈和队列的定义和特点\n\n* 栈和队列是两种常用的、重要的数据结构\n* 栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表\n\n栈\n\n```c++\nInsert(s,n+1,x)\t//插入和删除只能在表尾进行\nDelete(s,n)\n```\n\n队列\n\n```c++\nInsert(q,n+1,x)\t//插入在表尾进行\nDelete(q,1)\t\t//删除在表头进行\n```\n\n\n\n### 栈的定义和特点\n\n栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表\n\n又称为<font color=\"red\">后进先出</font>(Last In First Out)的线性表，简称<font color=\"red\">LIFO</font>结构。\n\n\n\n**栈的相关概念**\n\n* 表尾（即a~n~端）称为<font color=\"red\">栈顶</font>Top；表头（即a~1~端）称为<font color=\"red\">栈底</font>Base\n\n* 插入元素到栈顶（即表尾）的操作，称为<font color=\"red\">入栈</font>\t\tPUSH\n\n* 从栈顶删除一个元素的操作，称为<font color=\"red\">出栈</font>\t\t\t\t\tPOP\n\n* 逻辑结构：与线性表相同，仍为一对一关系\n* 存储结构：用顺序栈或链栈均可，但以顺序栈更常见\n* 运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则\n* 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同\n\n<font color=\"red\">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出\n\n\n\n### 队列的定义和特点\n\n队列(queue)是一种<font color=\"red\">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除\n\n\n\n**队列的相关概念**\n\n* 逻辑结构：一对一\n* 存储结构：顺序队或链队，以循环队列更常见\n* 运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则\n* 实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同\n\n\n\n\n\n### 栈的表示和实现\n\n#### 栈的抽象数据类型的类型定义\n\n```c++\nADT Stack{\n\t数据对象:\n\t\tD = {ai|ai∈ElemSet,i=1,2,3....n,n>=0}\n\t数据关系：\n\t\tR1 = {<ai-1,ai>|ai-1,ai∈D,i=2,3,4...n}\n\t\t约定an为栈顶，a1为栈底\n\t基本操作：\n\t\t初始化、进栈、出栈、取栈顶元素等\n}ADT Stack\n```\n\n\n\n#### 🍨顺序栈的表示和实现\n\n存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。\n\n* 附设<font color=\"red\">top</font>指针，指示栈顶元素在顺序栈中的位置\n* 另设<font color=\"red\">base</font>指针，指示栈底元素在顺序栈中的位置\n\n<font color=\"red\">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font>\n\n* 另外，用<font color=\"red\">stacksize</font>表示栈可用的最大容量\n\n\n\n空栈：base == top 是栈空标志\n\n栈满：top - base == stacksize\n\n栈满时的处理方法：\n\n1. 报错，返回操作系统\n2. 分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈\n\n\n\n使用数组作为顺序栈存储方式的特点：\n\n简单、方便，但易产生溢出\n\n* 上溢(overflow)：栈已经满，又要压入元素\n* 下溢(underflow)：栈已经空，又要弹出元素\n\n\n\n顺序栈的表示\n\n```c++\n#define MAXSIZE 100\ntypedef struct{\n\tSElemType *top;\n\tSElemType *base;\n\tint stacksize;\n}SqStack;\n```\n\n\n\n##### 顺序栈的初始化\n\n```c++\nStatus InitStack(SqStack &S){\n\tS.base = new SElemType[MAXSIZE];\t//分配内存空间\n\tif(!S.base) exit(OVERFLOW);\t\t\t//如果分配失败\n\t\n\tS.top = S.base;\t\t\t\t\t\t//栈顶指针等于栈底指针\n\tS.stacksize = MAXSIZE;\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈判断栈是否为空\n\n```c++\nStatus StackEmpty(SqStack s){\n\tif(S.top == S.base)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n```\n\n\n\n##### 求顺序栈长度\n\n```c++\nint StackLength(SqStack S){\n\treturn S.top-S.base;\n}\n```\n\n\n\n##### 清空顺序栈\n\n```c++\nStatus ClearStack(SqStack S){\n\tif(S.base) S.top == S.base;\t//如果没有base就不用清空了；不用删除元素，令栈顶指\n\treturn OK;\t\t\t\t\t//针等于栈底指针就相当于栈为空\n}\n```\n\n\n\n##### 销毁顺序栈\n\n```c++\nStatus DestoryStack(SqStack &s){\n\tif(S.base){\n\t\tdelete S.base;\n\t\tS.stacksize = 0;\n\t\tS.top = S.base = NULL;\n\t}\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈的入栈\n\n```c++\nStatus Push(SqStack &S,SElemType e){\n\tif(S.top-S.base == stacksize) return ERROR;\n\t\n\t*S.top++ = e;\n\treturn OK;\n}\n```\n\n\n\n##### 顺序栈的出栈\n\n```c++\nStatus Pop(SqStack &S,SElemType &e){\n\tif(S.top == S.base)\n\t\treturn ERROR;\n\te = *--S.top;\n\treturn OK;\n}\n```\n\n\n\n\n\n#### 🍨链栈的表示\n\n* 链栈是<font color=\"red\">运算受限</font>的单链表，只能在<font color=\"red\">链表头部</font>进行操作\n\n```c++\ntypedef struct StackNode{\n\tSElemType data;\n\tstruct StackNode *next;\n}StackNode,*LinkStack;\nLinkStack S;\n```\n\n* 链表的头指针就是栈顶\n* 不需要头结点\n* 基本不存在栈满的情况\n* 空栈相当于头指针指向空\n* 插入和删除仅在栈顶处执行\n\n\n\n##### 链栈的初始化\n\n```c++\nvoid InitStack(LinkStack &S){\n\t//构造一个空栈，栈顶指针置为空\n\tS = NULL;\n\treturn OK;\n}\n```\n\n\n\n##### 判断链栈是否为空\n\n```c++\nStatus StackEmpty(LinkStack S){\n\tif(S == NULL) return TRUE;\n\telse return FALSE;\n}\n```\n\n\n\n##### 链栈的入栈\n\n```c++\nStatus Push(LinkStack &S,SElemType e){\n\tStackNode *p;\n\tp = new StackNode;\n\tp->data = e;\n\tp->next = S;\n\tS = p;\n\treturn OK;\n}\n```\n\n\n\n##### 链栈的出栈\n\n```c++\nStatus Pop(LinkList &S,SElemType &e){\n\tif(S == NULL) return ERROR;\n\te = S->data;\n\t\n\tStacknode *p;\n\tp = S;\n\tS = S->next;\n\tdelete p;\n\treturn OK;\n}\n```\n\n\n\n##### 取栈顶元素\n\n```c++\nSElemType GetTop(LinkStack S){\n\tif(S != NULL) \n\treturn S->data;\n}\n```\n\n\n\n\n\n### 栈与递归\n\n#### 递归的定义\n\n* 若一个对象部分地<font color=\"red\">包含它自己</font>，或者用它<font color=\"red\">给自己定义</font>，则称这个对象是递归的\n* 若一个过程<font color=\"red\">直接或间接地调用自己</font>，则称这个过程是递归过程\n\n#### 以下这三种情况常常用到递归方法\n\n1. 递归定义的数学函数\n   * 阶乘函数\n   * 斐波那契数列\n2. 具有递归特性的数据结构\n   * 二叉树\n   * 广义表\n3. 可递归求解的问题\n   * 迷宫问题\n   * 汉诺塔问题\n\n#### 递归问题：用分治法求解\n\n分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解\n\n必备的三个条件：\n\n1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的\n2. 可以通过上述转化而使问题简化\n3. 必须有一个明确的递归出口，或称递归边界\n\n\n\n#### 分治法求解递归问题算法的一般形式\n\n```c++\nvoid p(参数表){\n\tif(递归结束条件) 可直接求解步骤;\t//基本项\n\telse p (较小的参数);\t//归纳项\n}\n```\n\n\n\n#### 函数调用过程\n\n调用前，系统完成：\n\n1. 将<font color=\"red\">实参，返回地址</font>等传递给被调用函数\n2. 为被调用函数的<font color=\"red\">局部变量</font>分配存储区\n3. 将控制转移到被调用函数的<font color=\"red\">入口</font>\n\n调用后，系统完成：\n\n1. 保存被调用函数的计算<font color=\"red\">结果</font>\n2. 释放被调用函数的<font color=\"red\">数据区</font>\n3. 依照被调用函数保存的<font color=\"red\">返回地址</font>将控制转移到调用函数\n\n\n\n#### 多个函数嵌套调用\n\n<font color=\"red\">遵循后调用的先返回</font>\n\n\n\n#### 递归函数调用的实现\n\n“层次”\n\n```\n主函数\t\t 0层\n第1次调用\t1层\n......\t\t\n第i次调用\ti层\n```\n\n“递归工作栈”\t——递归程序运行期间使用的数据存储区\n\n“工作记录”\t\t实际参数、局部变量、返回地址\n\n\n\n#### 递归的优缺点\n\n优点：结构清晰，程序易读\n\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n\n\n\n递归——>非递归\n\n方法1：尾递归、单向递归 ——>循环结构\n\n方法2：自用<font color=\"red\">栈</font>模拟系统的运行时候栈\n\n\n\n### 队列的表示和操作的实现\n\n#### 队列的抽象数据类型定义\n\n```\nADT Queue{\n\t数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}\n\t数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标\n\t基本操作：\n\t\tInitQueue(&Q);\n\t\tDestroyQueue(&Q);\n\t\t......\n}ADT Queue\n```\n\n\n\n#### 队列的顺序表示和实现\n\n用一维数组base[MAXQSIZE]\n\n```c++\n#define MAXQSIZE 100\ntypedef struct{\n\tQElemType *base;\t//指向数组首地址\n\tint front;\t\t\t//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标\n\tint rear;\t\t\t//尾指针\n}\n```\n\n\n\n**解决假上溢的方法：**\n\n1. 将队中元素依次向队头方向移动\n\n   缺点：浪费时间。每移动一次，队中元素都要移动\n\n2. 将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间\n\nbase[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；\n\n实现方法：利用<font color=\"red\">模运算（mod,c语言中：%）</font>\n\n\n\n**区分队空和队满**\n\n1. 另外设置一个标志来区分队空、队满\n\n2. 另设一个变量，记录元素个数\n\n3. <font color=\"red\">少用一个元素空间</font>\n\n   用第三种方法时：\n\n   队空：front == rear\n\n   队满：（rear+1）% MAXQSIZE == front\t\t\t//无论对front下标在哪都适用\n\n\n\n##### 队列的初始化\n\n```c++\nStatus InitQueue(SqQueue &Q){\n\tQ.base = new QElemType[MAXQSIZE];\n\tif(!Q.base) exit(OVERFLOW);\n\tQ.front = Q.rear = 0;\n\treturn OK;\n}\n```\n\n\n\n##### 求队列的长度\n\n```c++\nint QueueLength(SqQueue &Q){\n\treturn((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);\n}\n```\n\n\n\n##### 循环队列入队\n\n```c++\nStatus EnQueue(&Q,QElemType e){\n\tif( (Q.rear+1) % MAXQSIZE == Q.front) return ERROR;\n    Q.base[Q.rear] = e;\n\tQ.rear = (Q.rear + 1) % MAXQSIZE;\n    return OK;\n}\n```\n\n\n\n##### 循环队列出队\n\n```c++\nStatus DeQueue(&Q,&QElemType e){\n\tif(Q.front == Q.rear) return ERROR;\n\te = Q.base[Q.front];\n\tQ.front = (Q.front + 1) % MAXQSIZE;\n\treturn OK;\n}\n```\n\n\n\n##### 取队头元素\n\n```c++\nQElemType GetHead(Q){\n\tif(Q.front != Q.rear)\treturn Q.base[front];\n}\n```\n\n\n\n#### 队列的链式表示和实现\n\n若用户无法估计所用队列的长度，宜采用链队列\n\n* 带头结点\n\n\n\n##### 链队列的类型定义\n\n```c++\n#define MAXQSIZE 100\ntypedef struct Qnode{\n\tQElemType data;\n\tstruct Qnode *next;\n}Qnode,*QueuePtr;\n\ntypedef struct{\n    QueuePtr front;\t\t//头指针\n    QueuePtr rear;\t\t//尾指针\n}LinkQueue;\n```\n\n\n\n##### 链队列初始化\n\n```c++\nStatus InitQueue(LinkQueue &Q){\n\tQ.front = Q.rear = new Qnode;\n\tif(!Q.front) exit(OVERFLOW);\n\tQ.front->next = NULL;\n\treturn OK;\n}\n```\n\n\n\n##### 链队列的销毁\n\n```c++\nStatus DestroyQueue(LinkQueue &Q){\n\tQnode *p;\n\twhile(Q.front){\n\t\tp = Q.front->next;\n\t\tdelete Q.front;\n\t\tQ.front = p;\n\t}//这里Q.rear 没什么用，可以直接用它来代替p\n\treturn OK;\n}\n```\n\n\n\n##### 链队列入队\n\n```c++\nStatus EnQueue(LinkQueue &Q,QElemType e){\n\tQnode *p;\n\tp = new Qnode;\n    if(!p) exit(OVERFLOW);\n\tp->data = e;\n\tp->next = NULL;\n\t\n\tQ.rear->next = p;\n    Q.rear = p;\n\treturn OK;\n}\n```\n\n\n\n##### 链队列出队\n\n```c++\nStatus DeQueue(LinkQueue &Q,QElemType &e){\n\tif(Q.front == Q.rear) return ERROR;\n\tQnode *p;\n\tp = Q.front->next;\n\te = p->data;\n\tQ.front->next = Q.front->next->next;\n\t\n\tif(Q.rear == p) Q.rear = Q.front;\t//如果恰好删除的是尾结点，那么尾指针也指向\n\t\t\t\t\t\t\t\t\t\t// 头结点\n\tdelete p;\n\treturn \n}\n```\n\n\n\n##### 求链队列队头元素\n\n```c++\nStatus GetHead(LinkQueue Q,QElemType &e){\n\tif(Q.front == Q.rear) return ERROR;\n\te = Q.front->next->data;\n\treturn OK;\n}\n```\n\n\n\n\n\n## 串\n\n### 串的定义\n\n串（string）：零个或多个任意字符组成的有限序列\n\ns = “a~1~a~2~···a~n~” (n>=0)\n\n串名：s\n\n串值：a~1~到a~n~\n\n串长：n\n\n空串：n=0\t用∅表示\n\n子串：串中任意个连续字符组成的子序列称为该串的子串\n\n真子串：不包含自身的所有子串\n\n主串：包含子串的串\n\n字符位置：字符在序列中的序号为该字符在串中的位置\n\n子串位置：子串中第一个字符在主串中的位置\n\n空格串：由一个或多个空格所构成的串，与空串不同\n\n串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等\n\n​\t\t\t\t所有的空串都是相等的\n\n\n\n### 串的类型定义\n\n```\nADT String{\n\t数据对象：字符\n\t数据关系：序偶关系\n\t基本操作：\n\t\t1.串赋值\n\t\t2.串比较\n\t\t3.求串长\n\t\t4.串连结\n\t\t5.求子串\n\t\t6.串拷贝\n\t\t7.清空串\n\t\t8.串判空\n\t\t9.子串的位置\n\t\t10.串替换\n\t\t11.子串插入\n\t\t12.子串删除\n\t\t13.串销毁\n}ADT String\n```\n\n\n\n### 串的存储结构\n\n串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）\n\n#### 串的顺序存储结构\n\n```c++\n#define MAXLEN 255\ntypedef struct{\n\tchar ch[MAXLEN+1];\t//0号位置不用\n\tint length;\n}SString\n```\n\n\n\n#### 串的链式存储结构\n\n与单链表类似\t优点：操作方便\t\t缺点：存储密度较低\n\n为了克服缺点，可将多个字符放在一个结点中，称为<font color=\"red\">块</font>\n\n```\n#define CHUNKSIZE 80\ntypedef struct Chunk{\n\tchar ch[CHUNKSIZE];\n\tstruct Chunk *next;\n}Chunk;\n\ntypedef struct{\n\tChunk *head,*tail;\t//串的头指针和尾指针\n\tint curlen;\t\t\t//串的当前长度\n}LString;\t\t\t\t//字符串的块链结构\n```\n\n\n\n### 串的模式匹配算法\n\n算法目的：确定主串中所含子串（模式串）第一次出现的位置\n\n算法应用：搜索引擎、拼写检查、语言翻译、数据压缩\n\n算法种类：BF算法、KMP算法\n\n\n\n#### BF算法\n\n简单匹配算法，采用穷举法的思路\n\n算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配\n\n\n\n##### 设计思想\n\nIndex (S,T,pos)\n\n* 将主串的第pos个字符和模式串的第一个字符比较\n* 若相等，继续逐个比较后续字符\n* 若不等，从主串的下一字符起，重新与模式串的第一个字符比较\n* 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功\n* 否则，匹配失败，返回值为0\n\n\n\n##### 算法描述\n\n```c++\nint Index_BF(SString S,SString T，int pos){\t//pos是从什么位置开始寻找\n\tint i=pos,j=1;\n\t\n\twhile(i<=S.length && j<=T.length){\n\t\tif(S.ch[i] == T.ch[j])\t{++i;++j;}\t//主串和子串依次匹配下一个字符\n\t\telse {j = 1; i = i - j + 2;}\t\t//主串、子串回溯开始下一次匹配\n\t}\n\tif(j>T.length) return i-T.length;\t\t//匹配成功返回第一个字符的下标\n\telse return 0;\t\t\t\t\t\t\t//匹配失败\n}\n```\n\n\n\n##### 算法时间复杂度\n\n主串长度为n，子串长度为m\n\n最好情况：O（m）\n\n最坏情况：O [ (n-m)*m + m ]\t若 m<<n，则算法复杂度为 O (m * n)\n\n\n\n#### KMP算法\n\n该算法较BF有较大改进，从而算法效率有了某种程度的提高\n\n\n\n##### 算法思想\n\n利用已经<font color=\"red\">部分匹配</font>的结果而加快模式串的滑动速度\n\n且主串S的指针<font color=\"red\">i不必回溯</font>，可提速到<font color=\"red\">O（m+n）</font>\n\n\n\n##### next[j]数组\n\n表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置\n\n​\t\t\t\t\tmax\t\n\nnext [j] = \t0\t当j=1时\n\n​\t\t\t\t\t1\t其他情况\n\n\n\n##### 算法描述\n\n```c++\nint Index_KMP(SString S,SString T，int pos){\n\tint i=pos,j=1;\n\t\n\twhile(i<=S.length && j<=T.length){\n\t\tif(S.ch[i] == T.ch[j])\t{++i;++j;}\t\n\t\telse \tj = next[j];\t\t//i不变，j后退 （与BF算法的区别）\n\t}\n\tif(j>T.length) return i-T.length;\n\telse return 0;\t\t\t\n}\n```\n\n获得next[j]数组的函数\n\n```c++\nvoid get_next(SString T,int &next[]){\n\ti = 1;next[1] = 0;j = 0;\n\twhile(i<T.length){\n\t\tif(j==0||T.ch[i]==T.ch[j]){\n\t\t\t++i;++j;\n\t\t\tnext[i] = j;  //如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1\n\t\t}\n\t\telse j = next[j]; //如果不相等，变成重新再找前j个字符的最长公共前缀子串，再\t\t\t\t\t\t  //移下一位看是否相等\n\t}\n}\n```\n\n理解：\n\n[(7条消息) KMP算法原理描述，告诉你为什么要“j = next[j\\]”_Leycaner的博客-CSDN博客_j=next[j]](https://blog.csdn.net/Leycaner/article/details/108301195)\n\n\n\n##### next函数的改进\n\n```c++\nvoid get_nextval(SString T,int &nextval[]){\n\ti = 1;nextval[1] = 0;j = 0;\n\twhile(i<T.length){\n\t\tif(j==0||T.ch[i]==T.ch[j]){\n\t\t\t++i;++j;\n\t\t\tif(T.ch[i]!=T.ch[j]) nextval = j;\n\t\t\telse nextval[i] = nextval[j];\n \t\t}\n\t\telse j = nextval[j]; \n\t}\n}\n```\n\n\n\n## 数组\n\n按一定格式排列起来的具有<font color=\"red\">相同类型</font>的数据元素的集合\n\n**结论：**线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展\n\n**特点：**结构固定\n\n**数组基本操作：**除了结构的初始化和销毁之外，只有取元素和修改元素值的操作\n\n\n\n### 数组的抽象数据类型定义\n\n<font color=\"red\">n维数组</font>的抽象数据类型\n\nADT Array{\n\n​\t数据对象： j~i~ = 0,······,b~i~-1\ti = 1,2,······n\t\t\t\tn为数组的维数，b~i~为数组第i维的长度\n\n​\t\t\t\t\t\tD = {a~j1j2······jn~|a~j1j2······jn~ ∈ElemSet}\n\n​\t数据关系：\n\n​\t\t\t\t\t\tR1 = {<a~j1······ji······jn~，a~j1······ji+1······jn~>|0<=j~k~<=b~k~-1 , 1<=k<=n, 且k≠i, 0<=j~i~<=b~k~-2,\n\n​\t\t\t\t\t\t\t\t\t<a~j1······ji······jn~，a~j1······ji+1······jn~>∈D ,i = 2,······,n}\n\n}\n\n\n\n基本操作\n\n```\n1.InitArray(&A,n,bound1,...boundn)\t\t//n是维数，boundn是每一维的上界\n2.DestoryArray(&A)\n3.Value(A,&e,index1,...indexn)\n4.Assign(A,&e,index,...indexn)\n}ADT Array\n```\n\n\n\n### 数组的顺序存储\n\n数组特点：结构固定\n\n数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作\n\n<font color=\"red\">所以：</font>一般都是用<font color=\"blue\">顺序存储结构</font>来表示数组\n\n注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的\n\n\n\n**一维数组**\n\n​\t\t\t\t\tLOC(0) = a\t\t\t\t\t\t\ti = 0\n\nLOC（i）=  \n\n​\t\t\t\t\tLOC(i-1) + L = a + i * L,\t\ti > 0\n\n\n\n**二维数组**\n\n两种存储方式：\n\n1. 以行序为主序\t\tLOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L \t\t\tn列数  m行数\n2. 以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L \n\n\n\n**三维数组**\n\n按 页/行/列 存放，页优先的顺序存储\n\na[m1] [m2] [m3] 各维元素个数为m1,m2,m3\n\n下标为i~1~,i~2~,i~3~的数组元素的存储位置\n\nLOC ( i~1~,i~2~,i~3~ ) = a + i~1~ * m2 * m3 + i~2~ * m3 + i~3~\n\n\n\n\n\n### 特殊矩阵的压缩存储\n\n矩阵的常规存储：描述为二维数组\n\n矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1\n\n不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多\n\n矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间\n\n1. 什么是压缩存储\n\n   若多个数据元素的<font color=\"red\">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间\n\n2. 什么样的矩阵能够压缩\n\n   一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等\n\n3. 什么叫稀疏矩阵\n\n   矩阵中非零元素很少（一般少于5%）\n\n\n\n#### 对称矩阵\n\n**特点：**对角线上下两边都对称，即a~ij~ = a~ji~  (1<=i,j<=n)\n\n**存储方法：**只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间\n\n**存储结构：**\n\n可以<font color=\"red\">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中\n\n一维数组中的元素，它前面有多少个元素它就在第几个位置\n\n假如求 a~ij~ 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1\t（下三角）\n\n\n\n#### 三角矩阵\n\n**特点：**对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c\n\n**存储方法：**重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间\n\n​\t\t\t\t\t类似于对称矩阵\n\n\n\n#### 对角矩阵\n\n**特点：**所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color=\"red\">对角矩阵</font>\n\n**存储方法：**用二维数组存储，每一个对角线上的所有元素存储为一行\n\n|      |  1   |  2   |  3   |  4   |  5   |  6   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  -2  |      |      |  3   |  3   |  8   |  5   |\n|  -1  |      |  2   |  0   |  6   |  1   |  2   |\n|  0   |  8   |  2   |  7   |  9   |  4   |  3   |\n|  1   |  4   |  7   |  6   |  1   |  8   |      |\n|  2   |  5   |  9   |  6   |  2   |      |      |\n\n其中主对角线存储在行标为0的行中\n\n\n\n#### 稀疏矩阵\n\n三元组法：三元组（i，j，a~ij~）唯一确定矩阵的一个非零元\n\n矩阵由所有三元组和矩阵维数（m，n）唯一确定\n\n**压缩存储原则：**存各非零元的值、行列位置和矩阵的行列数\n\n\n\n1、顺序存储结构：三元组顺序表\n\n|      | i（行数） |  j（列数）  |     v（元素值）     |\n| :--: | :-------: | :---------: | :-----------------: |\n|  0   | 6(总行数) | 6（总列数） | 8（非零元素总个数） |\n|  1   |     1     |      2      |         12          |\n|  2   |     1     |      3      |          9          |\n|  3   |     3     |      1      |         -3          |\n\n三元组顺序表又称<font color=\"red\">有序的双下标法</font>\n\n优点：非零元在表中按行序有序存储，因此<font color=\"red\">便于进行依行顺序处理的矩阵运算</font>\n\n缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找\n\n\n\n2.链式存储结构：十字链表\n\n优点：能够<font color=\"red\">灵活地插入</font>因运算而产生的新的非零元素，<font color=\"red\">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。\n\n表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）\n\nright：用于链接同一行中的下一个非零元素\n\ndown：用于链接同一列中的下一个非零元素\n\n| 头结点  | M.chead |      |      |      |\n| :-----: | :-----: | :--: | :--: | :--: |\n| M.rhead |  结点   |      |      | 结点 |\n|         |         | 结点 |      |      |\n|         |  结点   |      |      |      |\n\n\n\n\n\n\n\n## 广义表\n\n广义表（又称列表List）是n个元素的有限序列，其中每一个a~i~或者是<font color=\"red\">原子</font>或者是一个<font color=\"red\">广义表</font>\n\n拓宽了的线性表就是广义表。\n\n\n\n### 广义表的定义\n\n* 广义表通常记作：LS = （a~1~,a~2~,……,a~n~）\n\n​\t其中：LS为表名，n为表的长度，每一个a~i~为表的元素\n\n* 习惯上，一般用大写字母表示广义表，小写字母表示原子\n* 表头：若LS非空，则其第一个元素a~1~就是表头，记作head（LS） = a~1~ <font color=\"red\">注：</font>表头可以是原子或子表\n* 表尾：除表头之外<font color=\"red\">其他元素</font>组成的表，记作tail（LS） = （a~2~,……,a~n~） <font color=\"red\">注：</font>表尾不是最后一个元素，而是一个子表\n\n\n\n### 广义表的性质\n\n1. 广义表中的数据元素有相对 <font color=\"red\">次序</font>；一个直接前驱和一个直接后继\n2. 广义表的<font color=\"red\">长度</font>定义为最外层所包含元素的个数\n3. 广义表的<font color=\"red\">深度</font>定义为该广义表 <font color=\"blue\">展开后所含括号的重数；</font>  <font color=\"red\">注：</font>“原子”的深度为0；“空表”的深度为1\n4. 广义表可以为其他广义表<font color=\"red\">共享</font>\n5. 广义表可以是一个 <font color=\"red\">递归</font>的表。<font color=\"red\">注：</font>递归表的深度是无穷值，长度是有限值\n6. 广义表是<font color=\"red\">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表\n\n\n\n### 广义表和线性表的区别\n\n广义表可以看成是线性表的推广，线性表是广义表的特例\n\n广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构\n\n\n\n### 广义表的基本运算\n\n1. 求表头GetHead（L)，可以是一个原子也可以是一个子表\n2. 求表尾GetTail（L)，一定是一个子表\n\n\n\n### 广义表的存储\n\n因为表中元素的大小不固定，所以不用数组存储，一般用链表存储\n\n\n\n\n\n## ⛄树和二叉树\n\n### 树的定义\n\n树（Tree）是n（n>=0）个结点的有限集（递归定义）。\n\n若n=0，称为空树；\n\n若n>0，则它满足如下两个条件：\n\n\t1. 有且仅有一个特定的称为 根 的结点\n\t2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）\n\t3. \n\n\n\n\n\n### 树的基本术语\n\n结点：数据元素以及指向子树的分支\n\n根节点：非空树中无前驱结点的结点\n\n结点的度：结点拥有的子树数\n\n树的度：树内各结点的度的最大值\n\n叶子结点：度为0，也叫作终端节点\n\n分支结点：度不为0，非终端结点\n\n内部结点：根节点以外的分支结点\n\n结点的子树称为该结点的<font color=\"red\">孩子</font>，该结点称为孩子的<font color=\"red\">双亲</font>\n\n拥有同一个双亲的结点称为<font color=\"red\">兄弟结点</font>\n\n双亲在同一层但双亲不同的结点称为<font color=\"red\">堂兄弟结点</font>\n\n结点的<font color=\"red\">祖先</font>：从根到该结点所经分支上的所有结点\n\n结点的<font color=\"red\">子孙</font>：以某结点为根的子树中的任一结点\n\n树的<font color=\"red\">深度</font>：树中结点的最大层次\n\n<font color=\"red\">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）\n\n<font color=\"red\">无序树：</font>树中结点的各子树无次序\n\n<font color=\"red\">森林：</font>是m（m>=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树\n\n\n\n\n\n### 二叉树的定义\n\n为什么要研究二叉树？\n\n答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。\n\n\n\n**定义**\n\n二叉树是n（n>=0）个结点的有限集，它或者是空集，或者由一个<font color=\"blue\">根结点</font>及<font color=\"red\">两个互不相交</font>的分别称作这个根的<font color=\"blue\">左子树</font>和<font color=\"blue\">右子树</font>的二叉树组成。\n\n\n\n**特点**\n\n1. 每个结点最多有两个孩子<font color=\"red\">（二叉树中不存在度大于2的结点）</font>\n2. 子树有左右之分，其次序不能颠倒\n3. 二叉树可以是空集合，根可以有空的左子树或空的右子树\n\n\n\n<font color=\"red\">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。\n\n\n\n### 二叉树的抽象数据类型定义\n\n**二叉树的抽象数据类型定义**\n\n```\nADT BinaryTree{\n\t数据对象D：D是具有相同特性的数据元素的集合\n\t数据关系R：若D=∅，则R=∅\n\t\t\t  若D≠∅，则R={H},H是如下二元关系\n\t\t\t  1. root唯一//关于根的说明\n\t\t\t  2. ......//子树不相交\n\t\t\t  3. ......//关于数据元素的说明\n\t\t\t  4. ......//关于左子树和右子树的说明\n\t基本操作P：//至少有20个\n}ADT BinaryTree\n```\n\n**比较重要的几个操作：**\n\n```\nCreateBiTree(&T,definition)\n\t初始条件：definition给出二叉树T的定义\t//definition是指构造方式（先序...)\n\t操作结果：按definition构造二叉树T\nPreOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：先序遍历T，对每个结点访问一次\nInOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：中序遍历T，对每个结点访问一次\nPostOrderTraverse(T)\n\t初始条件：二叉树T存在\n\t操作结果：后序遍历T，对每个结点访问一次\n```\n\n\n\n\n\n### 二叉树的性质\n\n<font color=\"red\">性质1：</font>在二叉树的第i层上<font color=\"blue\">最多</font>有2^i-1^个结点（i>=1）\n\n<font color=\"red\">性质2：</font>深度为k的二叉树<font color=\"blue\">最多</font>有2^k^-1个结点（k>=1）\t<font color=\"red\">深度为k时至少有k个结点</font>\n\n<font color=\"red\">性质3：</font>对任意一颗二叉树T，如果其叶子数为n~0~，度为2的结点数为n~2~，则<font color=\"red\">n~0~=n~2~+1</font>\n\n从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）\n\n从上往下：B = n~2~ * 2 + n~1~ * 1\n\nB = n~2~ * 2 + n~1~ * 1 =  n - 1\n\nn = n~2~ * 2 + n~1~ * 1 + 1\n\n又因为n = n~0~ + n~1~ + n~2~\t两式相结合得到 n~0~=n~2~+1\n\n\n\n**两种特殊形式的二叉树**\n\n**满二叉树**\n\n一颗深度为k且有2^k^-1个结点的二叉树称为<font color=\"blue\">满二叉树</font>\n\n特点：1. 每层都满\t2. 叶子结点全部在最底层\n\n对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。\n\n* 满二叉树在同样深度的二叉树中<font color=\"red\">结点</font>个数最多\n* 满二叉树在同样深度的二叉树中<font color=\"red\">叶子结点</font>个数最多\n\n\n\n**完全二叉树**\n\n深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color=\"red\">一一对应</font>时，称为完全二叉树\n\n注：在满二叉树中，从最后一个结点开始<font color=\"red\">连续</font>去掉<font color=\"red\">任意</font>个结点，即是一棵完全二叉树\n\n特点：1. 叶子只可能分布在层次最大的两层上\n\n​\t\t\t2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1\n\n\n\n<font color=\"red\">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log~2~n ⌋ + 1\t\t(完全二叉树结点n与深度k的关系)\n\n<font color=\"red\">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log~2~n ⌋ + 1层，每层从左到右），则对任一结点i（1<=i<=n），有\n\n1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其<font color=\"red\">双亲结点是⌊ i / 2 ⌋</font>\n2. 如果2i>n，则结点i为叶子结点，无左孩子；否则，其<font color=\"red\">左孩子结点是2i</font>\n3. 如果2i + 1>n，则结点i无右孩子；否则，其<font color=\"red\">右孩子结点是2i+1</font>\n\n性质5表明了完全二叉树中<font color=\"red\">双亲结点编号</font>与<font color=\"red\">孩子结点编号</font>之间的关系\n\n<font color=\"red\">性质6：</font>\n\n\n\n\n\n### 二叉树的存储结构\n\n#### 二叉树的顺序存储\n\n按<font color=\"red\">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素\n\n```c++\n//二叉树顺序存储表示\n#define MAXTSIZE 100\ntypedef TElemType SqBiTree[MAXSIZE];\t//定义了一种数组类型，元素类型TElemType\nSqBiTree bt;\n```\n\n若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0\n\n二叉树的顺序存储缺点：\n\n最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组\n\n结点间关系蕴含在其存储位置中，浪费空间，适于存<font color=\"red\">满二叉树和完全二叉树</font>\n\n\n\n#### 二叉树的链式存储结构\n\n二叉链表存储结构\n\n```\ntypedef struct BiNode{\n\tTElemType data;\n\tstruct BiNode *lchild,*rchild;\t//左右孩子指针\n}BiNode,*BiTree;\n```\n\n\n\n在n个结点的二叉链表中，必有<font color=\"red\">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color=\"red\">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中\n\n<font color=\"red\">空指针数目= 2n - (n-1) = n +1</font>\n\n\n\n#### 三叉链表\n\n三个指针域：lchild、rchild、parent\n\n```c++\ntypedef struct TriTNode{\n    TElemType data;\n    struct TriTNode *lchid,*rchild,*parent;\n}TriTNode,*TriTree;\n```\n\n\n\n\n\n### 遍历二叉树\n\n<font color=\"red\">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]\n\n<font color=\"red\">遍历目的：</font>得到树中所有结点的一个线性排列\n\n<font color=\"red\">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心\n\n\n\n#### 遍历二叉树算法描述\n\n**遍历方法**\n\n若规定**先左后右**，则只有三种情况：\n\nDLR - 先序遍历\n\nLDR - 中序遍历\n\nLRD - 后序遍历\n\n|        先序遍历二叉树        |        中序遍历二叉树        |        后序遍历二叉树        |\n| :--------------------------: | :--------------------------: | :--------------------------: |\n| 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 |\n|         1.访问根结点         |       1.中序遍历左子树       |       1.后序遍历左子树       |\n|       2.先序遍历左子树       |         2.访问根结点         |       2.后序遍历右子树       |\n|       3.先序遍历右子树       |       3.中序遍历右子树       |         3.访问根结点         |\n\n\n\n#### 根据遍历序列确定二叉树\n\n* 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的\n* 由二叉树的<font color=\"red\">先序序列和中序序列</font>，或由二叉树的<font color=\"red\">后序序列和中序序列</font>可以确定唯一一颗二叉树\n\n\n\n**已知先序和中序序列求二叉树**\n\n分析：由先序序列确定根，由中序序列确定左右子树\n\n\n\n**已知中序和后序序列求二叉树**\n\n分析：由后序序列确定根，由中序序列确定左右子树\n\n\n\n\n\n#### 遍历的算法实现\n\n##### 先序遍历\n\n存储结构：二叉链表\n\n方法：递归\n\n```c++\nStatus PreOrderTraverse(BiTree T){\t\t//递归后传递进来的就是T->child的值了\n\tif(T==NULL) return OK;\n\telse{\n\t\tvisit(T);\t//访问根结点\t例如，输出根结点：cout<<T->data;\n\t\tPreOrderTraverse(T->lchild);\t//递归遍历左子树\n\t\tPreOrderTraverse(T->rchild);\t//递归遍历右子树\n\t}\n}\n```\n\n```c++\nvoid Pre(BiTree T){\t\t\t//例子\n\tif(T!=NULL){\n\t\tcout<<T->data;\n\t\tpre(T->lchild);\n\t\tpre(T->rchild);\n\t}\n}\n```\n\n\n\n\n\n##### 中序遍历\n\n```c++\nStatus InOrderTraverse(BiTree T){\t//中序遍历\n\tif(T==NULL) return OK;\n    else{\n        InOrderTraverse(T->lchild);\n        visit(T);\n        InOrderTraverse(T->rchild);\n    }\n}\n```\n\n\n\n##### 后序遍历\n\n```c++\nStatus PostOrderTraverse(BiTree T){\t//后序遍历\n\tif(T==NULL) return OK;\n\telse{\n\t\tPostOrderTraverse(T->lchild);\n\t\tPostOrderTraverse(T.>rchild);\n\t\tvisit(T);\n\t}\n}\n```\n\n\n\n#### 遍历算法的分析\n\n如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。\n\n第1次经过时访问 = 先序遍历\n\n第2次经过时访问 = 中序遍历\n\n第3次经过时访问 = 后序遍历\n\n\n\n时间复杂度O（n）\t//每个结点只访问一次\n\n空间复杂度O（n）\t//栈占用的最大辅助空间（都是左子树或者都是右子树）\n\n\n\n#### 遍历二叉树的非递归算法\n\n##### 中序遍历非递归算法\n\n关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树\n\n<font color=\"red\">基本思想：</font>\n\n1. 建立一个<font color=\"red\">栈</font>\n2. <font color=\"red\">根</font>结点<font color=\"red\">进栈</font>，遍历<font color=\"red\">左子树</font>\n3. <font color=\"red\">根</font>结点<font color=\"red\">出栈</font>，输出根结点，遍历<font color=\"red\">右子树</font>\n\n\n\n```c++\nStatus InOrderTraver(BiTree T){\t\t//T是根结点\n    BiTree p; InitStack(S); p = T;\t//p是当前要出栈或者入栈的结点\n    while(p||!StackEmpty(S)){\n        if(p) {push(S,p); p = p->lchild;}\n        else  {pop(S,q); cout<<q->data; p = q->rchild;}\t//q是栈顶元素\n    }\n    return OK;\n}\n```\n\n\n\n#### 二叉树的层次遍历\n\n对于一颗二叉树，从根结点开始，按<font color=\"red\">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。\n\n实现的关键：<font color=\"red\">顺序循环队列</font>\n\n队列类型定义如下\n\n```c++\ntypedef struct{\n\tBTNode data[MAXSIZE];\t//存放队中元素\n\tint front, rear;\t\t//队头和队尾指针\n}SqQueue;\n```\n\n层次遍历算法\n\n```c++\nvoid LevelOrder(BTNode &b){\n\tBTNode *p; SqQueue *qu;\tp = b;\n\tInitQueue(qu);\t\t\t\t//初始化队列\n\tenQueue(qu,b);\t\t\t\t//根结点指针进入队列\n\twhile(!QueueEmpty(qu)){\t\t//队不为空，则循环\n\t\tdeQueue(qu,p);\t\t\t//出队结点p（应该是队首元素）\n\t\tcout<<p->data;\t\t\t//访问结点p\n\t\tif(p->lchild != NULL) enQueue(qu,p->lchild);\t//有左孩子时将其进队\n\t\tif(p->rchild !=NULL) enQueue(qu,p->rchild);\t\t//有右孩子时将其进队\n\t}\n}\n```\n\n\n\n#### 二叉树的建立\n\n**按先序遍历建立二叉树的二叉链表**\n\n例：ABCDEGF\t如果只这么输入，树不是唯一的，所以<font color=\"red\">空结点用其他符号表示</font>\n\n```c++\nStatus CreateBiTree(BiTree &T){\n\tchar ch;\n    cin>>ch;\n    if(ch == '#') T == NULL;\n    else{\n        if(!(T = new BiTNode)) exit(OVERFLOW);\n        T->data = ch;\t\t\t\t//生成根结点\n        createBiTree(T->lchild);\t//构造左子树\n        createBiTree(T->rchild);\t//构造右子树\n    }\n    return OK;\n}\n```\n\n\n\n#### 复制二叉树\n\n**先序遍历复制二叉树**\n\n* 如果是空树，递归结束；\n* 否则，申请新结点空间，复制根结点\n  * 递归复制左子树\n  * 递归复制右子树\n\n```c++\nint Copy(BiTree, BiTree &NewT){\n\tif(BtTree == NULL){\n\t\tNewT = NULL; return 0;\t//如果是空树返回0\n\t}\n\telse{\n\t\tNewT = new BiTNode;\t\t//内存中申请一块新结点空间\n\t\tNewT->data = T->data;\t//将data域中的值复制到新结点当中\n\t\tCopy(T->lchild, NewT->lchild);\t//递归复制左子树\n\t\tCopy(T->rchild, NewT->rchild);\t//递归复制右子树\n\t}\n}\n```\n\n\n\n\n\n#### 计算二叉树深度\n\n* 如果是空树，深度为0\n* 否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1\n\n```c++\nint Depth(BiTree){\n\tif(T == NULL) return 0;\n\telse{\n\t\tm = Depth(T->lchild);\n\t\tn = Depth(T->rchild);\n\t\treturn m>n?m+1:n+1;\n\t}\n}\n```\n\n\n\n\n\n#### 计算二叉树结点总个数\n\n* 如果是空树，则结点个数为0\n* 否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）\n\n```c++\nint NodeCount(BiTree T){\n\tif(T == NULL) return 0;\n\telse return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;\n}\n```\n\n\n\n\n\n#### 计算二叉树叶子结点树\n\n* 如果是空树，叶子结点个数为0\n* 否则，为左子树的叶子结点树+右子树的叶子结点数\n\n```c++\nint LeafCount(BiTree T){\n\tif(T == NULL) return 0;\t\t//如果是空树返回0\n\tif(T->lchild == NULL && T->rchild == NULL) return 1; //如果是叶子结点返回1\n\telse return LeafCount(T->lchild)+LeafCount(T->rchild);\n}\n```\n\n\n\n\n\n\n\n### 线索二叉树\n\n**为什么要研究线索二叉树**？\n\n当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color=\"red\">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font>\n\n\n\n**如何寻找特定遍历序列中二叉树结点的前驱和后继？**\n\n解决方法：\n\n1. 通过遍历寻找\t\t\t\t\t\t费时间\n2. 添加前驱、后继指针域         费空间\n3. <font color=\"red\">利用二叉链表的空指针域</font>\n\n\n\n**二叉链表中空指针域的数量**\n\nn个结点的二叉树有2n个指针域，n个结点中有<font color=\"red\">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color=\"red\">n + 1 个指针域为空</font>\n\n\n\n**利用二叉链表中的空指针域**\n\n如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color=\"red\">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color=\"red\">指向其后继</font>\n\n这种<font color=\"red\">改变指向的指针</font>称为<font color=\"red\">“线索”</font>\n\n加上了线索的二叉树称为<font color=\"red\">线索二叉树</font>\n\n对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color=\"red\">线索化</font>\n\n\n\n\n\n**区分孩子指针和前驱后继指针**\n\n为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color=\"red\">每个结点增设两个标志域 ltag 和 rtag</font>\n\nltag = 0\tlchild指向该结点的左孩子\n\nltag = 1\tlchild指向该结点的前驱\n\nrtag = 0\trchild指向该结点的右孩子\n\nrtag = 1\trchild指向该结点的后继\n\n\n\n#### 结点的结构\n\n```c++\ntypedef struct BiThrNode{\n\tint data;\n    int ltag,rtag;\n    struct BiThrNode *lchild,*rchild;\n}BiThrNode,*BiThrTree;\n```\n\n\n\n#### **增加一个头结点**\n\n为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点\n\nltag=0，lchild指向根结点\n\nrtag=1，rchild指向遍历序列中的最后一个结点\n\n遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点\n\n\n\n\n\n\n\n### 树和森林\n\n#### 树的存储结构\n\n##### 1.双亲表示法\n\n实现：定义数据结构，每个结点含两个域\n\n数据域：存放结点本身信息\n\n双亲域：指示本结点的双亲结点在数组中的位置\n\nr = 0  根结点位置\tn = 10 结点数，方便定义数组\n\n特点：找双亲容易，找孩子难\n\n\n\n**结点的类型定义**\n\n结点结构：\n\n```c++\ntypedef struct PTNode{\n\tTElemType data;\n\tint parent;\n}PTNode;\n```\n\n树结构：\n\n```c++\n#define MAX_TREE_SIZE 100\ntypedef struct{\n\tPTNode nodes[MAX_TREE_SIZE];\n\tint r,n;\n}PTree;\n```\n\n\n\n\n\n##### 2.孩子链表\n\n把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。\n\n则n个结点有n个孩子链表（叶子的孩子链表为空表）。\n\n而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。\n\n特点：找孩子容易，找双亲难\n\n\n\n**类型定义**\n\n孩子结点结构\n\n```c++\ntypedef struct CTNode{\n\tint child;\n\tstruct CTNode *next;\n}*ChildPtr;\n```\n\n双亲结点结构\n\n```c++\ntypedef struct {\n\tTElemType data;\n\tChildPtr firstchild;\t//孩子链表头指针\n}CTBox;\n```\n\n树结构\n\n```c++\ntypedef struct {\n\tCTBox nodes[MAX_TREE_SIZE];\n\tint n,r;\t//结点数和根结点的位置\n}CTree;\n```\n\n\n\n为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color=\"red\">带双亲的孩子链表。</font>\n\n\n\n\n\n##### 3.孩子兄弟表示法\n\n实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color=\"red\">第一个孩子结点</font>和<font color=\"red\">下一个兄弟结点</font>\n\n```c++\ntypdedef struct CSNode{\n\tElemType data;\n\tstruct CSNode *firstchild,*nextsibling;\n}CSNode,*CSTree;\n```\n\n特点：查找孩子容易，查找双亲难\n\n\n\n\n\n####  树与二叉树的转换\n\n将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作\n\n由于树和二叉树都可以用二叉链表作存储结构，则<font color=\"red\">以二叉链表作媒介</font>可以导出树与二叉树之间的一个对应关系\n\n<font color=\"red\">给定一颗树，可以找到唯一的一棵二叉树与之对应</font>\n\n \n\n**将树转换成二叉树**\n\n1.加线：在兄弟之间加一条线\n\n2.抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系\n\n3.旋转：以树的根结点为轴心，将整树顺时针转45°\n\n\n\n**将二叉树转换成树**\n\n1.加线：若p结点是双亲结点的左孩子，则将p的有孩子，有孩子的有孩子……延分支找到所有的右孩子，都与p的双亲用线连起来\n\n2.抹线：抹掉原二叉树中双亲与右孩子之间的连线\n\n3.调整：将结点按层次排列，形成树结构\n\n\n\n\n\n#### 森林与二叉树的转化\n\n**森林转化成二叉树**\n\n1.将各棵树分别转换成二叉树\n\n2.将每棵树的根节点用线相连\n\n3.以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构\n\n\n\n**二叉树转化成森林**\n\n1.抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子建连线全部抹掉，使之变成孤立的二叉树\n\n2.还原：将孤立的二叉树还原成树\n\n\n\n#### 树和森林的遍历\n\n**1.树的遍历（三种方式）**\t\t 【二叉树的遍历有四种方式：先根、中根、后根、层次】\n\n* 先根遍历：\n\n  若树不空，则先访问根结点，然后依次先根遍历各棵子树\n\n* 后根遍历：\n\n  若树不空，则先依次后根遍历各棵子树，然后访问根结点\n\n* 参差遍历：\n\n  若树不空，则自上而下从左至右访问树中每个结点 \n\n\n\n**2.森林的遍历**\n\n将森林看做有三部分构成：\n\n1.森林中第一棵树的根结点；\n\n2.森林中第一棵树的子树森林；\n\n3.森林中其他树构成的森林\n\n\n\n**先序遍历：**\n\n若森林不空，则\n\n1.访问森林中第一棵树的根结点；\n\n2.先序遍历森林中第一棵树的子树森林；\n\n3.先序遍历森林中（除第一棵树之外）其余树构成的森林\n\n<font color=\"red\">即：依次从左至右对森林中每一棵树进行先根遍历</font>\n\n<font color=\"red\">还有一种很简单的方法：即对森林中每一棵树依次进行先序遍历</font>\n\n\n\n**中序遍历：**\n\n若森林不空，则\n\n1.中序遍历森里中第一棵树的子树森林；\n\n2.访问森林中第一棵树的根结点；\n\n3.中序遍历森林中（除第一棵树之外）其余树构成的森林\n\n<font color=\"red\">即：依次从左至右对森林中每一棵树进行中序遍历</font>\n\n  \n\n\n\n\n\n### 哈夫曼树及应用\n\n#### 哈夫曼树的基本概念\n\n<font color=\"red\">判断树：</font>用于描述分类过程的二叉树\n\n路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径\n\n路径的长度：两结点间路径上的分支数\n\n树的路径长度：从<font color=\"red\">树根</font>到每一个结点的<font color=\"red\">路径长度之和</font>。记作：TL\n\n<font color=\"red\">结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>路径长度最短的不一定是二叉树。\n\n权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<font color=\"red\">结点的权</font>\n\n结点的带权路径长度：从<font color=\"red\">根结点</font>到该结点之间的<font color=\"red\">路径长度</font>与该结点的<font color=\"red\">权</font>的<font color=\"red\">乘积</font>\n\n树的带权路径长度：树中所有<font color=\"red\">叶子</font>结点的<font color=\"red\">带权路径长度</font>。记作：WPL (Weighted Path Length)\n\n\n\n哈夫曼树：<font color=\"red\">最优树</font> 即带权路径长度最短的树\n\n“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。\n\n哈夫曼树：<font color=\"red\">最优二叉树</font> 带权路径长度最短的二叉树\n\n相应的算法称为哈夫曼算法\n\n\n\n特点：\n\n满二叉树不一定是哈夫曼树\n\n哈夫曼树中权越大的叶子离根越近\n\n具有相同带权结点的哈夫曼树不唯一\n\n\n\n#### 哈夫曼树的构造算法\n\n贪心算法：构造哈夫曼树时首先选择权值小的叶子结点\n\n<font color=\"red\">哈夫曼算法</font>\n\n1.根据n个给定的权值{w~1~,w~2~,…,w~n~}构成n棵二叉树的森林F={T~1~,T~2~,…,T~n~},其中T~i~只有一个带权为w~i~的根结点\n\n<font color=\"red\">构造森林全是根</font>\n\n2.在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右字数上根结点的权值之和\n\n<font color=\"red\">选用两小造新树</font>\n\n3.在F中删除这两棵树，同时将新得到的二叉树加入森林中\n\n<font color=\"red\">删除两小添新人</font>\n\n4.重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树\n\n<font color=\"red\">重复2、3剩单根</font>\n\n\n\n哈夫曼树的结点度数为0或2，没有度为1的结点\n\n包含n个叶子结点的哈夫曼树中共有2n-1个结点\n\n（包含n棵树的森林要经过n-1次和并才能形成哈夫曼树，共产生n-1个新结点）\n\n\n\n**总结：**\n\n1.在哈夫曼算法中，初始时有n棵二叉树，要经过<font color=\"red\">n-1</font>次合并最终形成哈夫曼树\n\n2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支节点\n\n可见：哈夫曼树中共有 n+n-1 =  <font color=\"red\">2n-1</font>个结点，且其所有的分支结点的度均不为1\n\n\n\n\n\n#### 哈夫曼树构造算法的实现\n\n采用顺序存储结构————一维结构数组\n\n结点类型定义\n\n```c++\ntypedef struct{\n\tint weight;\n\tint parent,lch,rch;\n}HTNode,*Huffman Tree;\n```\n\n| 哈夫曼树中结点下标i | weight | parent | lch  | rch  |\n| :-----------------: | :----: | :----: | :--: | :--: |\n|          1          |        |        |      |      |\n|          2          |        |        |      |      |\n|          3          |        |        |      |      |\n|          …          |        |        |      |      |\n|        2n-1         |        |        |      |      |\n\n哈夫曼树中共有2n-1个结点，不使用0下标，数组大小为2n\n\n\n\n步骤：\n\n1.初始化<font color=\"red\">HT[1……2n-1]</font> : lch = rch = parent = 0;\n\n2.输入初始<font color=\"red\">n个叶子结点</font>：置HT[1……n]的<font color=\"red\">weight值</font>\n\n```c++\nvoid CreateHuffmanTree(HuffmanTree HT,int n){ //构造哈夫曼树--哈夫曼算法\n\tif(n<=1) return;\n\tm = 2*n - 1;\t//数组共2n-1个元素\n\tHT = new HTNode[m+1];\t//0号单元未用，HT[m]表示根结点\n\tfor(i=1;i<=m;i++){\n\t\tHT[i].lch = 0;HT[i].rch = 0;HT[i].parent = 0;\n\t}\n\tfor(i=1;i<=n,++i) cin>>HT[i].weight;\t//输入前n个元素的weight值\n\t//初始化结束，下面开始建立哈夫曼树\n续\n```\n\n3.<font color=\"red\">进行以下n-1次合并，</font>依次产生n-1个结点HT[i], i=<font color=\"red\">n+1</font>…..2n-1;\n\n \ta.在HT[1…i-1]中选两个<font color=\"red\">未被选过</font>（从parent==0的结点中选）的weight最小的两个结\t\t点<font color=\"red\">HT[s1]</font>和<font color=\"red\">HT[s2]</font>,<font color=\"red\">s1、s2为两个最小结点下标</font>\n\n​\tb.修改HT[s1]和HT[s2]的parent值：HT[s1].parent = i; HT[s2].parent = i;\n\n​\tc.修改新产生的HT[i]：\n\n​\t\tHT[i].weight = HT[s1].weight + HT[s2].weight;\n\n​\t\tHT[i].lch = s1; HT[i].rch = s2;\n\n```c++\n续\nfor(i=n+1;i<=m;i++){\t\t//合并产生n-1个结点--构造Huffman树\n\tSelect(HT,i-1,s1,s2);\t//在HT[k](1<=k<=i-1)中选择两个其双亲域为0\n\t\t\t\t\t\t\t//且权值最小的结点，并返回它们在HT中的序号s1和s2\n\tHT[s1].parent = i; HT[s2].parent = i;\t//表示从F中删除s1,s2\n    HT[i].lch = s1; HT[i].rch = s2;\t\t\t//s1，s2分别作为i的左右孩子\n    HT[i].weight = HT[s1].weight+HT[s2].weight;//i的权值为左右孩子权值之和\n}\n}\n```\n\n\n\n\n\n#### 哈夫曼编码\n\n在远程通讯中，要将待传字符转换成由二进制的字符串\n\n若将编码设计为长度不等的二进制编码，即让待传字符串中<font color=\"red\">出现次数较多的字符采用尽可能短的编码，</font>则转换的二进制字符串便可能减少\n\n<font color=\"red\">关键：</font>要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀\n\n这种编码称作<font color=\"red\">前缀编码</font>\n\n\n\n问题：什么样的前缀码能使电文总长最短  ----<font color=\"red\">哈弗曼编码</font>\n\n1.<font color=\"red\">统计</font>字符集中<font color=\"red\">每个字符</font>在电文中<font color=\"red\">出现的</font>平均<font color=\"red\">概率</font>（概率越大，要求编码越短）。\n\n2.利用哈夫曼树的特点：权越大的叶子离根越近；<font color=\"red\">将每个字符的概率值作为权值，构造哈夫曼树。</font>则概率越大的结点，路径越短。\n\n3.在哈夫曼树的每个分支上标上0或1：\n\n​\t结点的<font color=\"red\">左分支标0，右分支标1</font>\n\n​\t把根到每个叶子的路径上的标号连接起来，作为该叶子代表的<font color=\"red\">字符的编码</font>\n\n\n\n**为什么哈弗曼编码能够保证是前缀编码？**\n\n因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀\n\n\n\n**为什么哈弗曼编码能够保证字符编码总长最短**\n\n因为哈夫曼树的带权路径长度最短，故字符编码的总长最短\n\n\n\n<font color=\"red\">哈夫曼编码的两个性质</font>\n\n1.哈弗曼编码是前缀码\n\n2.哈夫曼编码是最优前缀码\n\n\n\n#### 哈夫曼编码的算法实现\n\n```c++\nvoid CreateHuffmanCode(Huffman Tree HT,HuffmanCode &HC,int n){\n//从叶子到根逆向求每个字符的哈弗曼编码，存储在编码表HC中\n\tHC = new char *[n+1];\t//分配n个字符编码的头指针矢量\n\tcd = new char[n];\t\t//分配临时存放编码的动态数组空间\n\tcd[n-1] = '\\0';\t\t\t//编码结束符 （字符串结束符）\n\t\n\tfor(i=1;i<=n;++i){\n\t\tstart=n-1;c=i;f=Ht[i].parent;\n\t\twhile(f!=0){\t//从叶子结点开始向上回溯，直到根结点\n\t\t\t--start;\t//回溯一次start向前指一个位置\n\t\t\tif(HT[f].lchild == c) cd[start]='0'; //结点c是f的左孩子，0\n\t\t\telse cd[start]='1';\t\t\t\t\t //结点c是f的右孩子，1\n\t\t\tc = f; f = HT[f].parent;\t\t\t //继续向上回溯\n\t\t}\t//求出第i个字符的编码\n\t\tHC[i] = new char[n-start];\t\t//为第i个字符串编码分配空间大小是\n        \t\t\t\t\t\t\t\t// n-start 已占用的空间量\n\t\tstrcpy(HC[i],&cd[start]);\t\t//将求得的编码从临时空间cd复制到HC的当前行中\n\t}\n\tdelete cd;\t//释放临时空间\n}\n```\n\n\n\n\n\n#### 文件的编码和解码\n\n**编码**\n\n1.输入各字符及其权值\n\n2.构造哈夫曼树--HT[i]\n\n3.进行哈夫曼编码--HC[i]\n\n4.查HC[i]，得到各字符的哈弗曼编码\n\n\n\n**解码**\n\n1.构造哈夫曼树\n\n2.依次读入二进制码\n\n3.读入0，则走向左孩子；读入1，则走向右孩子\n\n4.一旦达到某叶子时，即可译出字符\n\n5.然后再从根出发继续译码，直到结束\n\n\n\n\n\n\n\n\n\n## 图\n\n### 图的定义和基本术语\n\n图：G=(V,E)\t\t\t\tGraph = （Vertex , Edge)\n\n​\t\tV：顶点（数据元素）的有穷非空集合；\n\n​\t\tE：边的有穷集合\n\n\n\n无向图：每条边都是无方向的\n\n有向图：每条边都是有方向的\n\n完全图：任意两个点都有一条边相连（无向完全图和有向完全图，其中有向完全图要两个方向都有边）\n\n\n\n无向完全图：<font color=\"red\">n个顶点，n(n-1)/2条边</font>\n\n有向完全图：<font color=\"red\">n个顶点，n(n-1)条边</font>\n\n\n\n稀疏图：有很少边或弧的图（e < nlog~n~）\n\n稠密图：有较多边或弧的图\n\n网：边/弧带权的图\n\n邻接：有边/弧相连的两个顶点之间的关系\n\n​\t\t\t存在（v~i~ , v~j~）, 则称v~i~ 和 v~j~互为邻接点\n\n​\t\t\t存在 <v~i~ , v~j~> , 则称 v~i~ 邻接到 v~j~ ，v~j~ 邻接于 v~i~ \n\n​\t\t\t圆括号表示无向图，尖括号表示有向图，从前面到后面\n\n关联（依附）：边/弧与顶点之间的关系\n\n​\t\t\t\t\t\t\t存在（v~i~ , v~j~） / <v~i~ , v~j~> , 则称该边/弧关联于v~i~ 和v~j~\n\n顶点的度：与该顶点相关联的边的数目，记为TD(v)\n\n​\t\t\t\t\t在<font color=\"red\">有向图</font>中，顶点的度等于该顶点的<font color=\"red\">入度</font>和<font color=\"red\">出度</font>之和\n\n​\t\t\t\t\t顶点<font color=\"red\">v的入度</font>是以v为终点的有向边的条数，记作ID(v)\n\n​\t\t\t\t\t顶点<font color=\"red\">v的出度</font>是以v为始点的有向边的条数，记作OD(v)\n\n","slug":"数据结构","published":1,"updated":"2021-09-26T12:39:23.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku3k7fm2000z80u64p63a3ds","content":"<center>数据结构</center>\n\n<hr>\n<h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a><center>绪论</center></h2><h3 id=\"🎈数据结构的研究内容\"><a href=\"#🎈数据结构的研究内容\" class=\"headerlink\" title=\"🎈数据结构的研究内容\"></a>🎈数据结构的研究内容</h3><p><strong>计算机解决问题的步骤：</strong></p>\n<ul>\n<li>将问题抽象为<font color=\"red\">数学模型</font></li>\n<li>设计算法</li>\n<li>编程、调试、运行</li>\n</ul>\n<p><strong>早期，计算机应用于数值计算：</strong></p>\n<ul>\n<li>分析问题，找出对象以及对象之间的关系</li>\n<li>建立数学方程</li>\n<li>求解</li>\n</ul>\n<p><strong>随着计算机应用领域的扩展，越来越多被用于非数值计算：</strong></p>\n<ul>\n<li>线性表</li>\n<li>树</li>\n<li>图</li>\n</ul>\n<p>以上都是“非数值计算”的程序设计问题</p>\n<blockquote>\n<p>综上所述，数据结构是一门研究<font color=\"red\">非数值计算的</font>程序设计中计算机的<font color=\"red\">操作对象</font>以及他们之间的<font color=\"red\">关系</font>和<font color=\"red\">操作</font>的学科。</p>\n</blockquote>\n<h3 id=\"🎈基本概念和术语\"><a href=\"#🎈基本概念和术语\" class=\"headerlink\" title=\"🎈基本概念和术语\"></a>🎈基本概念和术语</h3><h4 id=\"数据、数据元素、数据项和数据对象\"><a href=\"#数据、数据元素、数据项和数据对象\" class=\"headerlink\" title=\"数据、数据元素、数据项和数据对象\"></a>数据、数据元素、数据项和数据对象</h4><ol>\n<li><p>数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。</p>\n<p>包括：</p>\n</li>\n</ol>\n<ul>\n<li>数值型数据：整数、实数等</li>\n<li>非数值型数据：文字、图像、图形、声音等</li>\n</ul>\n<ol start=\"2\">\n<li>数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。</li>\n<li>数据项：构成数据元素的不可分割的最小单位</li>\n</ol>\n<blockquote>\n<p><font color=\"red\">以上三者之间的关系：</font>数据&gt;数据元素&gt;数据项</p>\n</blockquote>\n<ol start=\"4\">\n<li><p>数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。</p>\n<p>数据元素和数据对象与数据的关系的区别：</p>\n</li>\n</ol>\n<ul>\n<li>数据元素是集合的个体</li>\n<li>数据对象是集合的子集</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>数据元素互相之间的关系称为<font color=\"red\">结构</font></p>\n</li>\n<li><p>是指相互之间存在一种或多种特定关系的数据元素集合</p>\n</li>\n<li><p><font color=\"red\">包含以下三方面内容：</font></p>\n<ol>\n<li>数据元素之间的逻辑关系，也称为<font color=\"red\">逻辑结构</font></li>\n<li>数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color=\"red\">物理结构</font>或数据的<font color=\"red\">存储结构</font></li>\n<li>数据的<font color=\"red\">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现</li>\n</ol>\n</li>\n<li><p>数据结构的两个层次：</p>\n<ol>\n<li><p><font color=\"red\">逻辑结构：</font>是指数据对象中数据元素之间的互相关系</p>\n<p><strong>逻辑结构的种类：</strong></p>\n<p>划分方法一：</p>\n<ol>\n<li><font color=\"red\">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。</li>\n<li><font color=\"red\">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。</li>\n</ol>\n<p>划分方法二：</p>\n<ol>\n<li><font color=\"red\">集合结构：</font>其中的数据元素只有<font color=\"red\">只属于一个集合</font>的关系</li>\n<li><font color=\"red\">线性结构：</font>数据元素存在<font color=\"red\">一对一</font>的线性关系</li>\n<li><font color=\"red\">树形结构：</font>数据元素存在<font color=\"red\">一对多</font>的线性关系</li>\n<li><font color=\"red\">图状/网状结构：</font>数据元素存在<font color=\"red\">多对多</font>的线性关系</li>\n</ol>\n</li>\n<li><p><font color=\"red\">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式</p>\n<p><strong>存储结构的种类：</strong></p>\n<p>​    <font color=\"red\">四种基本的存储结构：</font></p>\n<p>​    1.<font color=\"red\">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示</p>\n<p>​    2.<font color=\"red\">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示</p>\n<p>​    3.<font color=\"red\">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）</p>\n<p>​    4.<font color=\"red\">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址</p>\n<p><strong>逻辑结构和存储结构之间的关系：</strong></p>\n<ul>\n<li>存储结构是逻辑关系的映像与元素本身的映像</li>\n<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>\n<li>两者综合起来建立了数据元素之间的结构关系</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>数据类型(Data Type):是指一组性质相同的<font color=\"red\">值的集合</font>及定义在此集合上的<font color=\"red\">一组操作</font>的总称</p>\n<blockquote>\n<p>数据类型 = 值的集合 + 值集合上的一组操作</p>\n</blockquote>\n<p><strong>在C语言中，按照取值的不同，可以分为两类：</strong></p>\n<ul>\n<li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li>\n<li>结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的</li>\n</ul>\n<h4 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h4><mark class=\"hl-label red\">抽象是指抽取出事物具有的普遍性的本质。</mark> \n\n<p>通过对已有的数据类型进行抽象得到。</p>\n<p>抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。</p>\n<ul>\n<li>由用户定义，从问题中抽象出<font color=\"red\">数据模型</font>（逻辑结构）。</li>\n<li>还包括定义在数据模型上的一组<font color=\"red\">抽象运算</font>（相关操作）。</li>\n</ul>\n<p><strong>抽象数据类型的形式定义：</strong></p>\n<p>抽象数据类型可以用（D，S，P）<font color=\"red\">三元组</font>表示。</p>\n<p>其中：D是数据对象；</p>\n<p>​            S是D上的关系集；</p>\n<p>​            P是对D的基本操作集。</p>\n<p><strong>抽象数据类型的定义格式如下：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t数据对象：&lt;数据对象的定义&gt;\t\t<span class=\"comment\">//其中，数据对象和数据关系用伪代码描述</span></span><br><span class=\"line\">\t数据关系：&lt;数据关系的定义&gt;\t\t<span class=\"comment\">//基本操作的定义格式为：</span></span><br><span class=\"line\">\t基本操作：&lt;基本操作的定义&gt;\t\t<span class=\"comment\">// 基本操作名（参数表）</span></span><br><span class=\"line\">&#125;ADT 抽象数据类型名\t\t\t   <span class=\"comment\">// 初始条件：&lt;初始条件描述&gt;</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">// 操作结果：&lt;操作结果描述&gt;                     </span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>基本操作</strong>定义格式说明：</p>\n<p>参数表：赋值参数 只为操作提供输入值</p>\n<p>​                引用参数 以&amp;打头，除可提供输入值外，还将返回操作结果</p>\n<p>初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。</p>\n<p>操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名&#123;</span><br><span class=\"line\">Data</span><br><span class=\"line\">\t数据对象的定义</span><br><span class=\"line\">\t数据元素之间逻辑关系的定义</span><br><span class=\"line\">Operation</span><br><span class=\"line\">\t操作1</span><br><span class=\"line\">\t\t初始条件</span><br><span class=\"line\">\t\t操作结果描述</span><br><span class=\"line\">\t操作2</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t操作n</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a><center>算法</center></h2><p><strong>数据额结构和算法的关系是相互依赖不可分割的。</strong></p>\n<h3 id=\"🎈算法定义\"><a href=\"#🎈算法定义\" class=\"headerlink\" title=\"🎈算法定义\"></a>🎈算法定义</h3><p>算法是解决特定问题<strong>求解方法和步骤</strong>的描述，在计算机中表现为<font color=\"red\">指令</font>的有限<font color=\"red\">序列</font>，并且每条指令表示一个或多个操作。</p>\n<p><strong>算法的描述：</strong></p>\n<ul>\n<li>自然语言：中文、英语</li>\n<li>流程图</li>\n<li>伪代码</li>\n<li>程序代码</li>\n</ul>\n<p><strong>算法与程序：</strong></p>\n<p><strong>算法</strong>是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法</p>\n<p><strong>程序</strong>是用某种程序设计语言对算法的具体实现</p>\n<blockquote>\n<p>程序 = 数据结构 + 算法</p>\n</blockquote>\n<h3 id=\"🎈算法的特性\"><a href=\"#🎈算法的特性\" class=\"headerlink\" title=\"🎈算法的特性\"></a>🎈算法的特性</h3><h4 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h4><ul>\n<li>算法具有零个或多个输入</li>\n<li>算法至少有一个或多个输出</li>\n</ul>\n<h4 id=\"有穷性\"><a href=\"#有穷性\" class=\"headerlink\" title=\"有穷性\"></a>有穷性</h4><p>算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。</p>\n<h4 id=\"确定性\"><a href=\"#确定性\" class=\"headerlink\" title=\"确定性\"></a>确定性</h4><p>算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</p>\n<h4 id=\"可行性\"><a href=\"#可行性\" class=\"headerlink\" title=\"可行性\"></a>可行性</h4><p>算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</p>\n<h3 id=\"🎈算法设计的要求\"><a href=\"#🎈算法设计的要求\" class=\"headerlink\" title=\"🎈算法设计的要求\"></a>🎈算法设计的要求</h3><h4 id=\"正确性\"><a href=\"#正确性\" class=\"headerlink\" title=\"正确性\"></a>正确性</h4><p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</p>\n<p>可以分为四个层次：</p>\n<ol>\n<li>算法程序<font color=\"red\">不含语法错误</font></li>\n<li>算法程序对于<font color=\"red\">几组输入数据</font>能够产生满足要求的输出结果。</li>\n<li>算法程序对于<font color=\"red\">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。</li>\n<li>算法程序对于<font color=\"red\">一切合法的输入数据</font>都有满足要求的输出结果。</li>\n</ol>\n<p>一般情况下，把<font color=\"red\">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。</p>\n<h4 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h4><p>算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试</p>\n<h4 id=\"健壮性\"><a href=\"#健壮性\" class=\"headerlink\" title=\"健壮性\"></a>健壮性</h4><ul>\n<li>当<font color=\"red\">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。</li>\n<li>处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。</li>\n</ul>\n<h4 id=\"时间效率高和存储量低\"><a href=\"#时间效率高和存储量低\" class=\"headerlink\" title=\"时间效率高和存储量低\"></a>时间效率高和存储量低</h4><p>设计算法应该尽量满足时间效率高和存储量低的需求。</p>\n<h3 id=\"🎈算法效率的度量方法\"><a href=\"#🎈算法效率的度量方法\" class=\"headerlink\" title=\"🎈算法效率的度量方法\"></a>🎈算法效率的度量方法</h3><p><strong>算法效率从以下两个方面来考虑：</strong></p>\n<p><font color=\"red\">1.时间效率： </font>指的是算法所耗费的时间</p>\n<p><font color=\"red\">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间</p>\n<p><strong>时间效率和空间效率有时候是矛盾的</strong></p>\n<h4 id=\"事后统计方法\"><a href=\"#事后统计方法\" class=\"headerlink\" title=\"事后统计方法\"></a>事后统计方法</h4><p>将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。</p>\n<h4 id=\"事前分析估算方法\"><a href=\"#事前分析估算方法\" class=\"headerlink\" title=\"事前分析估算方法\"></a>事前分析估算方法</h4><p><strong><font color=\"red\">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font></strong></p>\n<p>在计算机程序编制前，依据统计方法对算法进行估算。</p>\n<p>程序在计算机上运行时所消耗的时间取决于下列因素：</p>\n<ol>\n<li>算法采用的策略、方法</li>\n<li>编译产生的代码质量</li>\n<li>问题的输入规模</li>\n<li>机器指令执行的速度</li>\n</ol>\n<blockquote>\n<p>抛开软件和硬件的因素，一个程序的运行时间，依赖于<strong>算法的好坏和问题的输入规模</strong>。问题输入规模是指输入量的多少。</p>\n</blockquote>\n<p><strong>在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</strong></p>\n<h3 id=\"🎈函数的渐近增长\"><a href=\"#🎈函数的渐近增长\" class=\"headerlink\" title=\"🎈函数的渐近增长\"></a>🎈函数的渐近增长</h3><blockquote>\n<p>定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n&gt;N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。</p>\n</blockquote>\n<p>结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>\n<h3 id=\"🎈算法时间复杂度\"><a href=\"#🎈算法时间复杂度\" class=\"headerlink\" title=\"🎈算法时间复杂度\"></a>🎈算法时间复杂度</h3><h4 id=\"算法时间复杂度定义\"><a href=\"#算法时间复杂度定义\" class=\"headerlink\" title=\"算法时间复杂度定义\"></a>算法时间复杂度定义</h4><blockquote>\n<p>在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color=\"red\"><strong>渐进时间复杂度</strong></font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中<strong>基本操作</strong>执行的次数，它是问题规模n的某个函数，用T（n）表示。</p>\n</blockquote>\n<p>这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。</p>\n<p>一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。</p>\n<p><strong>分析算法时间复杂度的基本方法：</strong></p>\n<ol>\n<li>找出<font color=\"red\">语句频度最大</font>的那条语句作为<font color=\"red\">基本语句</font></li>\n<li>计算<font color=\"red\">基本语句</font>的频度得到问题规模n的某个函数f（n）</li>\n<li>取其数量级用符号“O”表示</li>\n</ol>\n<h4 id=\"推导大O阶方法\"><a href=\"#推导大O阶方法\" class=\"headerlink\" title=\"推导大O阶方法\"></a>推导大O阶方法</h4><ol>\n<li>用常数1取代运行时间中的所有加法常数。</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n<li>得到的结果就是大O阶</li>\n</ol>\n<h4 id=\"常数阶\"><a href=\"#常数阶\" class=\"headerlink\" title=\"常数阶\"></a>常数阶</h4><p>如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。</p>\n<mark class=\"hl-label red\">即执行次数恒定，不会随着n的变大而发生变化</mark> \n\n<h4 id=\"线性阶\"><a href=\"#线性阶\" class=\"headerlink\" title=\"线性阶\"></a>线性阶</h4><p>要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况</strong>。</p>\n<p>下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对数阶\"><a href=\"#对数阶\" class=\"headerlink\" title=\"对数阶\"></a>对数阶</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(count &lt; n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcount = count * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。</p>\n<h4 id=\"平方阶\"><a href=\"#平方阶\" class=\"headerlink\" title=\"平方阶\"></a>平方阶</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; n; J++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。</p>\n<p>如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。</p>\n<p>总结得出，<font color=\"red\">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。</p>\n<p>对于下面这个循环嵌套：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = i; j &lt; n; j++) <span class=\"comment\">/* 注意int j = i 而不是0 */</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：</p>\n<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>\n\n<p>用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。</p>\n<h4 id=\"算法的加法法则和乘法法则\"><a href=\"#算法的加法法则和乘法法则\" class=\"headerlink\" title=\"算法的加法法则和乘法法则\"></a>算法的加法法则和乘法法则</h4><ul>\n<li><p>加法法则</p>\n<p>T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )</p>\n</li>\n<li><p>乘法法则</p>\n<p>T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )</p>\n</li>\n</ul>\n<h4 id=\"🎈常用的时间复杂度\"><a href=\"#🎈常用的时间复杂度\" class=\"headerlink\" title=\"🎈常用的时间复杂度\"></a>🎈常用的时间复杂度</h4><table>\n<thead>\n<tr>\n<th align=\"center\">执行次数函数</th>\n<th align=\"center\">阶</th>\n<th align=\"center\">非正式术语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">12</td>\n<td align=\"center\">O（1）</td>\n<td align=\"center\">常数阶</td>\n</tr>\n<tr>\n<td align=\"center\">2n+3</td>\n<td align=\"center\">O（n）</td>\n<td align=\"center\">线性阶</td>\n</tr>\n<tr>\n<td align=\"center\">3n<sup>2</sup>+2n+1</td>\n<td align=\"center\">O（n<sup>2</sup>）</td>\n<td align=\"center\">平方阶</td>\n</tr>\n<tr>\n<td align=\"center\">5log<sub>2</sub>n+20</td>\n<td align=\"center\">O（log<sub>2</sub>n）</td>\n<td align=\"center\">对数阶</td>\n</tr>\n<tr>\n<td align=\"center\">2n+3nlog<sub>2</sub>n+19</td>\n<td align=\"center\">O（nlog<sub>2</sub>n）</td>\n<td align=\"center\">nlog<sub>2</sub>n阶</td>\n</tr>\n<tr>\n<td align=\"center\">6n<sup>3</sup>+2n<sup>2</sup>+3n+4</td>\n<td align=\"center\">O（n<sup>3</sup>）</td>\n<td align=\"center\">立方阶</td>\n</tr>\n<tr>\n<td align=\"center\">2<sup>n</sup></td>\n<td align=\"center\">O（2<sup>n</sup>）</td>\n<td align=\"center\">指数阶</td>\n</tr>\n</tbody></table>\n<p>常用的时间复杂度所耗费的时间从小到大依次是：</p>\n<blockquote>\n<p>O（1）&lt;O（log<sub>2</sub>n）&lt; O（n）&lt;O（nlog<sub>2</sub>n）&lt;O（n<sup>2</sup>）&lt;O（n<sup>3</sup>）&lt;O（2<sup>n</sup>）&lt;O（n！）&lt;O（n<sup>n</sup>）</p>\n</blockquote>\n<h3 id=\"🎈最坏情况与平均情况\"><a href=\"#🎈最坏情况与平均情况\" class=\"headerlink\" title=\"🎈最坏情况与平均情况\"></a>🎈最坏情况与平均情况</h3><ul>\n<li><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</strong></li>\n<li>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）</li>\n</ul>\n<h3 id=\"🎈算法空间复杂度\"><a href=\"#🎈算法空间复杂度\" class=\"headerlink\" title=\"🎈算法空间复杂度\"></a>🎈算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。</p>\n<p><strong>算法要占据的空间：</strong></p>\n<ul>\n<li>算法本身要占据的空间，输入/输出，指令，常数，变量等</li>\n<li>算法要使用<font color=\"red\">辅助空间</font></li>\n</ul>\n<hr>\n<h2 id=\"🍟线性表\"><a href=\"#🍟线性表\" class=\"headerlink\" title=\"🍟线性表\"></a><center>🍟线性表</center></h2><h3 id=\"🎵线性表的定义和特点\"><a href=\"#🎵线性表的定义和特点\" class=\"headerlink\" title=\"🎵线性表的定义和特点\"></a>🎵线性表的定义和特点</h3><p><strong>线性表(Linear List):</strong></p>\n<ul>\n<li>由n个数据元素（结点）组成的<font color=\"red\">有限序列</font></li>\n<li>其中数据元素的个数n定义为表的长度</li>\n<li>当n=0时称为空表</li>\n<li>数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同</li>\n</ul>\n<p><font color=\"red\">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font></p>\n<h4 id=\"线性表的逻辑特征\"><a href=\"#线性表的逻辑特征\" class=\"headerlink\" title=\"线性表的逻辑特征\"></a><strong>线性表的逻辑特征</strong></h4><ol>\n<li>非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继</li>\n<li>有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱</li>\n<li>其余的内部结点有且只有一个直接前驱和一个直接后继</li>\n</ol>\n<p><font color=\"red\">线性表是一种典型的线性结构</font></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></li>\n<li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</li>\n<li>从具体应用中抽象处共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></li>\n</ul>\n<h4 id=\"顺序表的类型定义\"><a href=\"#顺序表的类型定义\" class=\"headerlink\" title=\"顺序表的类型定义\"></a><strong>顺序表的类型定义</strong></h4><ul>\n<li>抽象数据类型线性表的定义如下：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT List&#123;</span><br><span class=\"line\">\t数据对象：D = &#123;ai|ai∈Elemset,(i=<span class=\"number\">1</span>,<span class=\"number\">2</span>,...,n,n&gt;=<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">\t数据关系：R = &#123;&lt;ai<span class=\"number\">-1</span>,ai&gt;|ai<span class=\"number\">-1</span>,ai∈D,(i=<span class=\"number\">2</span>,<span class=\"number\">3</span>,...n)&#125;    <span class=\"comment\">//这里的ai中的i都是下标</span></span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t<span class=\"built_in\">InitList</span>(&amp;L);</span><br><span class=\"line\">\t<span class=\"built_in\">ListInsert</span>(&amp;L,i,e);</span><br><span class=\"line\">\t<span class=\"built_in\">DestroyList</span>(&amp;L);</span><br><span class=\"line\">\t<span class=\"built_in\">ListDelete</span>(&amp;L,i,&amp;e);</span><br><span class=\"line\">\t......等等</span><br><span class=\"line\">&#125;ADT List</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵基本操作\"><a href=\"#🎵基本操作\" class=\"headerlink\" title=\"🎵基本操作\"></a>🎵基本操作</h3><ul>\n<li><p>InitList(&amp;L)   (Initiallization List)</p>\n<ul>\n<li>操作结果：构造一个空的线性表L</li>\n</ul>\n</li>\n<li><p>DestroyList(&amp;L)</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：销毁线性表L</p>\n</li>\n</ul>\n</li>\n<li><p>ClearList(&amp;L)</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：将线性表L重置为空表</p>\n</li>\n</ul>\n</li>\n<li><p>ListEmpty(L);</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE</p>\n</li>\n</ul>\n</li>\n<li><p>ListLength(L</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：返回线性表L中的数据元素的个数</p>\n</li>\n</ul>\n</li>\n<li><p>GetElem(L,i,&amp;e)</p>\n<ul>\n<li>初始条件：线性表L已经存在，1 &lt;= i &lt;= ListLength(L)</li>\n<li>操作结果：用e返回线性表L中第i个数据元素的值</li>\n</ul>\n</li>\n<li><p>LocateElem(L,e,compare())</p>\n<ul>\n<li>初始条件：线性表L已经存在，compare()是数据元素判定函数</li>\n<li>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li>\n</ul>\n</li>\n<li><p>PriorElem(L,cur_e,&amp;pre_e)</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义</li>\n</ul>\n</li>\n<li><p>NextElem(L,cur_e,&amp;next_e)</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义</li>\n</ul>\n</li>\n<li><p>ListInsert(&amp;L,i,e)</p>\n<ul>\n<li>初始条件：线性表L已经存在， 1 &lt;= i&lt;= ListLength(L) + 1</li>\n<li>操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1</li>\n</ul>\n</li>\n<li><p>ListDelete(&amp;L,i,&amp;e)</p>\n<ul>\n<li>初始条件：线性表L已经存在， 1 &lt;= i&lt;= ListLength(L) </li>\n<li>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一</li>\n</ul>\n</li>\n<li><p>ListTraverse(&amp;L,visited())</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：依次对线性表中每个元素调用visited()</li>\n</ul>\n</li>\n</ul>\n<p><strong>以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。</strong></p>\n<h3 id=\"🎵线性表的顺序存储表示\"><a href=\"#🎵线性表的顺序存储表示\" class=\"headerlink\" title=\"🎵线性表的顺序存储表示\"></a>🎵线性表的顺序存储表示</h3><p>顺序表的顺序表示又称为<font color=\"red\">顺序存储结构</font>或<font color=\"red\">顺序映像</font></p>\n<h4 id=\"顺序存储定义\"><a href=\"#顺序存储定义\" class=\"headerlink\" title=\"顺序存储定义\"></a><font color=\"red\"><strong>顺序存储定义</strong></font></h4><p>把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构</p>\n<ul>\n<li><p>依次存储，地址连续——中间<font color=\"red\">没有空出存储单元</font></p>\n</li>\n<li><p>线性表顺序存储结构<font color=\"red\">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置</p>\n</li>\n</ul>\n<h4 id=\"顺序表中元素存储位置的计算\"><a href=\"#顺序表中元素存储位置的计算\" class=\"headerlink\" title=\"顺序表中元素存储位置的计算\"></a><strong>顺序表中元素存储位置的计算</strong></h4><ul>\n<li><p>假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color=\"red\">LOC(a<del>i+1</del>) = LOC(a<del>i</del>) + K</font></p>\n</li>\n<li><p>所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color=\"red\">LOC(a<del>i</del>) = LOC(a<del>1</del>) + (i-1) * K </font>。其中<font color=\"red\">LOC(a<del>1</del>) </font>称为<font color=\"red\">基地址</font>。</p>\n</li>\n</ul>\n<h4 id=\"顺序表的特点\"><a href=\"#顺序表的特点\" class=\"headerlink\" title=\"顺序表的特点\"></a><strong>顺序表的特点</strong></h4><p><font color=\"red\">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）</p>\n<p>顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color=\"red\">用一维数组表示顺序表</font></p>\n<p>但线性表长度可变（删除），数组长度不可动态定义</p>\n<p>一维数组定义方式：<code>类型说明符 数组名[常量表达式]</code></p>\n<p>说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color=\"red\">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。</p>\n<h4 id=\"定义顺序表类型\"><a href=\"#定义顺序表类型\" class=\"headerlink\" title=\"定义顺序表类型\"></a><strong>定义顺序表类型</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define MAXSIZE 100</span><br><span class=\"line\">typedef struct&#123;</span><br><span class=\"line\">\tElemType *elem;</span><br><span class=\"line\">\tint length;</span><br><span class=\"line\">&#125;SqList;  //定义数据表类型</span><br><span class=\"line\"></span><br><span class=\"line\">SqList L; //定义变量L</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵顺序表基本操作的实现\"><a href=\"#🎵顺序表基本操作的实现\" class=\"headerlink\" title=\"🎵顺序表基本操作的实现\"></a><strong>🎵顺序表基本操作的实现</strong></h3><h4 id=\"操作算法中用到的预定义常量和类型\"><a href=\"#操作算法中用到的预定义常量和类型\" class=\"headerlink\" title=\"操作算法中用到的预定义常量和类型\"></a>操作算法中用到的预定义常量和类型</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数结果状态代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFEASIBLE -1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OVERFLOW -2</span></span><br><span class=\"line\"><span class=\"comment\">//Status 是函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"线性表L的初始化\"><a href=\"#线性表L的初始化\" class=\"headerlink\" title=\"线性表L的初始化\"></a>线性表L的初始化</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL.elem = <span class=\"keyword\">new</span> ElemType[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!L.elem)<span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tL.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁线性表\"><a href=\"#销毁线性表\" class=\"headerlink\" title=\"销毁线性表\"></a>销毁线性表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestoryList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.elem) <span class=\"keyword\">delete</span> L.elem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空线性表\"><a href=\"#清空线性表\" class=\"headerlink\" title=\"清空线性表\"></a>清空线性表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ClearList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"求线性表长度\"><a href=\"#求线性表长度\" class=\"headerlink\" title=\"求线性表长度\"></a>求线性表长度</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLength</span><span class=\"params\">(SqList L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(L.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"判断线性表L是否为空\"><a href=\"#判断线性表L是否为空\" class=\"headerlink\" title=\"判断线性表L是否为空\"></a>判断线性表L是否为空</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(SqList L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表取值\"><a href=\"#顺序表取值\" class=\"headerlink\" title=\"顺序表取值\"></a>顺序表取值</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetElem</span><span class=\"params\">(SqList L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>||i&gt;L.length) <span class=\"keyword\">return</span> ERROR;  <span class=\"comment\">//判断i的值是否合理</span></span><br><span class=\"line\">\te = L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表的查找\"><a href=\"#顺序表的查找\" class=\"headerlink\" title=\"顺序表的查找\"></a>顺序表的查找</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem</span><span class=\"params\">(SqList L,ElemType e)</span></span>&#123;     <span class=\"comment\">//查找值为e的元素，返回其序号</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;L.length;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L.elem[i] == e) <span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>顺序表的查找算法分析</strong></p>\n<p>平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。</p>\n<ul>\n<li>用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加</li>\n</ul>\n<p>(1/n)*[(n+1)(n) / 2]</p>\n<p>顺序表查找的时间复杂度为O（n）</p>\n<h4 id=\"顺序表的删除\"><a href=\"#顺序表的删除\" class=\"headerlink\" title=\"顺序表的删除\"></a>顺序表的删除</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L,<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((i&lt;<span class=\"number\">1</span>)||(i&gt;L.length)) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=i;j&lt;=L.length;j++)&#123;</span><br><span class=\"line\">\t\tL.elem[j<span class=\"number\">-1</span>]=L.elem[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL.length--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表的删除算法分析\"><a href=\"#顺序表的删除算法分析\" class=\"headerlink\" title=\"顺序表的删除算法分析\"></a><strong>顺序表的删除算法分析</strong></h4><p>(1/n)*[(n-1)n / 2]</p>\n<p>顺序表删除的时间复杂度O（n）</p>\n<h3 id=\"🎵线性表的链式存储表示\"><a href=\"#🎵线性表的链式存储表示\" class=\"headerlink\" title=\"🎵线性表的链式存储表示\"></a>🎵线性表的链式存储表示</h3><ul>\n<li>用一组<font color=\"red\">物理位置任意的存储单元</font>来存放线性表的数据元素</li>\n<li>这组存储单元既可以是<font color=\"red\">连续</font>的，也可以是<font color=\"red\">不连续</font>的，甚至是零散分布在内存中的任意位置上的</li>\n<li>链表中元素的<font color=\"red\">逻辑次序和物理次序不一定相同</font></li>\n</ul>\n<h4 id=\"与链式存储有关的术语\"><a href=\"#与链式存储有关的术语\" class=\"headerlink\" title=\"与链式存储有关的术语\"></a><strong>与链式存储有关的术语</strong></h4><ol>\n<li><font color=\"red\">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成</li>\n<li><font color=\"red\">链表：</font>n个结点由<font color=\"red\">指针链</font>组成一个链表</li>\n<li><font color=\"red\">单链表、双链表、循环链表：</font><ul>\n<li>结点只有一个指针域的链表，称为单链表或线性链表</li>\n<li>结点有两个指针域的链表，称为双链表</li>\n<li>首尾相接的链表称为循环链表</li>\n</ul>\n</li>\n<li><font color=\"red\">头指针、头结点、首元结点</font></li>\n</ol>\n<h4 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a><font color=\"red\"><strong>讨论</strong></font></h4><p><strong>如何表示空表？</strong></p>\n<ul>\n<li>无头结点时，<font color=\"red\">头指针为空</font>表示空表</li>\n<li>有头结点时，<font color=\"red\">当头结点的指针域为空时</font>表示空表</li>\n</ul>\n<p><strong>在链表中设置<font color=\"red\">头结点</font>有什么好处？</strong></p>\n<ul>\n<li>便于<font color=\"red\">首元结点</font>的处理</li>\n<li>便于<font color=\"red\">空表与非空表</font>的统一处理</li>\n</ul>\n<p><strong>头结点的<font color=\"red\">数据域</font>中装的是什么？</strong></p>\n<p>头结点的<font color=\"red\">数据域</font>可以为空，也可以存放线性<font color=\"red\">表长度</font>等附加信息，但此结点不能计入链表长度</p>\n<h4 id=\"链表（链式存储结构）的特点\"><a href=\"#链表（链式存储结构）的特点\" class=\"headerlink\" title=\"链表（链式存储结构）的特点\"></a><font color=\"red\">链表（链式存储结构）的特点</font></h4><ol>\n<li>结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻</li>\n<li>访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等</li>\n</ol>\n<p>这种数据元素的存储方法称为<font color=\"red\">顺序存取法</font></p>\n<h4 id=\"单链表的定义和表示\"><a href=\"#单链表的定义和表示\" class=\"headerlink\" title=\"单链表的定义和表示\"></a>单链表的定义和表示</h4><p>单链表是<font color=\"red\">由表头</font>唯一确定，因此单链表可以用<font color=\"red\">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color=\"red\">表L</font>。</p>\n<p><strong>单链表的存储结构：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Lnode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Lnode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Lnode,*LinkList;</span><br></pre></td></tr></table></figure>\n\n<p>虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color=\"red\">LinkList L 创建链表</font>，用<font color=\"red\">Lnode *p 来创建指向结点的指针</font>。</p>\n<h3 id=\"🎵单链表基本操作的实现\"><a href=\"#🎵单链表基本操作的实现\" class=\"headerlink\" title=\"🎵单链表基本操作的实现\"></a>🎵单链表基本操作的实现</h3><h4 id=\"单链表的初始化\"><a href=\"#单链表的初始化\" class=\"headerlink\" title=\"单链表的初始化\"></a>单链表的初始化</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_L</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL = <span class=\"keyword\">new</span> LNode;   <span class=\"comment\">//从内存中申请一个存放LNode类型的空间，L指向它</span></span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"判断链表是否为空\"><a href=\"#判断链表是否为空\" class=\"headerlink\" title=\"判断链表是否为空\"></a>判断链表是否为空</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListEmpty</span><span class=\"params\">(LinkList L)</span></span>&#123;\t<span class=\"comment\">//若表为空，返回1；不为空，返回0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L-&gt;next)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//非空</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的销毁\"><a href=\"#单链表的销毁\" class=\"headerlink\" title=\"单链表的销毁\"></a>单链表的销毁</h4><p>从头指针开始，依次释放所有结点</p>\n<p>用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestoryList_L</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tLNode *P;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(L)&#123;</span><br><span class=\"line\">\t\tp = L;</span><br><span class=\"line\">\t\tL = L-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空单链表\"><a href=\"#清空单链表\" class=\"headerlink\" title=\"清空单链表\"></a>清空单链表</h4><p>链表仍存在，但链表中没有元素，只有头指针和头结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p, *q;</span><br><span class=\"line\">\tp = L-&gt;next;\t<span class=\"comment\">//p指向首元结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">\t\tq = p-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//头结点的指针域指向空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"求单链表表长\"><a href=\"#求单链表表长\" class=\"headerlink\" title=\"求单链表表长\"></a>求单链表表长</h4><ul>\n<li>头结点不计入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength_L</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tp = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表取值\"><a href=\"#单链表取值\" class=\"headerlink\" title=\"单链表取值\"></a>单链表取值</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem_L</span><span class=\"params\">(LinkList L;<span class=\"keyword\">int</span> i;ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//这里j&gt;i是指i为0或者负数的情况 !p有两种情况</span></span><br><span class=\"line\">\te = p-&gt;data;\t\t\t\t<span class=\"comment\">//1.链表为空  2.i的值大于链表长度p指向空了\t\t</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的按值查找\"><a href=\"#单链表的按值查找\" class=\"headerlink\" title=\"单链表的按值查找\"></a>单链表的按值查找</h4><p>返回指针（地址）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Lnode *<span class=\"title\">LocateElem_L</span><span class=\"params\">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回<font color=\"red\">位置序号</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem_L</span><span class=\"params\">(LinkList L,Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p) <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的插入\"><a href=\"#单链表的插入\" class=\"headerlink\" title=\"单链表的插入\"></a>单链表的插入</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_L</span><span class=\"params\">(LinkList &amp;L,ElemType e,<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ts = <span class=\"keyword\">new</span> Lnode;s-&gt;data = e;\t<span class=\"comment\">//这里一定要用new一块内存空间 如果只Lnode一个结点</span></span><br><span class=\"line\">\ts-&gt;next = p-&gt;next;\t\t\t<span class=\"comment\">//只是一个函数中的临时变量</span></span><br><span class=\"line\">\tp-&gt;next = s;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单链表的删除</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_L</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;Lnode *q;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tq = p-&gt;next;</span><br><span class=\"line\">\te = p-&gt;next-&gt;data;</span><br><span class=\"line\">\tp-&gt;next = p-&gt;next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"单链表的查找、插入、删除算法时间效率分析\"><a href=\"#单链表的查找、插入、删除算法时间效率分析\" class=\"headerlink\" title=\"单链表的查找、插入、删除算法时间效率分析\"></a>单链表的查找、插入、删除算法时间效率分析</h4><ol>\n<li>查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color=\"red\">O（n）</font></li>\n<li>插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color=\"red\">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color=\"red\">O（n）</font></li>\n</ol>\n<h4 id=\"建立单链表\"><a href=\"#建立单链表\" class=\"headerlink\" title=\"建立单链表\"></a>建立单链表</h4><ul>\n<li>头插法：元素插在链表的头部(倒位序)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateList_H</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;</span><br><span class=\"line\">\tL = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=n;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\tp = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">\t\tcin&gt;&gt;p-&gt;data;</span><br><span class=\"line\">\t\tp-&gt;next = L-&gt;next;</span><br><span class=\"line\">\t\tL-&gt;next = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>尾插法：元素插在链表的尾部(正位序)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateList_R</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;Lnode *r;\t\t<span class=\"comment\">//需要创建一个指针来指向尾结点</span></span><br><span class=\"line\">    L = <span class=\"keyword\">new</span> Lnode;L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    r = L;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        p = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">        cin&gt;&gt;p-&gt;data;</span><br><span class=\"line\">        p-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        r-&gt;next = p;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵循环链表\"><a href=\"#🎵循环链表\" class=\"headerlink\" title=\"🎵循环链表\"></a>🎵循环链表</h3><p>定义：是一种头尾相接的链表（表中最后一个结点指向<font color=\"red\">头结点</font>）</p>\n<p>优点：可以从表中任意结点出发均可找到表中其他结点</p>\n<p>注意：</p>\n<ol>\n<li>由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p-&gt;next是否为空，而是<font color=\"red\">判断它们是否等于头指针</font></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p != L;</span><br><span class=\"line\">p-&gt;next != NULL;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>表的操作常常是在表的首尾进行</p>\n<p>若用头指针表示单循环链表，寻找a<del>n</del>的时间复杂度为O（n），不方便</p>\n<p>所以经常用尾指针来表示单循环链表,使得寻找a<del>1</del>和a<del>n</del>的时间复杂度都为O（1）</p>\n<p>a<del>1</del>的存储位置：R-&gt;next-&gt;next</p>\n<p>a<del>n</del>的存储位置：R</p>\n</li>\n</ol>\n<p><strong>带尾指针的循环链表的合并</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">Connect</span><span class=\"params\">(LinkList Ta,LinkList Tb)</span></span>&#123;</span><br><span class=\"line\">\tp = Ta-&gt;next;\t\t\t\t<span class=\"comment\">//存储表头结点</span></span><br><span class=\"line\">\tTa-&gt;next = Tb-&gt;next-&gt;next;\t<span class=\"comment\">//Tb表头连接Ta表尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> Tb-&gt;next;\t\t\t<span class=\"comment\">//释放Tb表头结点</span></span><br><span class=\"line\">\tTb-&gt;next = p;\t\t\t\t<span class=\"comment\">//修改指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Tb;\t\t\t\t\t<span class=\"comment\">//因为return了新的表尾  所以形参不用引用符号</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵双向链表\"><a href=\"#🎵双向链表\" class=\"headerlink\" title=\"🎵双向链表\"></a>🎵双向链表</h3><p>定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表</p>\n<p>双向链表的结构可定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct DuLnode&#123;</span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\tstruct DuLnode *prior,*next;</span><br><span class=\"line\">&#125;DuLnode,*DuLinkList;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双向链表的插入\"><a href=\"#双向链表的插入\" class=\"headerlink\" title=\"双向链表的插入\"></a>双向链表的插入</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListInsert_DuL</span><span class=\"params\">(DuLinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(p = <span class=\"built_in\">GetElemP_DuL</span>(L,i))) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//用p指向第i个结点</span></span><br><span class=\"line\">\tDuLnode *s;</span><br><span class=\"line\">\ts = <span class=\"keyword\">new</span> DuLnode;</span><br><span class=\"line\">\ts-&gt;data = e;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ts-&gt;prior = p-&gt;prior;</span><br><span class=\"line\">\tp-&gt;prior-&gt;next = s;</span><br><span class=\"line\">\ts-&gt;next = p;</span><br><span class=\"line\">\tp-&gt;prior = s;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双向链表的删除\"><a href=\"#双向链表的删除\" class=\"headerlink\" title=\"双向链表的删除\"></a>双向链表的删除</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListDelete_DuL</span><span class=\"params\">(DuLinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(p = <span class=\"built_in\">GetElemP_DuL</span>(L,i))) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//寻找第i个元素的时间复杂度O(n)</span></span><br><span class=\"line\">\te = p-&gt;data;</span><br><span class=\"line\">\tp-&gt;prior-&gt;next = p-&gt;next;\t<span class=\"comment\">//删除元素所需要的时间复杂度为 O(1)</span></span><br><span class=\"line\">\tp-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🎵单链表、循环链表和双向链表的时间效率比较\"><a href=\"#🎵单链表、循环链表和双向链表的时间效率比较\" class=\"headerlink\" title=\"🎵单链表、循环链表和双向链表的时间效率比较\"></a>🎵单链表、循环链表和双向链表的时间效率比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>查找首元结点</th>\n<th>查表表尾结点</th>\n<th>查找结点*p的前驱结点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>带头结点的单链表L</td>\n<td>L-&gt;next 时间复杂度O(1)</td>\n<td>从L-&gt;next依次向后遍历 时间复杂度O(n)</td>\n<td>通过p-&gt;next无法找到前驱</td>\n</tr>\n<tr>\n<td>带头结点且仅设头指针L的循环单链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>从L-&gt;next依次向后遍历 时间复杂度O(n)</td>\n<td>通过p-&gt;next可以找到前驱 时间复杂度O(n)</td>\n</tr>\n<tr>\n<td>带头结点且仅设尾指针R的循环单链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>R 时间复杂度O(1)</td>\n<td>通过p-&gt;next可以找到前驱 时间复杂度O(n)</td>\n</tr>\n<tr>\n<td>带头结点的双向循环链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>R 时间复杂度O(1)</td>\n<td>p-&gt;prior 时间复杂度O(1)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>带头结点的双向循环链表，本质上还是用空间换取时间效率</li>\n</ul>\n<h3 id=\"🎵线性表的应用\"><a href=\"#🎵线性表的应用\" class=\"headerlink\" title=\"🎵线性表的应用\"></a>🎵线性表的应用</h3><h4 id=\"线性表的合并\"><a href=\"#线性表的合并\" class=\"headerlink\" title=\"线性表的合并\"></a>线性表的合并</h4><p>思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(SqList &amp;La,SqList Lb)</span></span>&#123;</span><br><span class=\"line\">\tLa_len = <span class=\"built_in\">ListLength</span>(La);</span><br><span class=\"line\">\tLb_len = <span class=\"built_in\">ListLength</span>(Lb);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">GetElem</span>(Lb,i,e);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">LocateElem</span>(La,e)) <span class=\"built_in\">ListInsert</span>(&amp;La,++La_len,e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )</li>\n</ul>\n<h4 id=\"有序表的合并\"><a href=\"#有序表的合并\" class=\"headerlink\" title=\"有序表的合并\"></a>有序表的合并</h4><ul>\n<li>顺序表的实现</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_Sq</span><span class=\"params\">(SqList La,SqList Lb,SqList &amp;Lc)</span></span>&#123;</span><br><span class=\"line\">\tElemType *pa,*pb,*pc;</span><br><span class=\"line\">\tElemType *La_last,*Lb_last;\t\t\t\t<span class=\"comment\">//指针类型要和元素类型对应</span></span><br><span class=\"line\">\tpa = La.elem;\t\t\t\t\t\t\t<span class=\"comment\">//分别指向两个顺序表第一个元素的指针</span></span><br><span class=\"line\">\tpb = Lb.elem;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLc.length = La.length + Lb.length;</span><br><span class=\"line\">\tLc.elem = <span class=\"keyword\">new</span> ElemType[Lc.length];\t\t<span class=\"comment\">//为新表分配一个数组空间</span></span><br><span class=\"line\">\tpc = Lc.elem;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpa_last = La.elem + La.length - <span class=\"number\">1</span>;\t\t<span class=\"comment\">//分别指向表中的最后一个元素</span></span><br><span class=\"line\">\tpb_last = Lb.elem + Lb.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;\t<span class=\"comment\">//两个表都非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> *pc++ = *pb++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &lt;= pa_last) *pc++ = *pa++;\t\t<span class=\"comment\">//将剩余元素填入表c</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和</p>\n<p>算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) </p>\n<ul>\n<li>链表实现</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_L</span><span class=\"params\">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class=\"line\">\tLnode *pa,*pb,*pc;</span><br><span class=\"line\">\tpa = La-&gt;next;\tpb = Lb-&gt;next;\t\t<span class=\"comment\">//分别指向La和Lb的首元结点</span></span><br><span class=\"line\">\tpc = Lc = La;\t<span class=\"comment\">//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>(pc-&gt;next = pb; pc = pb; pb = pb-&gt;next;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//当La和Lb有一个表填完</span></span><br><span class=\"line\">\tpc-&gt;next = pa ? pa:pb;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//释放Lb的头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> Lb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的</p>\n<p>算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到</p>\n<h3 id=\"🎵补充\"><a href=\"#🎵补充\" class=\"headerlink\" title=\"🎵补充\"></a><strong>🎵补充</strong></h3><h4 id=\"数组定义\"><a href=\"#数组定义\" class=\"headerlink\" title=\"数组定义\"></a><strong>数组定义</strong></h4><p>数组静态分布</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[maxsize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n<p>数组动态分布</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType *data;\t<span class=\"comment\">//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;\t\t<span class=\"comment\">//来存放数组的首地址</span></span><br><span class=\"line\">&#125;SqList;</span><br><span class=\"line\"></span><br><span class=\"line\">SqList L;</span><br><span class=\"line\">L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(ElemType)*maxsize);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"C语言动态存储分配\"><a href=\"#C语言动态存储分配\" class=\"headerlink\" title=\"C语言动态存储分配\"></a><strong>C语言动态存储分配</strong></h4><p>对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。</p>\n<p><font color=\"red\">需要加载头文件：&lt;stdlib.h&gt;</font>(C语言)</p>\n<h4 id=\"C-的动态存储分配\"><a href=\"#C-的动态存储分配\" class=\"headerlink\" title=\"C++的动态存储分配\"></a><strong>C++的动态存储分配</strong></h4><p><code>new 类型名T(初值列表)</code></p>\n<p>功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值</p>\n<p>成功：T类型的指针，指向新分配的内存</p>\n<p>失败：0（NULL）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;\t\t<span class=\"comment\">//不赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//赋初值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>delete 指针p</code></p>\n<p>功能：释放指针P所指向的内存。P必须是new操作的返回值。</p>\n<h4 id=\"C-中的参数传递\"><a href=\"#C-中的参数传递\" class=\"headerlink\" title=\"C++中的参数传递\"></a><strong>C++中的参数传递</strong></h4><ul>\n<li>函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序</li>\n<li>参数传递有两种方式<ul>\n<li>传值方式（参数为整型、实型、字符型等）</li>\n<li>传地址<ul>\n<li>参数为指针变量</li>\n<li>参数为引用类型</li>\n<li>参数为数组名</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-中-引用类型做参数\"><a href=\"#C-中-引用类型做参数\" class=\"headerlink\" title=\"C++中 引用类型做参数\"></a><strong>C++中 引用类型做参数</strong></h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;j = i;\t\t<span class=\"comment\">//引用类型,j作为i的一个替代名字，会随着i的改变而改变</span></span><br><span class=\"line\">\ti = <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">float</span> &amp;m,<span class=\"keyword\">float</span> &amp;n)</span> <span class=\"comment\">//这里的m和n与主函数中的实参用的是同一块空间</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> temp;</span><br><span class=\"line\">    temp = n;</span><br><span class=\"line\">    n = m;</span><br><span class=\"line\">    m = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用类型做形参的三种说明\"><a href=\"#引用类型做形参的三种说明\" class=\"headerlink\" title=\"引用类型做形参的三种说明\"></a><strong>引用类型做形参的三种说明</strong></h4><ol>\n<li><p>传递引用给函数与传递指针的效果是一样的，<font color=\"red\">形参变化实参也发生变化</font>。</p>\n</li>\n<li><p>引用类型做形参，在内存中并没有产生实参的副本，它<font color=\"red\">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color=\"red\">形参变量的值是实参变量的副本</font>。因此，当<font color=\"red\">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。</p>\n</li>\n<li><p>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。</p>\n</li>\n</ol>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><h3 id=\"栈和队列的定义和特点\"><a href=\"#栈和队列的定义和特点\" class=\"headerlink\" title=\"栈和队列的定义和特点\"></a>栈和队列的定义和特点</h3><ul>\n<li>栈和队列是两种常用的、重要的数据结构</li>\n<li>栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表</li>\n</ul>\n<p>栈</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Insert</span>(s,n+<span class=\"number\">1</span>,x)\t<span class=\"comment\">//插入和删除只能在表尾进行</span></span><br><span class=\"line\"><span class=\"built_in\">Delete</span>(s,n)</span><br></pre></td></tr></table></figure>\n\n<p>队列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Insert</span>(q,n+<span class=\"number\">1</span>,x)\t<span class=\"comment\">//插入在表尾进行</span></span><br><span class=\"line\"><span class=\"built_in\">Delete</span>(q,<span class=\"number\">1</span>)\t\t<span class=\"comment\">//删除在表头进行</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"栈的定义和特点\"><a href=\"#栈的定义和特点\" class=\"headerlink\" title=\"栈的定义和特点\"></a>栈的定义和特点</h3><p>栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表</p>\n<p>又称为<font color=\"red\">后进先出</font>(Last In First Out)的线性表，简称<font color=\"red\">LIFO</font>结构。</p>\n<p><strong>栈的相关概念</strong></p>\n<ul>\n<li><p>表尾（即a<del>n</del>端）称为<font color=\"red\">栈顶</font>Top；表头（即a<del>1</del>端）称为<font color=\"red\">栈底</font>Base</p>\n</li>\n<li><p>插入元素到栈顶（即表尾）的操作，称为<font color=\"red\">入栈</font>        PUSH</p>\n</li>\n<li><p>从栈顶删除一个元素的操作，称为<font color=\"red\">出栈</font>                    POP</p>\n</li>\n<li><p>逻辑结构：与线性表相同，仍为一对一关系</p>\n</li>\n<li><p>存储结构：用顺序栈或链栈均可，但以顺序栈更常见</p>\n</li>\n<li><p>运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则</p>\n</li>\n<li><p>实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同</p>\n</li>\n</ul>\n<p><font color=\"red\">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出</p>\n<h3 id=\"队列的定义和特点\"><a href=\"#队列的定义和特点\" class=\"headerlink\" title=\"队列的定义和特点\"></a>队列的定义和特点</h3><p>队列(queue)是一种<font color=\"red\">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除</p>\n<p><strong>队列的相关概念</strong></p>\n<ul>\n<li>逻辑结构：一对一</li>\n<li>存储结构：顺序队或链队，以循环队列更常见</li>\n<li>运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则</li>\n<li>实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同</li>\n</ul>\n<h3 id=\"栈的表示和实现\"><a href=\"#栈的表示和实现\" class=\"headerlink\" title=\"栈的表示和实现\"></a>栈的表示和实现</h3><h4 id=\"栈的抽象数据类型的类型定义\"><a href=\"#栈的抽象数据类型的类型定义\" class=\"headerlink\" title=\"栈的抽象数据类型的类型定义\"></a>栈的抽象数据类型的类型定义</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Stack&#123;</span><br><span class=\"line\">\t数据对象:</span><br><span class=\"line\">\t\tD = &#123;ai|ai∈ElemSet,i=<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.</span>...n,n&gt;=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">\t数据关系：</span><br><span class=\"line\">\t\tR1 = &#123;&lt;ai<span class=\"number\">-1</span>,ai&gt;|ai<span class=\"number\">-1</span>,ai∈D,i=<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4.</span>..n&#125;</span><br><span class=\"line\">\t\t约定an为栈顶，a1为栈底</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\t初始化、进栈、出栈、取栈顶元素等</span><br><span class=\"line\">&#125;ADT Stack</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"🍨顺序栈的表示和实现\"><a href=\"#🍨顺序栈的表示和实现\" class=\"headerlink\" title=\"🍨顺序栈的表示和实现\"></a>🍨顺序栈的表示和实现</h4><p>存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。</p>\n<ul>\n<li>附设<font color=\"red\">top</font>指针，指示栈顶元素在顺序栈中的位置</li>\n<li>另设<font color=\"red\">base</font>指针，指示栈底元素在顺序栈中的位置</li>\n</ul>\n<p><font color=\"red\">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font></p>\n<ul>\n<li>另外，用<font color=\"red\">stacksize</font>表示栈可用的最大容量</li>\n</ul>\n<p>空栈：base == top 是栈空标志</p>\n<p>栈满：top - base == stacksize</p>\n<p>栈满时的处理方法：</p>\n<ol>\n<li>报错，返回操作系统</li>\n<li>分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈</li>\n</ol>\n<p>使用数组作为顺序栈存储方式的特点：</p>\n<p>简单、方便，但易产生溢出</p>\n<ul>\n<li>上溢(overflow)：栈已经满，又要压入元素</li>\n<li>下溢(underflow)：栈已经空，又要弹出元素</li>\n</ul>\n<p>顺序栈的表示</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tSElemType *top;</span><br><span class=\"line\">\tSElemType *base;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stacksize;</span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的初始化\"><a href=\"#顺序栈的初始化\" class=\"headerlink\" title=\"顺序栈的初始化\"></a>顺序栈的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">\tS.base = <span class=\"keyword\">new</span> SElemType[MAXSIZE];\t<span class=\"comment\">//分配内存空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);\t\t\t<span class=\"comment\">//如果分配失败</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tS.top = S.base;\t\t\t\t\t\t<span class=\"comment\">//栈顶指针等于栈底指针</span></span><br><span class=\"line\">\tS.stacksize = MAXSIZE;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈判断栈是否为空\"><a href=\"#顺序栈判断栈是否为空\" class=\"headerlink\" title=\"顺序栈判断栈是否为空\"></a>顺序栈判断栈是否为空</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">StackEmpty</span><span class=\"params\">(SqStack s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == S.base)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求顺序栈长度\"><a href=\"#求顺序栈长度\" class=\"headerlink\" title=\"求顺序栈长度\"></a>求顺序栈长度</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackLength</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> S.top-S.base;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"清空顺序栈\"><a href=\"#清空顺序栈\" class=\"headerlink\" title=\"清空顺序栈\"></a>清空顺序栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearStack</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.base) S.top == S.base;\t<span class=\"comment\">//如果没有base就不用清空了；不用删除元素，令栈顶指</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;\t\t\t\t\t<span class=\"comment\">//针等于栈底指针就相当于栈为空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"销毁顺序栈\"><a href=\"#销毁顺序栈\" class=\"headerlink\" title=\"销毁顺序栈\"></a>销毁顺序栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestoryStack</span><span class=\"params\">(SqStack &amp;s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.base)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> S.base;</span><br><span class=\"line\">\t\tS.stacksize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tS.top = S.base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的入栈\"><a href=\"#顺序栈的入栈\" class=\"headerlink\" title=\"顺序栈的入栈\"></a>顺序栈的入栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top-S.base == stacksize) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t*S.top++ = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的出栈\"><a href=\"#顺序栈的出栈\" class=\"headerlink\" title=\"顺序栈的出栈\"></a>顺序栈的出栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == S.base)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = *--S.top;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"🍨链栈的表示\"><a href=\"#🍨链栈的表示\" class=\"headerlink\" title=\"🍨链栈的表示\"></a>🍨链栈的表示</h4><ul>\n<li>链栈是<font color=\"red\">运算受限</font>的单链表，只能在<font color=\"red\">链表头部</font>进行操作</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\tSElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode,*LinkStack;</span><br><span class=\"line\">LinkStack S;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>链表的头指针就是栈顶</li>\n<li>不需要头结点</li>\n<li>基本不存在栈满的情况</li>\n<li>空栈相当于头指针指向空</li>\n<li>插入和删除仅在栈顶处执行</li>\n</ul>\n<h5 id=\"链栈的初始化\"><a href=\"#链栈的初始化\" class=\"headerlink\" title=\"链栈的初始化\"></a>链栈的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitStack</span><span class=\"params\">(LinkStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空栈，栈顶指针置为空</span></span><br><span class=\"line\">\tS = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"判断链栈是否为空\"><a href=\"#判断链栈是否为空\" class=\"headerlink\" title=\"判断链栈是否为空\"></a>判断链栈是否为空</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">StackEmpty</span><span class=\"params\">(LinkStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链栈的入栈\"><a href=\"#链栈的入栈\" class=\"headerlink\" title=\"链栈的入栈\"></a>链栈的入栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class=\"line\">\tStackNode *p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> StackNode;</span><br><span class=\"line\">\tp-&gt;data = e;</span><br><span class=\"line\">\tp-&gt;next = S;</span><br><span class=\"line\">\tS = p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链栈的出栈\"><a href=\"#链栈的出栈\" class=\"headerlink\" title=\"链栈的出栈\"></a>链栈的出栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(LinkList &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = S-&gt;data;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tStacknode *p;</span><br><span class=\"line\">\tp = S;</span><br><span class=\"line\">\tS = S-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"取栈顶元素\"><a href=\"#取栈顶元素\" class=\"headerlink\" title=\"取栈顶元素\"></a>取栈顶元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SElemType <span class=\"title\">GetTop</span><span class=\"params\">(LinkStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S != <span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> S-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"栈与递归\"><a href=\"#栈与递归\" class=\"headerlink\" title=\"栈与递归\"></a>栈与递归</h3><h4 id=\"递归的定义\"><a href=\"#递归的定义\" class=\"headerlink\" title=\"递归的定义\"></a>递归的定义</h4><ul>\n<li>若一个对象部分地<font color=\"red\">包含它自己</font>，或者用它<font color=\"red\">给自己定义</font>，则称这个对象是递归的</li>\n<li>若一个过程<font color=\"red\">直接或间接地调用自己</font>，则称这个过程是递归过程</li>\n</ul>\n<h4 id=\"以下这三种情况常常用到递归方法\"><a href=\"#以下这三种情况常常用到递归方法\" class=\"headerlink\" title=\"以下这三种情况常常用到递归方法\"></a>以下这三种情况常常用到递归方法</h4><ol>\n<li>递归定义的数学函数<ul>\n<li>阶乘函数</li>\n<li>斐波那契数列</li>\n</ul>\n</li>\n<li>具有递归特性的数据结构<ul>\n<li>二叉树</li>\n<li>广义表</li>\n</ul>\n</li>\n<li>可递归求解的问题<ul>\n<li>迷宫问题</li>\n<li>汉诺塔问题</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"递归问题：用分治法求解\"><a href=\"#递归问题：用分治法求解\" class=\"headerlink\" title=\"递归问题：用分治法求解\"></a>递归问题：用分治法求解</h4><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p>\n<p>必备的三个条件：</p>\n<ol>\n<li>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的</li>\n<li>可以通过上述转化而使问题简化</li>\n<li>必须有一个明确的递归出口，或称递归边界</li>\n</ol>\n<h4 id=\"分治法求解递归问题算法的一般形式\"><a href=\"#分治法求解递归问题算法的一般形式\" class=\"headerlink\" title=\"分治法求解递归问题算法的一般形式\"></a>分治法求解递归问题算法的一般形式</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">p</span><span class=\"params\">(参数表)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(递归结束条件) 可直接求解步骤;\t<span class=\"comment\">//基本项</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">p</span> (较小的参数);\t<span class=\"comment\">//归纳项</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h4><p>调用前，系统完成：</p>\n<ol>\n<li>将<font color=\"red\">实参，返回地址</font>等传递给被调用函数</li>\n<li>为被调用函数的<font color=\"red\">局部变量</font>分配存储区</li>\n<li>将控制转移到被调用函数的<font color=\"red\">入口</font></li>\n</ol>\n<p>调用后，系统完成：</p>\n<ol>\n<li>保存被调用函数的计算<font color=\"red\">结果</font></li>\n<li>释放被调用函数的<font color=\"red\">数据区</font></li>\n<li>依照被调用函数保存的<font color=\"red\">返回地址</font>将控制转移到调用函数</li>\n</ol>\n<h4 id=\"多个函数嵌套调用\"><a href=\"#多个函数嵌套调用\" class=\"headerlink\" title=\"多个函数嵌套调用\"></a>多个函数嵌套调用</h4><p><font color=\"red\">遵循后调用的先返回</font></p>\n<h4 id=\"递归函数调用的实现\"><a href=\"#递归函数调用的实现\" class=\"headerlink\" title=\"递归函数调用的实现\"></a>递归函数调用的实现</h4><p>“层次”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主函数\t\t 0层</span><br><span class=\"line\">第1次调用\t1层</span><br><span class=\"line\">......\t\t</span><br><span class=\"line\">第i次调用\ti层</span><br></pre></td></tr></table></figure>\n\n<p>“递归工作栈”    ——递归程序运行期间使用的数据存储区</p>\n<p>“工作记录”        实际参数、局部变量、返回地址</p>\n<h4 id=\"递归的优缺点\"><a href=\"#递归的优缺点\" class=\"headerlink\" title=\"递归的优缺点\"></a>递归的优缺点</h4><p>优点：结构清晰，程序易读</p>\n<p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p>\n<p>递归——&gt;非递归</p>\n<p>方法1：尾递归、单向递归 ——&gt;循环结构</p>\n<p>方法2：自用<font color=\"red\">栈</font>模拟系统的运行时候栈</p>\n<h3 id=\"队列的表示和操作的实现\"><a href=\"#队列的表示和操作的实现\" class=\"headerlink\" title=\"队列的表示和操作的实现\"></a>队列的表示和操作的实现</h3><h4 id=\"队列的抽象数据类型定义\"><a href=\"#队列的抽象数据类型定义\" class=\"headerlink\" title=\"队列的抽象数据类型定义\"></a>队列的抽象数据类型定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Queue&#123;</span><br><span class=\"line\">\t数据对象：D = &#123;ai|ai∈Elemset,(i=1,2,...,n,n&gt;=0)&#125;</span><br><span class=\"line\">\t数据关系：R = &#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,(i=2,3,...n)&#125;    //这里的ai中的i都是下标</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\tInitQueue(&amp;Q);</span><br><span class=\"line\">\t\tDestroyQueue(&amp;Q);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">&#125;ADT Queue</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"队列的顺序表示和实现\"><a href=\"#队列的顺序表示和实现\" class=\"headerlink\" title=\"队列的顺序表示和实现\"></a>队列的顺序表示和实现</h4><p>用一维数组base[MAXQSIZE]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXQSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tQElemType *base;\t<span class=\"comment\">//指向数组首地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;\t\t\t<span class=\"comment\">//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;\t\t\t<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>解决假上溢的方法：</strong></p>\n<ol>\n<li><p>将队中元素依次向队头方向移动</p>\n<p>缺点：浪费时间。每移动一次，队中元素都要移动</p>\n</li>\n<li><p>将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间</p>\n</li>\n</ol>\n<p>base[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；</p>\n<p>实现方法：利用<font color=\"red\">模运算（mod,c语言中：%）</font></p>\n<p><strong>区分队空和队满</strong></p>\n<ol>\n<li><p>另外设置一个标志来区分队空、队满</p>\n</li>\n<li><p>另设一个变量，记录元素个数</p>\n</li>\n<li><p><font color=\"red\">少用一个元素空间</font></p>\n<p>用第三种方法时：</p>\n<p>队空：front == rear</p>\n<p>队满：（rear+1）% MAXQSIZE == front            //无论对front下标在哪都适用</p>\n</li>\n</ol>\n<h5 id=\"队列的初始化\"><a href=\"#队列的初始化\" class=\"headerlink\" title=\"队列的初始化\"></a>队列的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQ.base = <span class=\"keyword\">new</span> QElemType[MAXQSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求队列的长度\"><a href=\"#求队列的长度\" class=\"headerlink\" title=\"求队列的长度\"></a>求队列的长度</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"循环队列入队\"><a href=\"#循环队列入队\" class=\"headerlink\" title=\"循环队列入队\"></a>循环队列入队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(&amp;Q,QElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( (Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    Q.base[Q.rear] = e;</span><br><span class=\"line\">\tQ.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"循环队列出队\"><a href=\"#循环队列出队\" class=\"headerlink\" title=\"循环队列出队\"></a>循环队列出队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(&amp;Q,&amp;QElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = Q.base[Q.front];</span><br><span class=\"line\">\tQ.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"取队头元素\"><a href=\"#取队头元素\" class=\"headerlink\" title=\"取队头元素\"></a>取队头元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">QElemType <span class=\"title\">GetHead</span><span class=\"params\">(Q)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front != Q.rear)\t<span class=\"keyword\">return</span> Q.base[front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"队列的链式表示和实现\"><a href=\"#队列的链式表示和实现\" class=\"headerlink\" title=\"队列的链式表示和实现\"></a>队列的链式表示和实现</h4><p>若用户无法估计所用队列的长度，宜采用链队列</p>\n<ul>\n<li>带头结点</li>\n</ul>\n<h5 id=\"链队列的类型定义\"><a href=\"#链队列的类型定义\" class=\"headerlink\" title=\"链队列的类型定义\"></a>链队列的类型定义</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXQSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Qnode</span>&#123;</span></span><br><span class=\"line\">\tQElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Qnode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Qnode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    QueuePtr front;\t\t<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    QueuePtr rear;\t\t<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列初始化\"><a href=\"#链队列初始化\" class=\"headerlink\" title=\"链队列初始化\"></a>链队列初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"keyword\">new</span> Qnode;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!Q.front) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tQ.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列的销毁\"><a href=\"#链队列的销毁\" class=\"headerlink\" title=\"链队列的销毁\"></a>链队列的销毁</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestroyQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(Q.front)&#123;</span><br><span class=\"line\">\t\tp = Q.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> Q.front;</span><br><span class=\"line\">\t\tQ.front = p;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//这里Q.rear 没什么用，可以直接用它来代替p</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列入队\"><a href=\"#链队列入队\" class=\"headerlink\" title=\"链队列入队\"></a>链队列入队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType e)</span></span>&#123;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> Qnode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!p) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tp-&gt;data = e;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tQ.rear-&gt;next = p;</span><br><span class=\"line\">    Q.rear = p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列出队\"><a href=\"#链队列出队\" class=\"headerlink\" title=\"链队列出队\"></a>链队列出队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\tp = Q.front-&gt;next;</span><br><span class=\"line\">\te = p-&gt;data;</span><br><span class=\"line\">\tQ.front-&gt;next = Q.front-&gt;next-&gt;next;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.rear == p) Q.rear = Q.front;\t<span class=\"comment\">//如果恰好删除的是尾结点，那么尾指针也指向</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求链队列队头元素\"><a href=\"#求链队列队头元素\" class=\"headerlink\" title=\"求链队列队头元素\"></a>求链队列队头元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetHead</span><span class=\"params\">(LinkQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = Q.front-&gt;next-&gt;data;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h2><h3 id=\"串的定义\"><a href=\"#串的定义\" class=\"headerlink\" title=\"串的定义\"></a>串的定义</h3><p>串（string）：零个或多个任意字符组成的有限序列</p>\n<p>s = “a<del>1</del>a<del>2</del>···a<del>n</del>” (n&gt;=0)</p>\n<p>串名：s</p>\n<p>串值：a<del>1</del>到a<del>n</del></p>\n<p>串长：n</p>\n<p>空串：n=0    用∅表示</p>\n<p>子串：串中任意个连续字符组成的子序列称为该串的子串</p>\n<p>真子串：不包含自身的所有子串</p>\n<p>主串：包含子串的串</p>\n<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>\n<p>子串位置：子串中第一个字符在主串中的位置</p>\n<p>空格串：由一个或多个空格所构成的串，与空串不同</p>\n<p>串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等</p>\n<p>​                所有的空串都是相等的</p>\n<h3 id=\"串的类型定义\"><a href=\"#串的类型定义\" class=\"headerlink\" title=\"串的类型定义\"></a>串的类型定义</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT String&#123;</span><br><span class=\"line\">\t数据对象：字符</span><br><span class=\"line\">\t数据关系：序偶关系</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\t1.串赋值</span><br><span class=\"line\">\t\t2.串比较</span><br><span class=\"line\">\t\t3.求串长</span><br><span class=\"line\">\t\t4.串连结</span><br><span class=\"line\">\t\t5.求子串</span><br><span class=\"line\">\t\t6.串拷贝</span><br><span class=\"line\">\t\t7.清空串</span><br><span class=\"line\">\t\t8.串判空</span><br><span class=\"line\">\t\t9.子串的位置</span><br><span class=\"line\">\t\t10.串替换</span><br><span class=\"line\">\t\t11.子串插入</span><br><span class=\"line\">\t\t12.子串删除</span><br><span class=\"line\">\t\t13.串销毁</span><br><span class=\"line\">&#125;ADT String</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h3><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）</p>\n<h4 id=\"串的顺序存储结构\"><a href=\"#串的顺序存储结构\" class=\"headerlink\" title=\"串的顺序存储结构\"></a>串的顺序存储结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLEN 255</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch[MAXLEN+<span class=\"number\">1</span>];\t<span class=\"comment\">//0号位置不用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;</span><br><span class=\"line\">&#125;SString</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"串的链式存储结构\"><a href=\"#串的链式存储结构\" class=\"headerlink\" title=\"串的链式存储结构\"></a>串的链式存储结构</h4><p>与单链表类似    优点：操作方便        缺点：存储密度较低</p>\n<p>为了克服缺点，可将多个字符放在一个结点中，称为<font color=\"red\">块</font></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define CHUNKSIZE 80</span><br><span class=\"line\">typedef struct Chunk&#123;</span><br><span class=\"line\">\tchar ch[CHUNKSIZE];</span><br><span class=\"line\">\tstruct Chunk *next;</span><br><span class=\"line\">&#125;Chunk;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct&#123;</span><br><span class=\"line\">\tChunk *head,*tail;\t//串的头指针和尾指针</span><br><span class=\"line\">\tint curlen;\t\t\t//串的当前长度</span><br><span class=\"line\">&#125;LString;\t\t\t\t//字符串的块链结构</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"串的模式匹配算法\"><a href=\"#串的模式匹配算法\" class=\"headerlink\" title=\"串的模式匹配算法\"></a>串的模式匹配算法</h3><p>算法目的：确定主串中所含子串（模式串）第一次出现的位置</p>\n<p>算法应用：搜索引擎、拼写检查、语言翻译、数据压缩</p>\n<p>算法种类：BF算法、KMP算法</p>\n<h4 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h4><p>简单匹配算法，采用穷举法的思路</p>\n<p>算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配</p>\n<h5 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h5><p>Index (S,T,pos)</p>\n<ul>\n<li>将主串的第pos个字符和模式串的第一个字符比较</li>\n<li>若相等，继续逐个比较后续字符</li>\n<li>若不等，从主串的下一字符起，重新与模式串的第一个字符比较</li>\n<li>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功</li>\n<li>否则，匹配失败，返回值为0</li>\n</ul>\n<h5 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index_BF</span><span class=\"params\">(SString S,SString T，<span class=\"keyword\">int</span> pos)</span></span>&#123;\t<span class=\"comment\">//pos是从什么位置开始寻找</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=pos,j=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(S.ch[i] == T.ch[j])\t&#123;++i;++j;&#125;\t<span class=\"comment\">//主串和子串依次匹配下一个字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;j = <span class=\"number\">1</span>; i = i - j + <span class=\"number\">2</span>;&#125;\t\t<span class=\"comment\">//主串、子串回溯开始下一次匹配</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(j&gt;T.length) <span class=\"keyword\">return</span> i-T.length;\t\t<span class=\"comment\">//匹配成功返回第一个字符的下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t\t\t\t\t<span class=\"comment\">//匹配失败</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"算法时间复杂度\"><a href=\"#算法时间复杂度\" class=\"headerlink\" title=\"算法时间复杂度\"></a>算法时间复杂度</h5><p>主串长度为n，子串长度为m</p>\n<p>最好情况：O（m）</p>\n<p>最坏情况：O [ (n-m)*m + m ]    若 m&lt;&lt;n，则算法复杂度为 O (m * n)</p>\n<h4 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h4><p>该算法较BF有较大改进，从而算法效率有了某种程度的提高</p>\n<h5 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h5><p>利用已经<font color=\"red\">部分匹配</font>的结果而加快模式串的滑动速度</p>\n<p>且主串S的指针<font color=\"red\">i不必回溯</font>，可提速到<font color=\"red\">O（m+n）</font></p>\n<h5 id=\"next-j-数组\"><a href=\"#next-j-数组\" class=\"headerlink\" title=\"next[j]数组\"></a>next[j]数组</h5><p>表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置</p>\n<p>​                    max    </p>\n<p>next [j] =     0    当j=1时</p>\n<p>​                    1    其他情况</p>\n<h5 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index_KMP</span><span class=\"params\">(SString S,SString T，<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=pos,j=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(S.ch[i] == T.ch[j])\t&#123;++i;++j;&#125;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> \tj = next[j];\t\t<span class=\"comment\">//i不变，j后退 （与BF算法的区别）</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(j&gt;T.length) <span class=\"keyword\">return</span> i-T.length;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获得next[j]数组的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T,<span class=\"keyword\">int</span> &amp;next[])</span></span>&#123;</span><br><span class=\"line\">\ti = <span class=\"number\">1</span>;next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class=\"line\">\t\t\t++i;++j;</span><br><span class=\"line\">\t\t\tnext[i] = j;  <span class=\"comment\">//如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> j = next[j]; <span class=\"comment\">//如果不相等，变成重新再找前j个字符的最长公共前缀子串，再\t\t\t\t\t\t  //移下一位看是否相等</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解：</p>\n<p>[(7条消息) KMP算法原理描述，告诉你为什么要“j = next<a href=\"https://blog.csdn.net/Leycaner/article/details/108301195\">j]”_Leycaner的博客-CSDN博客_j=next[j]</a></p>\n<h5 id=\"next函数的改进\"><a href=\"#next函数的改进\" class=\"headerlink\" title=\"next函数的改进\"></a>next函数的改进</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_nextval</span><span class=\"params\">(SString T,<span class=\"keyword\">int</span> &amp;nextval[])</span></span>&#123;</span><br><span class=\"line\">\ti = <span class=\"number\">1</span>;nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class=\"line\">\t\t\t++i;++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(T.ch[i]!=T.ch[j]) nextval = j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\"> \t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> j = nextval[j]; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>按一定格式排列起来的具有<font color=\"red\">相同类型</font>的数据元素的集合</p>\n<p><strong>结论：</strong>线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展</p>\n<p><strong>特点：</strong>结构固定</p>\n<p><strong>数组基本操作：</strong>除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p>\n<h3 id=\"数组的抽象数据类型定义\"><a href=\"#数组的抽象数据类型定义\" class=\"headerlink\" title=\"数组的抽象数据类型定义\"></a>数组的抽象数据类型定义</h3><p><font color=\"red\">n维数组</font>的抽象数据类型</p>\n<p>ADT Array{</p>\n<p>​    数据对象： j<del>i</del> = 0,······,b<del>i</del>-1    i = 1,2,······n                n为数组的维数，b<del>i</del>为数组第i维的长度</p>\n<p>​                        D = {a<del>j1j2······jn</del>|a<del>j1j2······jn</del> ∈ElemSet}</p>\n<p>​    数据关系：</p>\n<p>​                        R1 = {&lt;a<del>j1······ji······jn</del>，a<del>j1······ji+1······jn</del>&gt;|0&lt;=j<del>k</del>&lt;=b<del>k</del>-1 , 1&lt;=k&lt;=n, 且k≠i, 0&lt;=j<del>i</del>&lt;=b<del>k</del>-2,</p>\n<p>​                                    &lt;a<del>j1······ji······jn</del>，a<del>j1······ji+1······jn</del>&gt;∈D ,i = 2,······,n}</p>\n<p>}</p>\n<p>基本操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.InitArray(&amp;A,n,bound1,...boundn)\t\t//n是维数，boundn是每一维的上界</span><br><span class=\"line\">2.DestoryArray(&amp;A)</span><br><span class=\"line\">3.Value(A,&amp;e,index1,...indexn)</span><br><span class=\"line\">4.Assign(A,&amp;e,index,...indexn)</span><br><span class=\"line\">&#125;ADT Array</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组的顺序存储\"><a href=\"#数组的顺序存储\" class=\"headerlink\" title=\"数组的顺序存储\"></a>数组的顺序存储</h3><p>数组特点：结构固定</p>\n<p>数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作</p>\n<p><font color=\"red\">所以：</font>一般都是用<font color=\"blue\">顺序存储结构</font>来表示数组</p>\n<p>注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的</p>\n<p><strong>一维数组</strong></p>\n<p>​                    LOC(0) = a                            i = 0</p>\n<p>LOC（i）=  </p>\n<p>​                    LOC(i-1) + L = a + i * L,        i &gt; 0</p>\n<p><strong>二维数组</strong></p>\n<p>两种存储方式：</p>\n<ol>\n<li>以行序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L             n列数  m行数</li>\n<li>以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L </li>\n</ol>\n<p><strong>三维数组</strong></p>\n<p>按 页/行/列 存放，页优先的顺序存储</p>\n<p>a[m1] [m2] [m3] 各维元素个数为m1,m2,m3</p>\n<p>下标为i<del>1</del>,i<del>2</del>,i<del>3</del>的数组元素的存储位置</p>\n<p>LOC ( i<del>1</del>,i<del>2</del>,i<del>3</del> ) = a + i<del>1</del> * m2 * m3 + i<del>2</del> * m3 + i<del>3</del></p>\n<h3 id=\"特殊矩阵的压缩存储\"><a href=\"#特殊矩阵的压缩存储\" class=\"headerlink\" title=\"特殊矩阵的压缩存储\"></a>特殊矩阵的压缩存储</h3><p>矩阵的常规存储：描述为二维数组</p>\n<p>矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1</p>\n<p>不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多</p>\n<p>矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间</p>\n<ol>\n<li><p>什么是压缩存储</p>\n<p>若多个数据元素的<font color=\"red\">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间</p>\n</li>\n<li><p>什么样的矩阵能够压缩</p>\n<p>一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等</p>\n</li>\n<li><p>什么叫稀疏矩阵</p>\n<p>矩阵中非零元素很少（一般少于5%）</p>\n</li>\n</ol>\n<h4 id=\"对称矩阵\"><a href=\"#对称矩阵\" class=\"headerlink\" title=\"对称矩阵\"></a>对称矩阵</h4><p><strong>特点：</strong>对角线上下两边都对称，即a<del>ij</del> = a<del>ji</del>  (1&lt;=i,j&lt;=n)</p>\n<p><strong>存储方法：</strong>只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间</p>\n<p><strong>存储结构：</strong></p>\n<p>可以<font color=\"red\">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中</p>\n<p>一维数组中的元素，它前面有多少个元素它就在第几个位置</p>\n<p>假如求 a<del>ij</del> 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1    （下三角）</p>\n<h4 id=\"三角矩阵\"><a href=\"#三角矩阵\" class=\"headerlink\" title=\"三角矩阵\"></a>三角矩阵</h4><p><strong>特点：</strong>对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c</p>\n<p><strong>存储方法：</strong>重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间</p>\n<p>​                    类似于对称矩阵</p>\n<h4 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h4><p><strong>特点：</strong>所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color=\"red\">对角矩阵</font></p>\n<p><strong>存储方法：</strong>用二维数组存储，每一个对角线上的所有元素存储为一行</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">8</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">-1</td>\n<td align=\"center\"></td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">8</td>\n<td align=\"center\">2</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">4</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">4</td>\n<td align=\"center\">7</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">8</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">5</td>\n<td align=\"center\">9</td>\n<td align=\"center\">6</td>\n<td align=\"center\">2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>其中主对角线存储在行标为0的行中</p>\n<h4 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h4><p>三元组法：三元组（i，j，a<del>ij</del>）唯一确定矩阵的一个非零元</p>\n<p>矩阵由所有三元组和矩阵维数（m，n）唯一确定</p>\n<p><strong>压缩存储原则：</strong>存各非零元的值、行列位置和矩阵的行列数</p>\n<p>1、顺序存储结构：三元组顺序表</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">i（行数）</th>\n<th align=\"center\">j（列数）</th>\n<th align=\"center\">v（元素值）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">6(总行数)</td>\n<td align=\"center\">6（总列数）</td>\n<td align=\"center\">8（非零元素总个数）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">-3</td>\n</tr>\n</tbody></table>\n<p>三元组顺序表又称<font color=\"red\">有序的双下标法</font></p>\n<p>优点：非零元在表中按行序有序存储，因此<font color=\"red\">便于进行依行顺序处理的矩阵运算</font></p>\n<p>缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找</p>\n<p>2.链式存储结构：十字链表</p>\n<p>优点：能够<font color=\"red\">灵活地插入</font>因运算而产生的新的非零元素，<font color=\"red\">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。</p>\n<p>表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）</p>\n<p>right：用于链接同一行中的下一个非零元素</p>\n<p>down：用于链接同一列中的下一个非零元素</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">头结点</th>\n<th align=\"center\">M.chead</th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">M.rhead</td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h2><p>广义表（又称列表List）是n个元素的有限序列，其中每一个a<del>i</del>或者是<font color=\"red\">原子</font>或者是一个<font color=\"red\">广义表</font></p>\n<p>拓宽了的线性表就是广义表。</p>\n<h3 id=\"广义表的定义\"><a href=\"#广义表的定义\" class=\"headerlink\" title=\"广义表的定义\"></a>广义表的定义</h3><ul>\n<li>广义表通常记作：LS = （a<del>1</del>,a<del>2</del>,……,a<del>n</del>）</li>\n</ul>\n<p>​    其中：LS为表名，n为表的长度，每一个a<del>i</del>为表的元素</p>\n<ul>\n<li>习惯上，一般用大写字母表示广义表，小写字母表示原子</li>\n<li>表头：若LS非空，则其第一个元素a<del>1</del>就是表头，记作head（LS） = a<del>1</del> <font color=\"red\">注：</font>表头可以是原子或子表</li>\n<li>表尾：除表头之外<font color=\"red\">其他元素</font>组成的表，记作tail（LS） = （a<del>2</del>,……,a<del>n</del>） <font color=\"red\">注：</font>表尾不是最后一个元素，而是一个子表</li>\n</ul>\n<h3 id=\"广义表的性质\"><a href=\"#广义表的性质\" class=\"headerlink\" title=\"广义表的性质\"></a>广义表的性质</h3><ol>\n<li>广义表中的数据元素有相对 <font color=\"red\">次序</font>；一个直接前驱和一个直接后继</li>\n<li>广义表的<font color=\"red\">长度</font>定义为最外层所包含元素的个数</li>\n<li>广义表的<font color=\"red\">深度</font>定义为该广义表 <font color=\"blue\">展开后所含括号的重数；</font>  <font color=\"red\">注：</font>“原子”的深度为0；“空表”的深度为1</li>\n<li>广义表可以为其他广义表<font color=\"red\">共享</font></li>\n<li>广义表可以是一个 <font color=\"red\">递归</font>的表。<font color=\"red\">注：</font>递归表的深度是无穷值，长度是有限值</li>\n<li>广义表是<font color=\"red\">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表</li>\n</ol>\n<h3 id=\"广义表和线性表的区别\"><a href=\"#广义表和线性表的区别\" class=\"headerlink\" title=\"广义表和线性表的区别\"></a>广义表和线性表的区别</h3><p>广义表可以看成是线性表的推广，线性表是广义表的特例</p>\n<p>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构</p>\n<h3 id=\"广义表的基本运算\"><a href=\"#广义表的基本运算\" class=\"headerlink\" title=\"广义表的基本运算\"></a>广义表的基本运算</h3><ol>\n<li>求表头GetHead（L)，可以是一个原子也可以是一个子表</li>\n<li>求表尾GetTail（L)，一定是一个子表</li>\n</ol>\n<h3 id=\"广义表的存储\"><a href=\"#广义表的存储\" class=\"headerlink\" title=\"广义表的存储\"></a>广义表的存储</h3><p>因为表中元素的大小不固定，所以不用数组存储，一般用链表存储</p>\n<h2 id=\"⛄树和二叉树\"><a href=\"#⛄树和二叉树\" class=\"headerlink\" title=\"⛄树和二叉树\"></a>⛄树和二叉树</h2><h3 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h3><p>树（Tree）是n（n&gt;=0）个结点的有限集（递归定义）。</p>\n<p>若n=0，称为空树；</p>\n<p>若n&gt;0，则它满足如下两个条件：</p>\n<pre><code>1. 有且仅有一个特定的称为 根 的结点\n2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）\n3. \n</code></pre>\n<h3 id=\"树的基本术语\"><a href=\"#树的基本术语\" class=\"headerlink\" title=\"树的基本术语\"></a>树的基本术语</h3><p>结点：数据元素以及指向子树的分支</p>\n<p>根节点：非空树中无前驱结点的结点</p>\n<p>结点的度：结点拥有的子树数</p>\n<p>树的度：树内各结点的度的最大值</p>\n<p>叶子结点：度为0，也叫作终端节点</p>\n<p>分支结点：度不为0，非终端结点</p>\n<p>内部结点：根节点以外的分支结点</p>\n<p>结点的子树称为该结点的<font color=\"red\">孩子</font>，该结点称为孩子的<font color=\"red\">双亲</font></p>\n<p>拥有同一个双亲的结点称为<font color=\"red\">兄弟结点</font></p>\n<p>双亲在同一层但双亲不同的结点称为<font color=\"red\">堂兄弟结点</font></p>\n<p>结点的<font color=\"red\">祖先</font>：从根到该结点所经分支上的所有结点</p>\n<p>结点的<font color=\"red\">子孙</font>：以某结点为根的子树中的任一结点</p>\n<p>树的<font color=\"red\">深度</font>：树中结点的最大层次</p>\n<p><font color=\"red\">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）</p>\n<p><font color=\"red\">无序树：</font>树中结点的各子树无次序</p>\n<p><font color=\"red\">森林：</font>是m（m&gt;=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树</p>\n<h3 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h3><p>为什么要研究二叉树？</p>\n<p>答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。</p>\n<p><strong>定义</strong></p>\n<p>二叉树是n（n&gt;=0）个结点的有限集，它或者是空集，或者由一个<font color=\"blue\">根结点</font>及<font color=\"red\">两个互不相交</font>的分别称作这个根的<font color=\"blue\">左子树</font>和<font color=\"blue\">右子树</font>的二叉树组成。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>每个结点最多有两个孩子<font color=\"red\">（二叉树中不存在度大于2的结点）</font></li>\n<li>子树有左右之分，其次序不能颠倒</li>\n<li>二叉树可以是空集合，根可以有空的左子树或空的右子树</li>\n</ol>\n<p><font color=\"red\">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。</p>\n<h3 id=\"二叉树的抽象数据类型定义\"><a href=\"#二叉树的抽象数据类型定义\" class=\"headerlink\" title=\"二叉树的抽象数据类型定义\"></a>二叉树的抽象数据类型定义</h3><p><strong>二叉树的抽象数据类型定义</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT BinaryTree&#123;</span><br><span class=\"line\">\t数据对象D：D是具有相同特性的数据元素的集合</span><br><span class=\"line\">\t数据关系R：若D=∅，则R=∅</span><br><span class=\"line\">\t\t\t  若D≠∅，则R=&#123;H&#125;,H是如下二元关系</span><br><span class=\"line\">\t\t\t  1. root唯一//关于根的说明</span><br><span class=\"line\">\t\t\t  2. ......//子树不相交</span><br><span class=\"line\">\t\t\t  3. ......//关于数据元素的说明</span><br><span class=\"line\">\t\t\t  4. ......//关于左子树和右子树的说明</span><br><span class=\"line\">\t基本操作P：//至少有20个</span><br><span class=\"line\">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>\n\n<p><strong>比较重要的几个操作：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateBiTree(&amp;T,definition)</span><br><span class=\"line\">\t初始条件：definition给出二叉树T的定义\t//definition是指构造方式（先序...)</span><br><span class=\"line\">\t操作结果：按definition构造二叉树T</span><br><span class=\"line\">PreOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：先序遍历T，对每个结点访问一次</span><br><span class=\"line\">InOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：中序遍历T，对每个结点访问一次</span><br><span class=\"line\">PostOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：后序遍历T，对每个结点访问一次</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h3><p><font color=\"red\">性质1：</font>在二叉树的第i层上<font color=\"blue\">最多</font>有2^i-1^个结点（i&gt;=1）</p>\n<p><font color=\"red\">性质2：</font>深度为k的二叉树<font color=\"blue\">最多</font>有2^k^-1个结点（k&gt;=1）    <font color=\"red\">深度为k时至少有k个结点</font></p>\n<p><font color=\"red\">性质3：</font>对任意一颗二叉树T，如果其叶子数为n<del>0</del>，度为2的结点数为n<del>2</del>，则<font color=\"red\">n<del>0</del>=n<del>2</del>+1</font></p>\n<p>从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）</p>\n<p>从上往下：B = n<del>2</del> * 2 + n<del>1</del> * 1</p>\n<p>B = n<del>2</del> * 2 + n<del>1</del> * 1 =  n - 1</p>\n<p>n = n<del>2</del> * 2 + n<del>1</del> * 1 + 1</p>\n<p>又因为n = n<del>0</del> + n<del>1</del> + n<del>2</del>    两式相结合得到 n<del>0</del>=n<del>2</del>+1</p>\n<p><strong>两种特殊形式的二叉树</strong></p>\n<p><strong>满二叉树</strong></p>\n<p>一颗深度为k且有2^k^-1个结点的二叉树称为<font color=\"blue\">满二叉树</font></p>\n<p>特点：1. 每层都满    2. 叶子结点全部在最底层</p>\n<p>对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。</p>\n<ul>\n<li>满二叉树在同样深度的二叉树中<font color=\"red\">结点</font>个数最多</li>\n<li>满二叉树在同样深度的二叉树中<font color=\"red\">叶子结点</font>个数最多</li>\n</ul>\n<p><strong>完全二叉树</strong></p>\n<p>深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color=\"red\">一一对应</font>时，称为完全二叉树</p>\n<p>注：在满二叉树中，从最后一个结点开始<font color=\"red\">连续</font>去掉<font color=\"red\">任意</font>个结点，即是一棵完全二叉树</p>\n<p>特点：1. 叶子只可能分布在层次最大的两层上</p>\n<p>​            2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1</p>\n<p><font color=\"red\">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log<del>2</del>n ⌋ + 1        (完全二叉树结点n与深度k的关系)</p>\n<p><font color=\"red\">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log<del>2</del>n ⌋ + 1层，每层从左到右），则对任一结点i（1&lt;=i&lt;=n），有</p>\n<ol>\n<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其<font color=\"red\">双亲结点是⌊ i / 2 ⌋</font></li>\n<li>如果2i&gt;n，则结点i为叶子结点，无左孩子；否则，其<font color=\"red\">左孩子结点是2i</font></li>\n<li>如果2i + 1&gt;n，则结点i无右孩子；否则，其<font color=\"red\">右孩子结点是2i+1</font></li>\n</ol>\n<p>性质5表明了完全二叉树中<font color=\"red\">双亲结点编号</font>与<font color=\"red\">孩子结点编号</font>之间的关系</p>\n<p><font color=\"red\">性质6：</font></p>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><h4 id=\"二叉树的顺序存储\"><a href=\"#二叉树的顺序存储\" class=\"headerlink\" title=\"二叉树的顺序存储\"></a>二叉树的顺序存储</h4><p>按<font color=\"red\">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树顺序存储表示</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXTSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> TElemType SqBiTree[MAXSIZE];\t<span class=\"comment\">//定义了一种数组类型，元素类型TElemType</span></span><br><span class=\"line\">SqBiTree bt;</span><br></pre></td></tr></table></figure>\n\n<p>若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0</p>\n<p>二叉树的顺序存储缺点：</p>\n<p>最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组</p>\n<p>结点间关系蕴含在其存储位置中，浪费空间，适于存<font color=\"red\">满二叉树和完全二叉树</font></p>\n<h4 id=\"二叉树的链式存储结构\"><a href=\"#二叉树的链式存储结构\" class=\"headerlink\" title=\"二叉树的链式存储结构\"></a>二叉树的链式存储结构</h4><p>二叉链表存储结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct BiNode&#123;</span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\tstruct BiNode *lchild,*rchild;\t//左右孩子指针</span><br><span class=\"line\">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在n个结点的二叉链表中，必有<font color=\"red\">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color=\"red\">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中</p>\n<p><font color=\"red\">空指针数目= 2n - (n-1) = n +1</font></p>\n<h4 id=\"三叉链表\"><a href=\"#三叉链表\" class=\"headerlink\" title=\"三叉链表\"></a>三叉链表</h4><p>三个指针域：lchild、rchild、parent</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TriTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TriTNode</span> *<span class=\"title\">lchid</span>,*<span class=\"title\">rchild</span>,*<span class=\"title\">parent</span>;</span></span><br><span class=\"line\">&#125;TriTNode,*TriTree;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"遍历二叉树\"><a href=\"#遍历二叉树\" class=\"headerlink\" title=\"遍历二叉树\"></a>遍历二叉树</h3><p><font color=\"red\">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]</p>\n<p><font color=\"red\">遍历目的：</font>得到树中所有结点的一个线性排列</p>\n<p><font color=\"red\">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心</p>\n<h4 id=\"遍历二叉树算法描述\"><a href=\"#遍历二叉树算法描述\" class=\"headerlink\" title=\"遍历二叉树算法描述\"></a>遍历二叉树算法描述</h4><p><strong>遍历方法</strong></p>\n<p>若规定<strong>先左后右</strong>，则只有三种情况：</p>\n<p>DLR - 先序遍历</p>\n<p>LDR - 中序遍历</p>\n<p>LRD - 后序遍历</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">先序遍历二叉树</th>\n<th align=\"center\">中序遍历二叉树</th>\n<th align=\"center\">后序遍历二叉树</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n</tr>\n<tr>\n<td align=\"center\">1.访问根结点</td>\n<td align=\"center\">1.中序遍历左子树</td>\n<td align=\"center\">1.后序遍历左子树</td>\n</tr>\n<tr>\n<td align=\"center\">2.先序遍历左子树</td>\n<td align=\"center\">2.访问根结点</td>\n<td align=\"center\">2.后序遍历右子树</td>\n</tr>\n<tr>\n<td align=\"center\">3.先序遍历右子树</td>\n<td align=\"center\">3.中序遍历右子树</td>\n<td align=\"center\">3.访问根结点</td>\n</tr>\n</tbody></table>\n<h4 id=\"根据遍历序列确定二叉树\"><a href=\"#根据遍历序列确定二叉树\" class=\"headerlink\" title=\"根据遍历序列确定二叉树\"></a>根据遍历序列确定二叉树</h4><ul>\n<li>若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的</li>\n<li>由二叉树的<font color=\"red\">先序序列和中序序列</font>，或由二叉树的<font color=\"red\">后序序列和中序序列</font>可以确定唯一一颗二叉树</li>\n</ul>\n<p><strong>已知先序和中序序列求二叉树</strong></p>\n<p>分析：由先序序列确定根，由中序序列确定左右子树</p>\n<p><strong>已知中序和后序序列求二叉树</strong></p>\n<p>分析：由后序序列确定根，由中序序列确定左右子树</p>\n<h4 id=\"遍历的算法实现\"><a href=\"#遍历的算法实现\" class=\"headerlink\" title=\"遍历的算法实现\"></a>遍历的算法实现</h4><h5 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h5><p>存储结构：二叉链表</p>\n<p>方法：递归</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t<span class=\"comment\">//递归后传递进来的就是T-&gt;child的值了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">visit</span>(T);\t<span class=\"comment\">//访问根结点\t例如，输出根结点：cout&lt;&lt;T-&gt;data;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">PreOrderTraverse</span>(T-&gt;lchild);\t<span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">PreOrderTraverse</span>(T-&gt;rchild);\t<span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pre</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t\t<span class=\"comment\">//例子</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;T-&gt;data;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>(T-&gt;rchild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t<span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t<span class=\"comment\">//后序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">PostOrderTraverse</span>(T.&gt;rchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">visit</span>(T);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"遍历算法的分析\"><a href=\"#遍历算法的分析\" class=\"headerlink\" title=\"遍历算法的分析\"></a>遍历算法的分析</h4><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。</p>\n<p>第1次经过时访问 = 先序遍历</p>\n<p>第2次经过时访问 = 中序遍历</p>\n<p>第3次经过时访问 = 后序遍历</p>\n<p>时间复杂度O（n）    //每个结点只访问一次</p>\n<p>空间复杂度O（n）    //栈占用的最大辅助空间（都是左子树或者都是右子树）</p>\n<h4 id=\"遍历二叉树的非递归算法\"><a href=\"#遍历二叉树的非递归算法\" class=\"headerlink\" title=\"遍历二叉树的非递归算法\"></a>遍历二叉树的非递归算法</h4><h5 id=\"中序遍历非递归算法\"><a href=\"#中序遍历非递归算法\" class=\"headerlink\" title=\"中序遍历非递归算法\"></a>中序遍历非递归算法</h5><p>关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树</p>\n<p><font color=\"red\">基本思想：</font></p>\n<ol>\n<li>建立一个<font color=\"red\">栈</font></li>\n<li><font color=\"red\">根</font>结点<font color=\"red\">进栈</font>，遍历<font color=\"red\">左子树</font></li>\n<li><font color=\"red\">根</font>结点<font color=\"red\">出栈</font>，输出根结点，遍历<font color=\"red\">右子树</font></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraver</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t<span class=\"comment\">//T是根结点</span></span><br><span class=\"line\">    BiTree p; <span class=\"built_in\">InitStack</span>(S); p = T;\t<span class=\"comment\">//p是当前要出栈或者入栈的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p||!<span class=\"built_in\">StackEmpty</span>(S))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p) &#123;<span class=\"built_in\">push</span>(S,p); p = p-&gt;lchild;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  &#123;<span class=\"built_in\">pop</span>(S,q); cout&lt;&lt;q-&gt;data; p = q-&gt;rchild;&#125;\t<span class=\"comment\">//q是栈顶元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二叉树的层次遍历\"><a href=\"#二叉树的层次遍历\" class=\"headerlink\" title=\"二叉树的层次遍历\"></a>二叉树的层次遍历</h4><p>对于一颗二叉树，从根结点开始，按<font color=\"red\">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。</p>\n<p>实现的关键：<font color=\"red\">顺序循环队列</font></p>\n<p>队列类型定义如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tBTNode data[MAXSIZE];\t<span class=\"comment\">//存放队中元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front, rear;\t\t<span class=\"comment\">//队头和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n\n<p>层次遍历算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BTNode &amp;b)</span></span>&#123;</span><br><span class=\"line\">\tBTNode *p; SqQueue *qu;\tp = b;</span><br><span class=\"line\">\t<span class=\"built_in\">InitQueue</span>(qu);\t\t\t\t<span class=\"comment\">//初始化队列</span></span><br><span class=\"line\">\t<span class=\"built_in\">enQueue</span>(qu,b);\t\t\t\t<span class=\"comment\">//根结点指针进入队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!<span class=\"built_in\">QueueEmpty</span>(qu))&#123;\t\t<span class=\"comment\">//队不为空，则循环</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">deQueue</span>(qu,p);\t\t\t<span class=\"comment\">//出队结点p（应该是队首元素）</span></span><br><span class=\"line\">\t\tcout&lt;&lt;p-&gt;data;\t\t\t<span class=\"comment\">//访问结点p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>) <span class=\"built_in\">enQueue</span>(qu,p-&gt;lchild);\t<span class=\"comment\">//有左孩子时将其进队</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;rchild !=<span class=\"literal\">NULL</span>) <span class=\"built_in\">enQueue</span>(qu,p-&gt;rchild);\t\t<span class=\"comment\">//有右孩子时将其进队</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二叉树的建立\"><a href=\"#二叉树的建立\" class=\"headerlink\" title=\"二叉树的建立\"></a>二叉树的建立</h4><p><strong>按先序遍历建立二叉树的二叉链表</strong></p>\n<p>例：ABCDEGF    如果只这么输入，树不是唯一的，所以<font color=\"red\">空结点用其他符号表示</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">CreateBiTree</span><span class=\"params\">(BiTree &amp;T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    cin&gt;&gt;ch;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch == <span class=\"string\">&#x27;#&#x27;</span>) T == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(T = <span class=\"keyword\">new</span> BiTNode)) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">        T-&gt;data = ch;\t\t\t\t<span class=\"comment\">//生成根结点</span></span><br><span class=\"line\">        <span class=\"built_in\">createBiTree</span>(T-&gt;lchild);\t<span class=\"comment\">//构造左子树</span></span><br><span class=\"line\">        <span class=\"built_in\">createBiTree</span>(T-&gt;rchild);\t<span class=\"comment\">//构造右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"复制二叉树\"><a href=\"#复制二叉树\" class=\"headerlink\" title=\"复制二叉树\"></a>复制二叉树</h4><p><strong>先序遍历复制二叉树</strong></p>\n<ul>\n<li>如果是空树，递归结束；</li>\n<li>否则，申请新结点空间，复制根结点<ul>\n<li>递归复制左子树</li>\n<li>递归复制右子树</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Copy</span><span class=\"params\">(BiTree, BiTree &amp;NewT)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(BtTree == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tNewT = <span class=\"literal\">NULL</span>; <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tNewT = <span class=\"keyword\">new</span> BiTNode;\t\t<span class=\"comment\">//内存中申请一块新结点空间</span></span><br><span class=\"line\">\t\tNewT-&gt;data = T-&gt;data;\t<span class=\"comment\">//将data域中的值复制到新结点当中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);\t<span class=\"comment\">//递归复制左子树</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);\t<span class=\"comment\">//递归复制右子树</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树深度\"><a href=\"#计算二叉树深度\" class=\"headerlink\" title=\"计算二叉树深度\"></a>计算二叉树深度</h4><ul>\n<li>如果是空树，深度为0</li>\n<li>否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Depth</span><span class=\"params\">(BiTree)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tm = <span class=\"built_in\">Depth</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\tn = <span class=\"built_in\">Depth</span>(T-&gt;rchild);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> m&gt;n?m+<span class=\"number\">1</span>:n+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树结点总个数\"><a href=\"#计算二叉树结点总个数\" class=\"headerlink\" title=\"计算二叉树结点总个数\"></a>计算二叉树结点总个数</h4><ul>\n<li>如果是空树，则结点个数为0</li>\n<li>否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NodeCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">NodeCount</span>(T-&gt;lchild) + <span class=\"built_in\">NodeCount</span>(T-&gt;rchild) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树叶子结点树\"><a href=\"#计算二叉树叶子结点树\" class=\"headerlink\" title=\"计算二叉树叶子结点树\"></a>计算二叉树叶子结点树</h4><ul>\n<li>如果是空树，叶子结点个数为0</li>\n<li>否则，为左子树的叶子结点树+右子树的叶子结点数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LeafCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lchild == <span class=\"literal\">NULL</span> &amp;&amp; T-&gt;rchild == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//如果是叶子结点返回1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">LeafCount</span>(T-&gt;lchild)+<span class=\"built_in\">LeafCount</span>(T-&gt;rchild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><p><strong>为什么要研究线索二叉树</strong>？</p>\n<p>当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color=\"red\">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font></p>\n<p><strong>如何寻找特定遍历序列中二叉树结点的前驱和后继？</strong></p>\n<p>解决方法：</p>\n<ol>\n<li>通过遍历寻找                        费时间</li>\n<li>添加前驱、后继指针域         费空间</li>\n<li><font color=\"red\">利用二叉链表的空指针域</font></li>\n</ol>\n<p><strong>二叉链表中空指针域的数量</strong></p>\n<p>n个结点的二叉树有2n个指针域，n个结点中有<font color=\"red\">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color=\"red\">n + 1 个指针域为空</font></p>\n<p><strong>利用二叉链表中的空指针域</strong></p>\n<p>如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color=\"red\">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color=\"red\">指向其后继</font></p>\n<p>这种<font color=\"red\">改变指向的指针</font>称为<font color=\"red\">“线索”</font></p>\n<p>加上了线索的二叉树称为<font color=\"red\">线索二叉树</font></p>\n<p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color=\"red\">线索化</font></p>\n<p><strong>区分孩子指针和前驱后继指针</strong></p>\n<p>为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color=\"red\">每个结点增设两个标志域 ltag 和 rtag</font></p>\n<p>ltag = 0    lchild指向该结点的左孩子</p>\n<p>ltag = 1    lchild指向该结点的前驱</p>\n<p>rtag = 0    rchild指向该结点的右孩子</p>\n<p>rtag = 1    rchild指向该结点的后继</p>\n<h4 id=\"结点的结构\"><a href=\"#结点的结构\" class=\"headerlink\" title=\"结点的结构\"></a>结点的结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ltag,rtag;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"增加一个头结点\"><a href=\"#增加一个头结点\" class=\"headerlink\" title=\"增加一个头结点\"></a><strong>增加一个头结点</strong></h4><p>为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点</p>\n<p>ltag=0，lchild指向根结点</p>\n<p>rtag=1，rchild指向遍历序列中的最后一个结点</p>\n<p>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</p>\n<h3 id=\"树和森林\"><a href=\"#树和森林\" class=\"headerlink\" title=\"树和森林\"></a>树和森林</h3><h4 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h4><h5 id=\"1-双亲表示法\"><a href=\"#1-双亲表示法\" class=\"headerlink\" title=\"1.双亲表示法\"></a>1.双亲表示法</h5><p>实现：定义数据结构，每个结点含两个域</p>\n<p>数据域：存放结点本身信息</p>\n<p>双亲域：指示本结点的双亲结点在数组中的位置</p>\n<p>r = 0  根结点位置    n = 10 结点数，方便定义数组</p>\n<p>特点：找双亲容易，找孩子难</p>\n<p><strong>结点的类型定义</strong></p>\n<p>结点结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PTNode</span>&#123;</span></span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> parent;</span><br><span class=\"line\">&#125;PTNode;</span><br></pre></td></tr></table></figure>\n\n<p>树结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_TREE_SIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tPTNode nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r,n;</span><br><span class=\"line\">&#125;PTree;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2-孩子链表\"><a href=\"#2-孩子链表\" class=\"headerlink\" title=\"2.孩子链表\"></a>2.孩子链表</h5><p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。</p>\n<p>则n个结点有n个孩子链表（叶子的孩子链表为空表）。</p>\n<p>而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p>\n<p>特点：找孩子容易，找双亲难</p>\n<p><strong>类型定义</strong></p>\n<p>孩子结点结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> child;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;*ChildPtr;</span><br></pre></td></tr></table></figure>\n\n<p>双亲结点结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\tChildPtr firstchild;\t<span class=\"comment\">//孩子链表头指针</span></span><br><span class=\"line\">&#125;CTBox;</span><br></pre></td></tr></table></figure>\n\n<p>树结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tCTBox nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,r;\t<span class=\"comment\">//结点数和根结点的位置</span></span><br><span class=\"line\">&#125;CTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color=\"red\">带双亲的孩子链表。</font></p>\n<h5 id=\"3-孩子兄弟表示法\"><a href=\"#3-孩子兄弟表示法\" class=\"headerlink\" title=\"3.孩子兄弟表示法\"></a>3.孩子兄弟表示法</h5><p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color=\"red\">第一个孩子结点</font>和<font color=\"red\">下一个兄弟结点</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typdedef <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span> *<span class=\"title\">firstchild</span>,*<span class=\"title\">nextsibling</span>;</span></span><br><span class=\"line\">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>\n\n<p>特点：查找孩子容易，查找双亲难</p>\n<h4 id=\"树与二叉树的转换\"><a href=\"#树与二叉树的转换\" class=\"headerlink\" title=\"树与二叉树的转换\"></a>树与二叉树的转换</h4><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作</p>\n<p>由于树和二叉树都可以用二叉链表作存储结构，则<font color=\"red\">以二叉链表作媒介</font>可以导出树与二叉树之间的一个对应关系</p>\n<p><font color=\"red\">给定一颗树，可以找到唯一的一棵二叉树与之对应</font></p>\n<p><strong>将树转换成二叉树</strong></p>\n<p>1.加线：在兄弟之间加一条线</p>\n<p>2.抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>\n<p>3.旋转：以树的根结点为轴心，将整树顺时针转45°</p>\n<p><strong>将二叉树转换成树</strong></p>\n<p>1.加线：若p结点是双亲结点的左孩子，则将p的有孩子，有孩子的有孩子……延分支找到所有的右孩子，都与p的双亲用线连起来</p>\n<p>2.抹线：抹掉原二叉树中双亲与右孩子之间的连线</p>\n<p>3.调整：将结点按层次排列，形成树结构</p>\n<h4 id=\"森林与二叉树的转化\"><a href=\"#森林与二叉树的转化\" class=\"headerlink\" title=\"森林与二叉树的转化\"></a>森林与二叉树的转化</h4><p><strong>森林转化成二叉树</strong></p>\n<p>1.将各棵树分别转换成二叉树</p>\n<p>2.将每棵树的根节点用线相连</p>\n<p>3.以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>\n<p><strong>二叉树转化成森林</strong></p>\n<p>1.抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子建连线全部抹掉，使之变成孤立的二叉树</p>\n<p>2.还原：将孤立的二叉树还原成树</p>\n<h4 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h4><p><strong>1.树的遍历（三种方式）</strong>         【二叉树的遍历有四种方式：先根、中根、后根、层次】</p>\n<ul>\n<li><p>先根遍历：</p>\n<p>若树不空，则先访问根结点，然后依次先根遍历各棵子树</p>\n</li>\n<li><p>后根遍历：</p>\n<p>若树不空，则先依次后根遍历各棵子树，然后访问根结点</p>\n</li>\n<li><p>参差遍历：</p>\n<p>若树不空，则自上而下从左至右访问树中每个结点 </p>\n</li>\n</ul>\n<p><strong>2.森林的遍历</strong></p>\n<p>将森林看做有三部分构成：</p>\n<p>1.森林中第一棵树的根结点；</p>\n<p>2.森林中第一棵树的子树森林；</p>\n<p>3.森林中其他树构成的森林</p>\n<p><strong>先序遍历：</strong></p>\n<p>若森林不空，则</p>\n<p>1.访问森林中第一棵树的根结点；</p>\n<p>2.先序遍历森林中第一棵树的子树森林；</p>\n<p>3.先序遍历森林中（除第一棵树之外）其余树构成的森林</p>\n<p><font color=\"red\">即：依次从左至右对森林中每一棵树进行先根遍历</font></p>\n<p><font color=\"red\">还有一种很简单的方法：即对森林中每一棵树依次进行先序遍历</font></p>\n<p><strong>中序遍历：</strong></p>\n<p>若森林不空，则</p>\n<p>1.中序遍历森里中第一棵树的子树森林；</p>\n<p>2.访问森林中第一棵树的根结点；</p>\n<p>3.中序遍历森林中（除第一棵树之外）其余树构成的森林</p>\n<p><font color=\"red\">即：依次从左至右对森林中每一棵树进行中序遍历</font></p>\n<h3 id=\"哈夫曼树及应用\"><a href=\"#哈夫曼树及应用\" class=\"headerlink\" title=\"哈夫曼树及应用\"></a>哈夫曼树及应用</h3><h4 id=\"哈夫曼树的基本概念\"><a href=\"#哈夫曼树的基本概念\" class=\"headerlink\" title=\"哈夫曼树的基本概念\"></a>哈夫曼树的基本概念</h4><p><font color=\"red\">判断树：</font>用于描述分类过程的二叉树</p>\n<p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径</p>\n<p>路径的长度：两结点间路径上的分支数</p>\n<p>树的路径长度：从<font color=\"red\">树根</font>到每一个结点的<font color=\"red\">路径长度之和</font>。记作：TL</p>\n<p><font color=\"red\">结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>路径长度最短的不一定是二叉树。</p>\n<p>权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<font color=\"red\">结点的权</font></p>\n<p>结点的带权路径长度：从<font color=\"red\">根结点</font>到该结点之间的<font color=\"red\">路径长度</font>与该结点的<font color=\"red\">权</font>的<font color=\"red\">乘积</font></p>\n<p>树的带权路径长度：树中所有<font color=\"red\">叶子</font>结点的<font color=\"red\">带权路径长度</font>。记作：WPL (Weighted Path Length)</p>\n<p>哈夫曼树：<font color=\"red\">最优树</font> 即带权路径长度最短的树</p>\n<p>“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。</p>\n<p>哈夫曼树：<font color=\"red\">最优二叉树</font> 带权路径长度最短的二叉树</p>\n<p>相应的算法称为哈夫曼算法</p>\n<p>特点：</p>\n<p>满二叉树不一定是哈夫曼树</p>\n<p>哈夫曼树中权越大的叶子离根越近</p>\n<p>具有相同带权结点的哈夫曼树不唯一</p>\n<h4 id=\"哈夫曼树的构造算法\"><a href=\"#哈夫曼树的构造算法\" class=\"headerlink\" title=\"哈夫曼树的构造算法\"></a>哈夫曼树的构造算法</h4><p>贪心算法：构造哈夫曼树时首先选择权值小的叶子结点</p>\n<p><font color=\"red\">哈夫曼算法</font></p>\n<p>1.根据n个给定的权值{w<del>1</del>,w<del>2</del>,…,w<del>n</del>}构成n棵二叉树的森林F={T<del>1</del>,T<del>2</del>,…,T<del>n</del>},其中T<del>i</del>只有一个带权为w<del>i</del>的根结点</p>\n<p><font color=\"red\">构造森林全是根</font></p>\n<p>2.在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右字数上根结点的权值之和</p>\n<p><font color=\"red\">选用两小造新树</font></p>\n<p>3.在F中删除这两棵树，同时将新得到的二叉树加入森林中</p>\n<p><font color=\"red\">删除两小添新人</font></p>\n<p>4.重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树</p>\n<p><font color=\"red\">重复2、3剩单根</font></p>\n<p>哈夫曼树的结点度数为0或2，没有度为1的结点</p>\n<p>包含n个叶子结点的哈夫曼树中共有2n-1个结点</p>\n<p>（包含n棵树的森林要经过n-1次和并才能形成哈夫曼树，共产生n-1个新结点）</p>\n<p><strong>总结：</strong></p>\n<p>1.在哈夫曼算法中，初始时有n棵二叉树，要经过<font color=\"red\">n-1</font>次合并最终形成哈夫曼树</p>\n<p>2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支节点</p>\n<p>可见：哈夫曼树中共有 n+n-1 =  <font color=\"red\">2n-1</font>个结点，且其所有的分支结点的度均不为1</p>\n<h4 id=\"哈夫曼树构造算法的实现\"><a href=\"#哈夫曼树构造算法的实现\" class=\"headerlink\" title=\"哈夫曼树构造算法的实现\"></a>哈夫曼树构造算法的实现</h4><p>采用顺序存储结构————一维结构数组</p>\n<p>结点类型定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> parent,lch,rch;</span><br><span class=\"line\">&#125;HTNode,*Huffman Tree;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">哈夫曼树中结点下标i</th>\n<th align=\"center\">weight</th>\n<th align=\"center\">parent</th>\n<th align=\"center\">lch</th>\n<th align=\"center\">rch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2n-1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>哈夫曼树中共有2n-1个结点，不使用0下标，数组大小为2n</p>\n<p>步骤：</p>\n<p>1.初始化<font color=\"red\">HT[1……2n-1]</font> : lch = rch = parent = 0;</p>\n<p>2.输入初始<font color=\"red\">n个叶子结点</font>：置HT[1……n]的<font color=\"red\">weight值</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateHuffmanTree</span><span class=\"params\">(HuffmanTree HT,<span class=\"keyword\">int</span> n)</span></span>&#123; <span class=\"comment\">//构造哈夫曼树--哈夫曼算法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tm = <span class=\"number\">2</span>*n - <span class=\"number\">1</span>;\t<span class=\"comment\">//数组共2n-1个元素</span></span><br><span class=\"line\">\tHT = <span class=\"keyword\">new</span> HTNode[m+<span class=\"number\">1</span>];\t<span class=\"comment\">//0号单元未用，HT[m]表示根结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tHT[i].lch = <span class=\"number\">0</span>;HT[i].rch = <span class=\"number\">0</span>;HT[i].parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n,++i) cin&gt;&gt;HT[i].weight;\t<span class=\"comment\">//输入前n个元素的weight值</span></span><br><span class=\"line\">\t<span class=\"comment\">//初始化结束，下面开始建立哈夫曼树</span></span><br><span class=\"line\">续</span><br></pre></td></tr></table></figure>\n\n<p>3.<font color=\"red\">进行以下n-1次合并，</font>依次产生n-1个结点HT[i], i=<font color=\"red\">n+1</font>…..2n-1;</p>\n<pre><code> a.在HT[1…i-1]中选两个&lt;font color=&quot;red&quot;&gt;未被选过&lt;/font&gt;（从parent==0的结点中选）的weight最小的两个结        点&lt;font color=&quot;red&quot;&gt;HT[s1]&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;HT[s2]&lt;/font&gt;,&lt;font color=&quot;red&quot;&gt;s1、s2为两个最小结点下标&lt;/font&gt;\n</code></pre>\n<p>​    b.修改HT[s1]和HT[s2]的parent值：HT[s1].parent = i; HT[s2].parent = i;</p>\n<p>​    c.修改新产生的HT[i]：</p>\n<p>​        HT[i].weight = HT[s1].weight + HT[s2].weight;</p>\n<p>​        HT[i].lch = s1; HT[i].rch = s2;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">续</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=n+<span class=\"number\">1</span>;i&lt;=m;i++)&#123;\t\t<span class=\"comment\">//合并产生n-1个结点--构造Huffman树</span></span><br><span class=\"line\">\t<span class=\"built_in\">Select</span>(HT,i<span class=\"number\">-1</span>,s1,s2);\t<span class=\"comment\">//在HT[k](1&lt;=k&lt;=i-1)中选择两个其双亲域为0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class=\"line\">\tHT[s1].parent = i; HT[s2].parent = i;\t<span class=\"comment\">//表示从F中删除s1,s2</span></span><br><span class=\"line\">    HT[i].lch = s1; HT[i].rch = s2;\t\t\t<span class=\"comment\">//s1，s2分别作为i的左右孩子</span></span><br><span class=\"line\">    HT[i].weight = HT[s1].weight+HT[s2].weight;<span class=\"comment\">//i的权值为左右孩子权值之和</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h4><p>在远程通讯中，要将待传字符转换成由二进制的字符串</p>\n<p>若将编码设计为长度不等的二进制编码，即让待传字符串中<font color=\"red\">出现次数较多的字符采用尽可能短的编码，</font>则转换的二进制字符串便可能减少</p>\n<p><font color=\"red\">关键：</font>要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀</p>\n<p>这种编码称作<font color=\"red\">前缀编码</font></p>\n<p>问题：什么样的前缀码能使电文总长最短  —-<font color=\"red\">哈弗曼编码</font></p>\n<p>1.<font color=\"red\">统计</font>字符集中<font color=\"red\">每个字符</font>在电文中<font color=\"red\">出现的</font>平均<font color=\"red\">概率</font>（概率越大，要求编码越短）。</p>\n<p>2.利用哈夫曼树的特点：权越大的叶子离根越近；<font color=\"red\">将每个字符的概率值作为权值，构造哈夫曼树。</font>则概率越大的结点，路径越短。</p>\n<p>3.在哈夫曼树的每个分支上标上0或1：</p>\n<p>​    结点的<font color=\"red\">左分支标0，右分支标1</font></p>\n<p>​    把根到每个叶子的路径上的标号连接起来，作为该叶子代表的<font color=\"red\">字符的编码</font></p>\n<p><strong>为什么哈弗曼编码能够保证是前缀编码？</strong></p>\n<p>因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀</p>\n<p><strong>为什么哈弗曼编码能够保证字符编码总长最短</strong></p>\n<p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短</p>\n<p><font color=\"red\">哈夫曼编码的两个性质</font></p>\n<p>1.哈弗曼编码是前缀码</p>\n<p>2.哈夫曼编码是最优前缀码</p>\n<h4 id=\"哈夫曼编码的算法实现\"><a href=\"#哈夫曼编码的算法实现\" class=\"headerlink\" title=\"哈夫曼编码的算法实现\"></a>哈夫曼编码的算法实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateHuffmanCode</span><span class=\"params\">(Huffman Tree HT,HuffmanCode &amp;HC,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//从叶子到根逆向求每个字符的哈弗曼编码，存储在编码表HC中</span></span><br><span class=\"line\">\tHC = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span> *[n+<span class=\"number\">1</span>];\t<span class=\"comment\">//分配n个字符编码的头指针矢量</span></span><br><span class=\"line\">\tcd = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[n];\t\t<span class=\"comment\">//分配临时存放编码的动态数组空间</span></span><br><span class=\"line\">\tcd[n<span class=\"number\">-1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;\t\t\t<span class=\"comment\">//编码结束符 （字符串结束符）</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tstart=n<span class=\"number\">-1</span>;c=i;f=Ht[i].parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(f!=<span class=\"number\">0</span>)&#123;\t<span class=\"comment\">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class=\"line\">\t\t\t--start;\t<span class=\"comment\">//回溯一次start向前指一个位置</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(HT[f].lchild == c) cd[start]=<span class=\"string\">&#x27;0&#x27;</span>; <span class=\"comment\">//结点c是f的左孩子，0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cd[start]=<span class=\"string\">&#x27;1&#x27;</span>;\t\t\t\t\t <span class=\"comment\">//结点c是f的右孩子，1</span></span><br><span class=\"line\">\t\t\tc = f; f = HT[f].parent;\t\t\t <span class=\"comment\">//继续向上回溯</span></span><br><span class=\"line\">\t\t&#125;\t<span class=\"comment\">//求出第i个字符的编码</span></span><br><span class=\"line\">\t\tHC[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[n-start];\t\t<span class=\"comment\">//为第i个字符串编码分配空间大小是</span></span><br><span class=\"line\">        \t\t\t\t\t\t\t\t<span class=\"comment\">// n-start 已占用的空间量</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(HC[i],&amp;cd[start]);\t\t<span class=\"comment\">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> cd;\t<span class=\"comment\">//释放临时空间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"文件的编码和解码\"><a href=\"#文件的编码和解码\" class=\"headerlink\" title=\"文件的编码和解码\"></a>文件的编码和解码</h4><p><strong>编码</strong></p>\n<p>1.输入各字符及其权值</p>\n<p>2.构造哈夫曼树–HT[i]</p>\n<p>3.进行哈夫曼编码–HC[i]</p>\n<p>4.查HC[i]，得到各字符的哈弗曼编码</p>\n<p><strong>解码</strong></p>\n<p>1.构造哈夫曼树</p>\n<p>2.依次读入二进制码</p>\n<p>3.读入0，则走向左孩子；读入1，则走向右孩子</p>\n<p>4.一旦达到某叶子时，即可译出字符</p>\n<p>5.然后再从根出发继续译码，直到结束</p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"图的定义和基本术语\"><a href=\"#图的定义和基本术语\" class=\"headerlink\" title=\"图的定义和基本术语\"></a>图的定义和基本术语</h3><p>图：G=(V,E)                Graph = （Vertex , Edge)</p>\n<p>​        V：顶点（数据元素）的有穷非空集合；</p>\n<p>​        E：边的有穷集合</p>\n<p>无向图：每条边都是无方向的</p>\n<p>有向图：每条边都是有方向的</p>\n<p>完全图：任意两个点都有一条边相连（无向完全图和有向完全图，其中有向完全图要两个方向都有边）</p>\n<p>无向完全图：<font color=\"red\">n个顶点，n(n-1)/2条边</font></p>\n<p>有向完全图：<font color=\"red\">n个顶点，n(n-1)条边</font></p>\n<p>稀疏图：有很少边或弧的图（e &lt; nlog<del>n</del>）</p>\n<p>稠密图：有较多边或弧的图</p>\n<p>网：边/弧带权的图</p>\n<p>邻接：有边/弧相连的两个顶点之间的关系</p>\n<p>​            存在（v<del>i</del> , v<del>j</del>）, 则称v<del>i</del> 和 v<del>j</del>互为邻接点</p>\n<p>​            存在 &lt;v<del>i</del> , v<del>j</del>&gt; , 则称 v<del>i</del> 邻接到 v<del>j</del> ，v<del>j</del> 邻接于 v<del>i</del> </p>\n<p>​            圆括号表示无向图，尖括号表示有向图，从前面到后面</p>\n<p>关联（依附）：边/弧与顶点之间的关系</p>\n<p>​                            存在（v<del>i</del> , v<del>j</del>） / &lt;v<del>i</del> , v<del>j</del>&gt; , 则称该边/弧关联于v<del>i</del> 和v<del>j</del></p>\n<p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p>\n<p>​                    在<font color=\"red\">有向图</font>中，顶点的度等于该顶点的<font color=\"red\">入度</font>和<font color=\"red\">出度</font>之和</p>\n<p>​                    顶点<font color=\"red\">v的入度</font>是以v为终点的有向边的条数，记作ID(v)</p>\n<p>​                    顶点<font color=\"red\">v的出度</font>是以v为始点的有向边的条数，记作OD(v)</p>\n","site":{"data":{}},"excerpt":"","more":"<center>数据结构</center>\n\n<hr>\n<h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a><center>绪论</center></h2><h3 id=\"🎈数据结构的研究内容\"><a href=\"#🎈数据结构的研究内容\" class=\"headerlink\" title=\"🎈数据结构的研究内容\"></a>🎈数据结构的研究内容</h3><p><strong>计算机解决问题的步骤：</strong></p>\n<ul>\n<li>将问题抽象为<font color=\"red\">数学模型</font></li>\n<li>设计算法</li>\n<li>编程、调试、运行</li>\n</ul>\n<p><strong>早期，计算机应用于数值计算：</strong></p>\n<ul>\n<li>分析问题，找出对象以及对象之间的关系</li>\n<li>建立数学方程</li>\n<li>求解</li>\n</ul>\n<p><strong>随着计算机应用领域的扩展，越来越多被用于非数值计算：</strong></p>\n<ul>\n<li>线性表</li>\n<li>树</li>\n<li>图</li>\n</ul>\n<p>以上都是“非数值计算”的程序设计问题</p>\n<blockquote>\n<p>综上所述，数据结构是一门研究<font color=\"red\">非数值计算的</font>程序设计中计算机的<font color=\"red\">操作对象</font>以及他们之间的<font color=\"red\">关系</font>和<font color=\"red\">操作</font>的学科。</p>\n</blockquote>\n<h3 id=\"🎈基本概念和术语\"><a href=\"#🎈基本概念和术语\" class=\"headerlink\" title=\"🎈基本概念和术语\"></a>🎈基本概念和术语</h3><h4 id=\"数据、数据元素、数据项和数据对象\"><a href=\"#数据、数据元素、数据项和数据对象\" class=\"headerlink\" title=\"数据、数据元素、数据项和数据对象\"></a>数据、数据元素、数据项和数据对象</h4><ol>\n<li><p>数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。</p>\n<p>包括：</p>\n</li>\n</ol>\n<ul>\n<li>数值型数据：整数、实数等</li>\n<li>非数值型数据：文字、图像、图形、声音等</li>\n</ul>\n<ol start=\"2\">\n<li>数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。</li>\n<li>数据项：构成数据元素的不可分割的最小单位</li>\n</ol>\n<blockquote>\n<p><font color=\"red\">以上三者之间的关系：</font>数据&gt;数据元素&gt;数据项</p>\n</blockquote>\n<ol start=\"4\">\n<li><p>数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。</p>\n<p>数据元素和数据对象与数据的关系的区别：</p>\n</li>\n</ol>\n<ul>\n<li>数据元素是集合的个体</li>\n<li>数据对象是集合的子集</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p>数据元素互相之间的关系称为<font color=\"red\">结构</font></p>\n</li>\n<li><p>是指相互之间存在一种或多种特定关系的数据元素集合</p>\n</li>\n<li><p><font color=\"red\">包含以下三方面内容：</font></p>\n<ol>\n<li>数据元素之间的逻辑关系，也称为<font color=\"red\">逻辑结构</font></li>\n<li>数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color=\"red\">物理结构</font>或数据的<font color=\"red\">存储结构</font></li>\n<li>数据的<font color=\"red\">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现</li>\n</ol>\n</li>\n<li><p>数据结构的两个层次：</p>\n<ol>\n<li><p><font color=\"red\">逻辑结构：</font>是指数据对象中数据元素之间的互相关系</p>\n<p><strong>逻辑结构的种类：</strong></p>\n<p>划分方法一：</p>\n<ol>\n<li><font color=\"red\">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。</li>\n<li><font color=\"red\">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。</li>\n</ol>\n<p>划分方法二：</p>\n<ol>\n<li><font color=\"red\">集合结构：</font>其中的数据元素只有<font color=\"red\">只属于一个集合</font>的关系</li>\n<li><font color=\"red\">线性结构：</font>数据元素存在<font color=\"red\">一对一</font>的线性关系</li>\n<li><font color=\"red\">树形结构：</font>数据元素存在<font color=\"red\">一对多</font>的线性关系</li>\n<li><font color=\"red\">图状/网状结构：</font>数据元素存在<font color=\"red\">多对多</font>的线性关系</li>\n</ol>\n</li>\n<li><p><font color=\"red\">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式</p>\n<p><strong>存储结构的种类：</strong></p>\n<p>​    <font color=\"red\">四种基本的存储结构：</font></p>\n<p>​    1.<font color=\"red\">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示</p>\n<p>​    2.<font color=\"red\">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示</p>\n<p>​    3.<font color=\"red\">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）</p>\n<p>​    4.<font color=\"red\">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址</p>\n<p><strong>逻辑结构和存储结构之间的关系：</strong></p>\n<ul>\n<li>存储结构是逻辑关系的映像与元素本身的映像</li>\n<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>\n<li>两者综合起来建立了数据元素之间的结构关系</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>数据类型(Data Type):是指一组性质相同的<font color=\"red\">值的集合</font>及定义在此集合上的<font color=\"red\">一组操作</font>的总称</p>\n<blockquote>\n<p>数据类型 = 值的集合 + 值集合上的一组操作</p>\n</blockquote>\n<p><strong>在C语言中，按照取值的不同，可以分为两类：</strong></p>\n<ul>\n<li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li>\n<li>结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的</li>\n</ul>\n<h4 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h4><mark class=\"hl-label red\">抽象是指抽取出事物具有的普遍性的本质。</mark> \n\n<p>通过对已有的数据类型进行抽象得到。</p>\n<p>抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。</p>\n<ul>\n<li>由用户定义，从问题中抽象出<font color=\"red\">数据模型</font>（逻辑结构）。</li>\n<li>还包括定义在数据模型上的一组<font color=\"red\">抽象运算</font>（相关操作）。</li>\n</ul>\n<p><strong>抽象数据类型的形式定义：</strong></p>\n<p>抽象数据类型可以用（D，S，P）<font color=\"red\">三元组</font>表示。</p>\n<p>其中：D是数据对象；</p>\n<p>​            S是D上的关系集；</p>\n<p>​            P是对D的基本操作集。</p>\n<p><strong>抽象数据类型的定义格式如下：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t数据对象：&lt;数据对象的定义&gt;\t\t<span class=\"comment\">//其中，数据对象和数据关系用伪代码描述</span></span><br><span class=\"line\">\t数据关系：&lt;数据关系的定义&gt;\t\t<span class=\"comment\">//基本操作的定义格式为：</span></span><br><span class=\"line\">\t基本操作：&lt;基本操作的定义&gt;\t\t<span class=\"comment\">// 基本操作名（参数表）</span></span><br><span class=\"line\">&#125;ADT 抽象数据类型名\t\t\t   <span class=\"comment\">// 初始条件：&lt;初始条件描述&gt;</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">// 操作结果：&lt;操作结果描述&gt;                     </span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>基本操作</strong>定义格式说明：</p>\n<p>参数表：赋值参数 只为操作提供输入值</p>\n<p>​                引用参数 以&amp;打头，除可提供输入值外，还将返回操作结果</p>\n<p>初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。</p>\n<p>操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名&#123;</span><br><span class=\"line\">Data</span><br><span class=\"line\">\t数据对象的定义</span><br><span class=\"line\">\t数据元素之间逻辑关系的定义</span><br><span class=\"line\">Operation</span><br><span class=\"line\">\t操作1</span><br><span class=\"line\">\t\t初始条件</span><br><span class=\"line\">\t\t操作结果描述</span><br><span class=\"line\">\t操作2</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t操作n</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a><center>算法</center></h2><p><strong>数据额结构和算法的关系是相互依赖不可分割的。</strong></p>\n<h3 id=\"🎈算法定义\"><a href=\"#🎈算法定义\" class=\"headerlink\" title=\"🎈算法定义\"></a>🎈算法定义</h3><p>算法是解决特定问题<strong>求解方法和步骤</strong>的描述，在计算机中表现为<font color=\"red\">指令</font>的有限<font color=\"red\">序列</font>，并且每条指令表示一个或多个操作。</p>\n<p><strong>算法的描述：</strong></p>\n<ul>\n<li>自然语言：中文、英语</li>\n<li>流程图</li>\n<li>伪代码</li>\n<li>程序代码</li>\n</ul>\n<p><strong>算法与程序：</strong></p>\n<p><strong>算法</strong>是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法</p>\n<p><strong>程序</strong>是用某种程序设计语言对算法的具体实现</p>\n<blockquote>\n<p>程序 = 数据结构 + 算法</p>\n</blockquote>\n<h3 id=\"🎈算法的特性\"><a href=\"#🎈算法的特性\" class=\"headerlink\" title=\"🎈算法的特性\"></a>🎈算法的特性</h3><h4 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h4><ul>\n<li>算法具有零个或多个输入</li>\n<li>算法至少有一个或多个输出</li>\n</ul>\n<h4 id=\"有穷性\"><a href=\"#有穷性\" class=\"headerlink\" title=\"有穷性\"></a>有穷性</h4><p>算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。</p>\n<h4 id=\"确定性\"><a href=\"#确定性\" class=\"headerlink\" title=\"确定性\"></a>确定性</h4><p>算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</p>\n<h4 id=\"可行性\"><a href=\"#可行性\" class=\"headerlink\" title=\"可行性\"></a>可行性</h4><p>算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</p>\n<h3 id=\"🎈算法设计的要求\"><a href=\"#🎈算法设计的要求\" class=\"headerlink\" title=\"🎈算法设计的要求\"></a>🎈算法设计的要求</h3><h4 id=\"正确性\"><a href=\"#正确性\" class=\"headerlink\" title=\"正确性\"></a>正确性</h4><p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</p>\n<p>可以分为四个层次：</p>\n<ol>\n<li>算法程序<font color=\"red\">不含语法错误</font></li>\n<li>算法程序对于<font color=\"red\">几组输入数据</font>能够产生满足要求的输出结果。</li>\n<li>算法程序对于<font color=\"red\">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。</li>\n<li>算法程序对于<font color=\"red\">一切合法的输入数据</font>都有满足要求的输出结果。</li>\n</ol>\n<p>一般情况下，把<font color=\"red\">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。</p>\n<h4 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h4><p>算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试</p>\n<h4 id=\"健壮性\"><a href=\"#健壮性\" class=\"headerlink\" title=\"健壮性\"></a>健壮性</h4><ul>\n<li>当<font color=\"red\">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。</li>\n<li>处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。</li>\n</ul>\n<h4 id=\"时间效率高和存储量低\"><a href=\"#时间效率高和存储量低\" class=\"headerlink\" title=\"时间效率高和存储量低\"></a>时间效率高和存储量低</h4><p>设计算法应该尽量满足时间效率高和存储量低的需求。</p>\n<h3 id=\"🎈算法效率的度量方法\"><a href=\"#🎈算法效率的度量方法\" class=\"headerlink\" title=\"🎈算法效率的度量方法\"></a>🎈算法效率的度量方法</h3><p><strong>算法效率从以下两个方面来考虑：</strong></p>\n<p><font color=\"red\">1.时间效率： </font>指的是算法所耗费的时间</p>\n<p><font color=\"red\">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间</p>\n<p><strong>时间效率和空间效率有时候是矛盾的</strong></p>\n<h4 id=\"事后统计方法\"><a href=\"#事后统计方法\" class=\"headerlink\" title=\"事后统计方法\"></a>事后统计方法</h4><p>将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。</p>\n<h4 id=\"事前分析估算方法\"><a href=\"#事前分析估算方法\" class=\"headerlink\" title=\"事前分析估算方法\"></a>事前分析估算方法</h4><p><strong><font color=\"red\">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font></strong></p>\n<p>在计算机程序编制前，依据统计方法对算法进行估算。</p>\n<p>程序在计算机上运行时所消耗的时间取决于下列因素：</p>\n<ol>\n<li>算法采用的策略、方法</li>\n<li>编译产生的代码质量</li>\n<li>问题的输入规模</li>\n<li>机器指令执行的速度</li>\n</ol>\n<blockquote>\n<p>抛开软件和硬件的因素，一个程序的运行时间，依赖于<strong>算法的好坏和问题的输入规模</strong>。问题输入规模是指输入量的多少。</p>\n</blockquote>\n<p><strong>在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</strong></p>\n<h3 id=\"🎈函数的渐近增长\"><a href=\"#🎈函数的渐近增长\" class=\"headerlink\" title=\"🎈函数的渐近增长\"></a>🎈函数的渐近增长</h3><blockquote>\n<p>定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n&gt;N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。</p>\n</blockquote>\n<p>结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>\n<h3 id=\"🎈算法时间复杂度\"><a href=\"#🎈算法时间复杂度\" class=\"headerlink\" title=\"🎈算法时间复杂度\"></a>🎈算法时间复杂度</h3><h4 id=\"算法时间复杂度定义\"><a href=\"#算法时间复杂度定义\" class=\"headerlink\" title=\"算法时间复杂度定义\"></a>算法时间复杂度定义</h4><blockquote>\n<p>在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color=\"red\"><strong>渐进时间复杂度</strong></font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中<strong>基本操作</strong>执行的次数，它是问题规模n的某个函数，用T（n）表示。</p>\n</blockquote>\n<p>这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。</p>\n<p>一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。</p>\n<p><strong>分析算法时间复杂度的基本方法：</strong></p>\n<ol>\n<li>找出<font color=\"red\">语句频度最大</font>的那条语句作为<font color=\"red\">基本语句</font></li>\n<li>计算<font color=\"red\">基本语句</font>的频度得到问题规模n的某个函数f（n）</li>\n<li>取其数量级用符号“O”表示</li>\n</ol>\n<h4 id=\"推导大O阶方法\"><a href=\"#推导大O阶方法\" class=\"headerlink\" title=\"推导大O阶方法\"></a>推导大O阶方法</h4><ol>\n<li>用常数1取代运行时间中的所有加法常数。</li>\n<li>在修改后的运行次数函数中，只保留最高阶项</li>\n<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>\n<li>得到的结果就是大O阶</li>\n</ol>\n<h4 id=\"常数阶\"><a href=\"#常数阶\" class=\"headerlink\" title=\"常数阶\"></a>常数阶</h4><p>如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。</p>\n<mark class=\"hl-label red\">即执行次数恒定，不会随着n的变大而发生变化</mark> \n\n<h4 id=\"线性阶\"><a href=\"#线性阶\" class=\"headerlink\" title=\"线性阶\"></a>线性阶</h4><p>要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况</strong>。</p>\n<p>下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对数阶\"><a href=\"#对数阶\" class=\"headerlink\" title=\"对数阶\"></a>对数阶</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(count &lt; n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcount = count * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。</p>\n<h4 id=\"平方阶\"><a href=\"#平方阶\" class=\"headerlink\" title=\"平方阶\"></a>平方阶</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; n; J++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。</p>\n<p>如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。</p>\n<p>总结得出，<font color=\"red\">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。</p>\n<p>对于下面这个循环嵌套：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = i; j &lt; n; j++) <span class=\"comment\">/* 注意int j = i 而不是0 */</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 时间复杂度为O（1）的程序步骤序列 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：</p>\n<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>\n\n<p>用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。</p>\n<h4 id=\"算法的加法法则和乘法法则\"><a href=\"#算法的加法法则和乘法法则\" class=\"headerlink\" title=\"算法的加法法则和乘法法则\"></a>算法的加法法则和乘法法则</h4><ul>\n<li><p>加法法则</p>\n<p>T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )</p>\n</li>\n<li><p>乘法法则</p>\n<p>T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )</p>\n</li>\n</ul>\n<h4 id=\"🎈常用的时间复杂度\"><a href=\"#🎈常用的时间复杂度\" class=\"headerlink\" title=\"🎈常用的时间复杂度\"></a>🎈常用的时间复杂度</h4><table>\n<thead>\n<tr>\n<th align=\"center\">执行次数函数</th>\n<th align=\"center\">阶</th>\n<th align=\"center\">非正式术语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">12</td>\n<td align=\"center\">O（1）</td>\n<td align=\"center\">常数阶</td>\n</tr>\n<tr>\n<td align=\"center\">2n+3</td>\n<td align=\"center\">O（n）</td>\n<td align=\"center\">线性阶</td>\n</tr>\n<tr>\n<td align=\"center\">3n<sup>2</sup>+2n+1</td>\n<td align=\"center\">O（n<sup>2</sup>）</td>\n<td align=\"center\">平方阶</td>\n</tr>\n<tr>\n<td align=\"center\">5log<sub>2</sub>n+20</td>\n<td align=\"center\">O（log<sub>2</sub>n）</td>\n<td align=\"center\">对数阶</td>\n</tr>\n<tr>\n<td align=\"center\">2n+3nlog<sub>2</sub>n+19</td>\n<td align=\"center\">O（nlog<sub>2</sub>n）</td>\n<td align=\"center\">nlog<sub>2</sub>n阶</td>\n</tr>\n<tr>\n<td align=\"center\">6n<sup>3</sup>+2n<sup>2</sup>+3n+4</td>\n<td align=\"center\">O（n<sup>3</sup>）</td>\n<td align=\"center\">立方阶</td>\n</tr>\n<tr>\n<td align=\"center\">2<sup>n</sup></td>\n<td align=\"center\">O（2<sup>n</sup>）</td>\n<td align=\"center\">指数阶</td>\n</tr>\n</tbody></table>\n<p>常用的时间复杂度所耗费的时间从小到大依次是：</p>\n<blockquote>\n<p>O（1）&lt;O（log<sub>2</sub>n）&lt; O（n）&lt;O（nlog<sub>2</sub>n）&lt;O（n<sup>2</sup>）&lt;O（n<sup>3</sup>）&lt;O（2<sup>n</sup>）&lt;O（n！）&lt;O（n<sup>n</sup>）</p>\n</blockquote>\n<h3 id=\"🎈最坏情况与平均情况\"><a href=\"#🎈最坏情况与平均情况\" class=\"headerlink\" title=\"🎈最坏情况与平均情况\"></a>🎈最坏情况与平均情况</h3><ul>\n<li><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</strong></li>\n<li>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）</li>\n</ul>\n<h3 id=\"🎈算法空间复杂度\"><a href=\"#🎈算法空间复杂度\" class=\"headerlink\" title=\"🎈算法空间复杂度\"></a>🎈算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。</p>\n<p><strong>算法要占据的空间：</strong></p>\n<ul>\n<li>算法本身要占据的空间，输入/输出，指令，常数，变量等</li>\n<li>算法要使用<font color=\"red\">辅助空间</font></li>\n</ul>\n<hr>\n<h2 id=\"🍟线性表\"><a href=\"#🍟线性表\" class=\"headerlink\" title=\"🍟线性表\"></a><center>🍟线性表</center></h2><h3 id=\"🎵线性表的定义和特点\"><a href=\"#🎵线性表的定义和特点\" class=\"headerlink\" title=\"🎵线性表的定义和特点\"></a>🎵线性表的定义和特点</h3><p><strong>线性表(Linear List):</strong></p>\n<ul>\n<li>由n个数据元素（结点）组成的<font color=\"red\">有限序列</font></li>\n<li>其中数据元素的个数n定义为表的长度</li>\n<li>当n=0时称为空表</li>\n<li>数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同</li>\n</ul>\n<p><font color=\"red\">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font></p>\n<h4 id=\"线性表的逻辑特征\"><a href=\"#线性表的逻辑特征\" class=\"headerlink\" title=\"线性表的逻辑特征\"></a><strong>线性表的逻辑特征</strong></h4><ol>\n<li>非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继</li>\n<li>有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱</li>\n<li>其余的内部结点有且只有一个直接前驱和一个直接后继</li>\n</ol>\n<p><font color=\"red\">线性表是一种典型的线性结构</font></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></li>\n<li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</li>\n<li>从具体应用中抽象处共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></li>\n</ul>\n<h4 id=\"顺序表的类型定义\"><a href=\"#顺序表的类型定义\" class=\"headerlink\" title=\"顺序表的类型定义\"></a><strong>顺序表的类型定义</strong></h4><ul>\n<li>抽象数据类型线性表的定义如下：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT List&#123;</span><br><span class=\"line\">\t数据对象：D = &#123;ai|ai∈Elemset,(i=<span class=\"number\">1</span>,<span class=\"number\">2</span>,...,n,n&gt;=<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">\t数据关系：R = &#123;&lt;ai<span class=\"number\">-1</span>,ai&gt;|ai<span class=\"number\">-1</span>,ai∈D,(i=<span class=\"number\">2</span>,<span class=\"number\">3</span>,...n)&#125;    <span class=\"comment\">//这里的ai中的i都是下标</span></span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t<span class=\"built_in\">InitList</span>(&amp;L);</span><br><span class=\"line\">\t<span class=\"built_in\">ListInsert</span>(&amp;L,i,e);</span><br><span class=\"line\">\t<span class=\"built_in\">DestroyList</span>(&amp;L);</span><br><span class=\"line\">\t<span class=\"built_in\">ListDelete</span>(&amp;L,i,&amp;e);</span><br><span class=\"line\">\t......等等</span><br><span class=\"line\">&#125;ADT List</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵基本操作\"><a href=\"#🎵基本操作\" class=\"headerlink\" title=\"🎵基本操作\"></a>🎵基本操作</h3><ul>\n<li><p>InitList(&amp;L)   (Initiallization List)</p>\n<ul>\n<li>操作结果：构造一个空的线性表L</li>\n</ul>\n</li>\n<li><p>DestroyList(&amp;L)</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：销毁线性表L</p>\n</li>\n</ul>\n</li>\n<li><p>ClearList(&amp;L)</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：将线性表L重置为空表</p>\n</li>\n</ul>\n</li>\n<li><p>ListEmpty(L);</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE</p>\n</li>\n</ul>\n</li>\n<li><p>ListLength(L</p>\n<ul>\n<li><p>初始条件：线性表L已经存在</p>\n</li>\n<li><p>操作结果：返回线性表L中的数据元素的个数</p>\n</li>\n</ul>\n</li>\n<li><p>GetElem(L,i,&amp;e)</p>\n<ul>\n<li>初始条件：线性表L已经存在，1 &lt;= i &lt;= ListLength(L)</li>\n<li>操作结果：用e返回线性表L中第i个数据元素的值</li>\n</ul>\n</li>\n<li><p>LocateElem(L,e,compare())</p>\n<ul>\n<li>初始条件：线性表L已经存在，compare()是数据元素判定函数</li>\n<li>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0</li>\n</ul>\n</li>\n<li><p>PriorElem(L,cur_e,&amp;pre_e)</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义</li>\n</ul>\n</li>\n<li><p>NextElem(L,cur_e,&amp;next_e)</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义</li>\n</ul>\n</li>\n<li><p>ListInsert(&amp;L,i,e)</p>\n<ul>\n<li>初始条件：线性表L已经存在， 1 &lt;= i&lt;= ListLength(L) + 1</li>\n<li>操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1</li>\n</ul>\n</li>\n<li><p>ListDelete(&amp;L,i,&amp;e)</p>\n<ul>\n<li>初始条件：线性表L已经存在， 1 &lt;= i&lt;= ListLength(L) </li>\n<li>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一</li>\n</ul>\n</li>\n<li><p>ListTraverse(&amp;L,visited())</p>\n<ul>\n<li>初始条件：线性表L已经存在</li>\n<li>操作结果：依次对线性表中每个元素调用visited()</li>\n</ul>\n</li>\n</ul>\n<p><strong>以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。</strong></p>\n<h3 id=\"🎵线性表的顺序存储表示\"><a href=\"#🎵线性表的顺序存储表示\" class=\"headerlink\" title=\"🎵线性表的顺序存储表示\"></a>🎵线性表的顺序存储表示</h3><p>顺序表的顺序表示又称为<font color=\"red\">顺序存储结构</font>或<font color=\"red\">顺序映像</font></p>\n<h4 id=\"顺序存储定义\"><a href=\"#顺序存储定义\" class=\"headerlink\" title=\"顺序存储定义\"></a><font color=\"red\"><strong>顺序存储定义</strong></font></h4><p>把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构</p>\n<ul>\n<li><p>依次存储，地址连续——中间<font color=\"red\">没有空出存储单元</font></p>\n</li>\n<li><p>线性表顺序存储结构<font color=\"red\">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置</p>\n</li>\n</ul>\n<h4 id=\"顺序表中元素存储位置的计算\"><a href=\"#顺序表中元素存储位置的计算\" class=\"headerlink\" title=\"顺序表中元素存储位置的计算\"></a><strong>顺序表中元素存储位置的计算</strong></h4><ul>\n<li><p>假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color=\"red\">LOC(a<del>i+1</del>) = LOC(a<del>i</del>) + K</font></p>\n</li>\n<li><p>所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color=\"red\">LOC(a<del>i</del>) = LOC(a<del>1</del>) + (i-1) * K </font>。其中<font color=\"red\">LOC(a<del>1</del>) </font>称为<font color=\"red\">基地址</font>。</p>\n</li>\n</ul>\n<h4 id=\"顺序表的特点\"><a href=\"#顺序表的特点\" class=\"headerlink\" title=\"顺序表的特点\"></a><strong>顺序表的特点</strong></h4><p><font color=\"red\">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）</p>\n<p>顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color=\"red\">用一维数组表示顺序表</font></p>\n<p>但线性表长度可变（删除），数组长度不可动态定义</p>\n<p>一维数组定义方式：<code>类型说明符 数组名[常量表达式]</code></p>\n<p>说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color=\"red\">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。</p>\n<h4 id=\"定义顺序表类型\"><a href=\"#定义顺序表类型\" class=\"headerlink\" title=\"定义顺序表类型\"></a><strong>定义顺序表类型</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define MAXSIZE 100</span><br><span class=\"line\">typedef struct&#123;</span><br><span class=\"line\">\tElemType *elem;</span><br><span class=\"line\">\tint length;</span><br><span class=\"line\">&#125;SqList;  //定义数据表类型</span><br><span class=\"line\"></span><br><span class=\"line\">SqList L; //定义变量L</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵顺序表基本操作的实现\"><a href=\"#🎵顺序表基本操作的实现\" class=\"headerlink\" title=\"🎵顺序表基本操作的实现\"></a><strong>🎵顺序表基本操作的实现</strong></h3><h4 id=\"操作算法中用到的预定义常量和类型\"><a href=\"#操作算法中用到的预定义常量和类型\" class=\"headerlink\" title=\"操作算法中用到的预定义常量和类型\"></a>操作算法中用到的预定义常量和类型</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数结果状态代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFEASIBLE -1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OVERFLOW -2</span></span><br><span class=\"line\"><span class=\"comment\">//Status 是函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"线性表L的初始化\"><a href=\"#线性表L的初始化\" class=\"headerlink\" title=\"线性表L的初始化\"></a>线性表L的初始化</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL.elem = <span class=\"keyword\">new</span> ElemType[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!L.elem)<span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tL.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁线性表\"><a href=\"#销毁线性表\" class=\"headerlink\" title=\"销毁线性表\"></a>销毁线性表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestoryList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.elem) <span class=\"keyword\">delete</span> L.elem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空线性表\"><a href=\"#清空线性表\" class=\"headerlink\" title=\"清空线性表\"></a>清空线性表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ClearList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"求线性表长度\"><a href=\"#求线性表长度\" class=\"headerlink\" title=\"求线性表长度\"></a>求线性表长度</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLength</span><span class=\"params\">(SqList L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(L.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"判断线性表L是否为空\"><a href=\"#判断线性表L是否为空\" class=\"headerlink\" title=\"判断线性表L是否为空\"></a>判断线性表L是否为空</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(SqList L)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表取值\"><a href=\"#顺序表取值\" class=\"headerlink\" title=\"顺序表取值\"></a>顺序表取值</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetElem</span><span class=\"params\">(SqList L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>||i&gt;L.length) <span class=\"keyword\">return</span> ERROR;  <span class=\"comment\">//判断i的值是否合理</span></span><br><span class=\"line\">\te = L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表的查找\"><a href=\"#顺序表的查找\" class=\"headerlink\" title=\"顺序表的查找\"></a>顺序表的查找</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem</span><span class=\"params\">(SqList L,ElemType e)</span></span>&#123;     <span class=\"comment\">//查找值为e的元素，返回其序号</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;L.length;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L.elem[i] == e) <span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>顺序表的查找算法分析</strong></p>\n<p>平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。</p>\n<ul>\n<li>用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加</li>\n</ul>\n<p>(1/n)*[(n+1)(n) / 2]</p>\n<p>顺序表查找的时间复杂度为O（n）</p>\n<h4 id=\"顺序表的删除\"><a href=\"#顺序表的删除\" class=\"headerlink\" title=\"顺序表的删除\"></a>顺序表的删除</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L,<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((i&lt;<span class=\"number\">1</span>)||(i&gt;L.length)) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=i;j&lt;=L.length;j++)&#123;</span><br><span class=\"line\">\t\tL.elem[j<span class=\"number\">-1</span>]=L.elem[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL.length--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序表的删除算法分析\"><a href=\"#顺序表的删除算法分析\" class=\"headerlink\" title=\"顺序表的删除算法分析\"></a><strong>顺序表的删除算法分析</strong></h4><p>(1/n)*[(n-1)n / 2]</p>\n<p>顺序表删除的时间复杂度O（n）</p>\n<h3 id=\"🎵线性表的链式存储表示\"><a href=\"#🎵线性表的链式存储表示\" class=\"headerlink\" title=\"🎵线性表的链式存储表示\"></a>🎵线性表的链式存储表示</h3><ul>\n<li>用一组<font color=\"red\">物理位置任意的存储单元</font>来存放线性表的数据元素</li>\n<li>这组存储单元既可以是<font color=\"red\">连续</font>的，也可以是<font color=\"red\">不连续</font>的，甚至是零散分布在内存中的任意位置上的</li>\n<li>链表中元素的<font color=\"red\">逻辑次序和物理次序不一定相同</font></li>\n</ul>\n<h4 id=\"与链式存储有关的术语\"><a href=\"#与链式存储有关的术语\" class=\"headerlink\" title=\"与链式存储有关的术语\"></a><strong>与链式存储有关的术语</strong></h4><ol>\n<li><font color=\"red\">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成</li>\n<li><font color=\"red\">链表：</font>n个结点由<font color=\"red\">指针链</font>组成一个链表</li>\n<li><font color=\"red\">单链表、双链表、循环链表：</font><ul>\n<li>结点只有一个指针域的链表，称为单链表或线性链表</li>\n<li>结点有两个指针域的链表，称为双链表</li>\n<li>首尾相接的链表称为循环链表</li>\n</ul>\n</li>\n<li><font color=\"red\">头指针、头结点、首元结点</font></li>\n</ol>\n<h4 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a><font color=\"red\"><strong>讨论</strong></font></h4><p><strong>如何表示空表？</strong></p>\n<ul>\n<li>无头结点时，<font color=\"red\">头指针为空</font>表示空表</li>\n<li>有头结点时，<font color=\"red\">当头结点的指针域为空时</font>表示空表</li>\n</ul>\n<p><strong>在链表中设置<font color=\"red\">头结点</font>有什么好处？</strong></p>\n<ul>\n<li>便于<font color=\"red\">首元结点</font>的处理</li>\n<li>便于<font color=\"red\">空表与非空表</font>的统一处理</li>\n</ul>\n<p><strong>头结点的<font color=\"red\">数据域</font>中装的是什么？</strong></p>\n<p>头结点的<font color=\"red\">数据域</font>可以为空，也可以存放线性<font color=\"red\">表长度</font>等附加信息，但此结点不能计入链表长度</p>\n<h4 id=\"链表（链式存储结构）的特点\"><a href=\"#链表（链式存储结构）的特点\" class=\"headerlink\" title=\"链表（链式存储结构）的特点\"></a><font color=\"red\">链表（链式存储结构）的特点</font></h4><ol>\n<li>结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻</li>\n<li>访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等</li>\n</ol>\n<p>这种数据元素的存储方法称为<font color=\"red\">顺序存取法</font></p>\n<h4 id=\"单链表的定义和表示\"><a href=\"#单链表的定义和表示\" class=\"headerlink\" title=\"单链表的定义和表示\"></a>单链表的定义和表示</h4><p>单链表是<font color=\"red\">由表头</font>唯一确定，因此单链表可以用<font color=\"red\">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color=\"red\">表L</font>。</p>\n<p><strong>单链表的存储结构：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Lnode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Lnode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Lnode,*LinkList;</span><br></pre></td></tr></table></figure>\n\n<p>虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color=\"red\">LinkList L 创建链表</font>，用<font color=\"red\">Lnode *p 来创建指向结点的指针</font>。</p>\n<h3 id=\"🎵单链表基本操作的实现\"><a href=\"#🎵单链表基本操作的实现\" class=\"headerlink\" title=\"🎵单链表基本操作的实现\"></a>🎵单链表基本操作的实现</h3><h4 id=\"单链表的初始化\"><a href=\"#单链表的初始化\" class=\"headerlink\" title=\"单链表的初始化\"></a>单链表的初始化</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_L</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL = <span class=\"keyword\">new</span> LNode;   <span class=\"comment\">//从内存中申请一个存放LNode类型的空间，L指向它</span></span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"判断链表是否为空\"><a href=\"#判断链表是否为空\" class=\"headerlink\" title=\"判断链表是否为空\"></a>判断链表是否为空</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListEmpty</span><span class=\"params\">(LinkList L)</span></span>&#123;\t<span class=\"comment\">//若表为空，返回1；不为空，返回0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L-&gt;next)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//非空</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的销毁\"><a href=\"#单链表的销毁\" class=\"headerlink\" title=\"单链表的销毁\"></a>单链表的销毁</h4><p>从头指针开始，依次释放所有结点</p>\n<p>用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestoryList_L</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tLNode *P;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(L)&#123;</span><br><span class=\"line\">\t\tp = L;</span><br><span class=\"line\">\t\tL = L-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"清空单链表\"><a href=\"#清空单链表\" class=\"headerlink\" title=\"清空单链表\"></a>清空单链表</h4><p>链表仍存在，但链表中没有元素，只有头指针和头结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p, *q;</span><br><span class=\"line\">\tp = L-&gt;next;\t<span class=\"comment\">//p指向首元结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">\t\tq = p-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//头结点的指针域指向空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"求单链表表长\"><a href=\"#求单链表表长\" class=\"headerlink\" title=\"求单链表表长\"></a>求单链表表长</h4><ul>\n<li>头结点不计入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength_L</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tp = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表取值\"><a href=\"#单链表取值\" class=\"headerlink\" title=\"单链表取值\"></a>单链表取值</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem_L</span><span class=\"params\">(LinkList L;<span class=\"keyword\">int</span> i;ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//这里j&gt;i是指i为0或者负数的情况 !p有两种情况</span></span><br><span class=\"line\">\te = p-&gt;data;\t\t\t\t<span class=\"comment\">//1.链表为空  2.i的值大于链表长度p指向空了\t\t</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的按值查找\"><a href=\"#单链表的按值查找\" class=\"headerlink\" title=\"单链表的按值查找\"></a>单链表的按值查找</h4><p>返回指针（地址）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Lnode *<span class=\"title\">LocateElem_L</span><span class=\"params\">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回<font color=\"red\">位置序号</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem_L</span><span class=\"params\">(LinkList L,Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p) <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单链表的插入\"><a href=\"#单链表的插入\" class=\"headerlink\" title=\"单链表的插入\"></a>单链表的插入</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_L</span><span class=\"params\">(LinkList &amp;L,ElemType e,<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ts = <span class=\"keyword\">new</span> Lnode;s-&gt;data = e;\t<span class=\"comment\">//这里一定要用new一块内存空间 如果只Lnode一个结点</span></span><br><span class=\"line\">\ts-&gt;next = p-&gt;next;\t\t\t<span class=\"comment\">//只是一个函数中的临时变量</span></span><br><span class=\"line\">\tp-&gt;next = s;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单链表的删除</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_L</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;p = L;<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;Lnode *q;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p || j&gt;i<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tq = p-&gt;next;</span><br><span class=\"line\">\te = p-&gt;next-&gt;data;</span><br><span class=\"line\">\tp-&gt;next = p-&gt;next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"单链表的查找、插入、删除算法时间效率分析\"><a href=\"#单链表的查找、插入、删除算法时间效率分析\" class=\"headerlink\" title=\"单链表的查找、插入、删除算法时间效率分析\"></a>单链表的查找、插入、删除算法时间效率分析</h4><ol>\n<li>查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color=\"red\">O（n）</font></li>\n<li>插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color=\"red\">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color=\"red\">O（n）</font></li>\n</ol>\n<h4 id=\"建立单链表\"><a href=\"#建立单链表\" class=\"headerlink\" title=\"建立单链表\"></a>建立单链表</h4><ul>\n<li>头插法：元素插在链表的头部(倒位序)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateList_H</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;</span><br><span class=\"line\">\tL = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=n;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\tp = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">\t\tcin&gt;&gt;p-&gt;data;</span><br><span class=\"line\">\t\tp-&gt;next = L-&gt;next;</span><br><span class=\"line\">\t\tL-&gt;next = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>尾插法：元素插在链表的尾部(正位序)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateList_R</span><span class=\"params\">(LinkList &amp;L,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tLnode *p;Lnode *r;\t\t<span class=\"comment\">//需要创建一个指针来指向尾结点</span></span><br><span class=\"line\">    L = <span class=\"keyword\">new</span> Lnode;L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    r = L;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        p = <span class=\"keyword\">new</span> Lnode;</span><br><span class=\"line\">        cin&gt;&gt;p-&gt;data;</span><br><span class=\"line\">        p-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        r-&gt;next = p;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵循环链表\"><a href=\"#🎵循环链表\" class=\"headerlink\" title=\"🎵循环链表\"></a>🎵循环链表</h3><p>定义：是一种头尾相接的链表（表中最后一个结点指向<font color=\"red\">头结点</font>）</p>\n<p>优点：可以从表中任意结点出发均可找到表中其他结点</p>\n<p>注意：</p>\n<ol>\n<li>由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p-&gt;next是否为空，而是<font color=\"red\">判断它们是否等于头指针</font></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p != L;</span><br><span class=\"line\">p-&gt;next != NULL;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>表的操作常常是在表的首尾进行</p>\n<p>若用头指针表示单循环链表，寻找a<del>n</del>的时间复杂度为O（n），不方便</p>\n<p>所以经常用尾指针来表示单循环链表,使得寻找a<del>1</del>和a<del>n</del>的时间复杂度都为O（1）</p>\n<p>a<del>1</del>的存储位置：R-&gt;next-&gt;next</p>\n<p>a<del>n</del>的存储位置：R</p>\n</li>\n</ol>\n<p><strong>带尾指针的循环链表的合并</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">Connect</span><span class=\"params\">(LinkList Ta,LinkList Tb)</span></span>&#123;</span><br><span class=\"line\">\tp = Ta-&gt;next;\t\t\t\t<span class=\"comment\">//存储表头结点</span></span><br><span class=\"line\">\tTa-&gt;next = Tb-&gt;next-&gt;next;\t<span class=\"comment\">//Tb表头连接Ta表尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> Tb-&gt;next;\t\t\t<span class=\"comment\">//释放Tb表头结点</span></span><br><span class=\"line\">\tTb-&gt;next = p;\t\t\t\t<span class=\"comment\">//修改指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Tb;\t\t\t\t\t<span class=\"comment\">//因为return了新的表尾  所以形参不用引用符号</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"🎵双向链表\"><a href=\"#🎵双向链表\" class=\"headerlink\" title=\"🎵双向链表\"></a>🎵双向链表</h3><p>定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表</p>\n<p>双向链表的结构可定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct DuLnode&#123;</span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\tstruct DuLnode *prior,*next;</span><br><span class=\"line\">&#125;DuLnode,*DuLinkList;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双向链表的插入\"><a href=\"#双向链表的插入\" class=\"headerlink\" title=\"双向链表的插入\"></a>双向链表的插入</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListInsert_DuL</span><span class=\"params\">(DuLinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(p = <span class=\"built_in\">GetElemP_DuL</span>(L,i))) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//用p指向第i个结点</span></span><br><span class=\"line\">\tDuLnode *s;</span><br><span class=\"line\">\ts = <span class=\"keyword\">new</span> DuLnode;</span><br><span class=\"line\">\ts-&gt;data = e;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ts-&gt;prior = p-&gt;prior;</span><br><span class=\"line\">\tp-&gt;prior-&gt;next = s;</span><br><span class=\"line\">\ts-&gt;next = p;</span><br><span class=\"line\">\tp-&gt;prior = s;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双向链表的删除\"><a href=\"#双向链表的删除\" class=\"headerlink\" title=\"双向链表的删除\"></a>双向链表的删除</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListDelete_DuL</span><span class=\"params\">(DuLinkList &amp;L,<span class=\"keyword\">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(p = <span class=\"built_in\">GetElemP_DuL</span>(L,i))) <span class=\"keyword\">return</span> ERROR;\t<span class=\"comment\">//寻找第i个元素的时间复杂度O(n)</span></span><br><span class=\"line\">\te = p-&gt;data;</span><br><span class=\"line\">\tp-&gt;prior-&gt;next = p-&gt;next;\t<span class=\"comment\">//删除元素所需要的时间复杂度为 O(1)</span></span><br><span class=\"line\">\tp-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🎵单链表、循环链表和双向链表的时间效率比较\"><a href=\"#🎵单链表、循环链表和双向链表的时间效率比较\" class=\"headerlink\" title=\"🎵单链表、循环链表和双向链表的时间效率比较\"></a>🎵单链表、循环链表和双向链表的时间效率比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>查找首元结点</th>\n<th>查表表尾结点</th>\n<th>查找结点*p的前驱结点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>带头结点的单链表L</td>\n<td>L-&gt;next 时间复杂度O(1)</td>\n<td>从L-&gt;next依次向后遍历 时间复杂度O(n)</td>\n<td>通过p-&gt;next无法找到前驱</td>\n</tr>\n<tr>\n<td>带头结点且仅设头指针L的循环单链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>从L-&gt;next依次向后遍历 时间复杂度O(n)</td>\n<td>通过p-&gt;next可以找到前驱 时间复杂度O(n)</td>\n</tr>\n<tr>\n<td>带头结点且仅设尾指针R的循环单链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>R 时间复杂度O(1)</td>\n<td>通过p-&gt;next可以找到前驱 时间复杂度O(n)</td>\n</tr>\n<tr>\n<td>带头结点的双向循环链表</td>\n<td>R-&gt;next 时间复杂度O(1)</td>\n<td>R 时间复杂度O(1)</td>\n<td>p-&gt;prior 时间复杂度O(1)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>带头结点的双向循环链表，本质上还是用空间换取时间效率</li>\n</ul>\n<h3 id=\"🎵线性表的应用\"><a href=\"#🎵线性表的应用\" class=\"headerlink\" title=\"🎵线性表的应用\"></a>🎵线性表的应用</h3><h4 id=\"线性表的合并\"><a href=\"#线性表的合并\" class=\"headerlink\" title=\"线性表的合并\"></a>线性表的合并</h4><p>思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(SqList &amp;La,SqList Lb)</span></span>&#123;</span><br><span class=\"line\">\tLa_len = <span class=\"built_in\">ListLength</span>(La);</span><br><span class=\"line\">\tLb_len = <span class=\"built_in\">ListLength</span>(Lb);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">GetElem</span>(Lb,i,e);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">LocateElem</span>(La,e)) <span class=\"built_in\">ListInsert</span>(&amp;La,++La_len,e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )</li>\n</ul>\n<h4 id=\"有序表的合并\"><a href=\"#有序表的合并\" class=\"headerlink\" title=\"有序表的合并\"></a>有序表的合并</h4><ul>\n<li>顺序表的实现</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_Sq</span><span class=\"params\">(SqList La,SqList Lb,SqList &amp;Lc)</span></span>&#123;</span><br><span class=\"line\">\tElemType *pa,*pb,*pc;</span><br><span class=\"line\">\tElemType *La_last,*Lb_last;\t\t\t\t<span class=\"comment\">//指针类型要和元素类型对应</span></span><br><span class=\"line\">\tpa = La.elem;\t\t\t\t\t\t\t<span class=\"comment\">//分别指向两个顺序表第一个元素的指针</span></span><br><span class=\"line\">\tpb = Lb.elem;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLc.length = La.length + Lb.length;</span><br><span class=\"line\">\tLc.elem = <span class=\"keyword\">new</span> ElemType[Lc.length];\t\t<span class=\"comment\">//为新表分配一个数组空间</span></span><br><span class=\"line\">\tpc = Lc.elem;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpa_last = La.elem + La.length - <span class=\"number\">1</span>;\t\t<span class=\"comment\">//分别指向表中的最后一个元素</span></span><br><span class=\"line\">\tpb_last = Lb.elem + Lb.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;\t<span class=\"comment\">//两个表都非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> *pc++ = *pb++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &lt;= pa_last) *pc++ = *pa++;\t\t<span class=\"comment\">//将剩余元素填入表c</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和</p>\n<p>算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) </p>\n<ul>\n<li>链表实现</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_L</span><span class=\"params\">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class=\"line\">\tLnode *pa,*pb,*pc;</span><br><span class=\"line\">\tpa = La-&gt;next;\tpb = Lb-&gt;next;\t\t<span class=\"comment\">//分别指向La和Lb的首元结点</span></span><br><span class=\"line\">\tpc = Lc = La;\t<span class=\"comment\">//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>(pc-&gt;next = pb; pc = pb; pb = pb-&gt;next;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//当La和Lb有一个表填完</span></span><br><span class=\"line\">\tpc-&gt;next = pa ? pa:pb;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//释放Lb的头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> Lb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的</p>\n<p>算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到</p>\n<h3 id=\"🎵补充\"><a href=\"#🎵补充\" class=\"headerlink\" title=\"🎵补充\"></a><strong>🎵补充</strong></h3><h4 id=\"数组定义\"><a href=\"#数组定义\" class=\"headerlink\" title=\"数组定义\"></a><strong>数组定义</strong></h4><p>数组静态分布</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[maxsize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n<p>数组动态分布</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType *data;\t<span class=\"comment\">//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;\t\t<span class=\"comment\">//来存放数组的首地址</span></span><br><span class=\"line\">&#125;SqList;</span><br><span class=\"line\"></span><br><span class=\"line\">SqList L;</span><br><span class=\"line\">L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(ElemType)*maxsize);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"C语言动态存储分配\"><a href=\"#C语言动态存储分配\" class=\"headerlink\" title=\"C语言动态存储分配\"></a><strong>C语言动态存储分配</strong></h4><p>对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。</p>\n<p><font color=\"red\">需要加载头文件：&lt;stdlib.h&gt;</font>(C语言)</p>\n<h4 id=\"C-的动态存储分配\"><a href=\"#C-的动态存储分配\" class=\"headerlink\" title=\"C++的动态存储分配\"></a><strong>C++的动态存储分配</strong></h4><p><code>new 类型名T(初值列表)</code></p>\n<p>功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值</p>\n<p>成功：T类型的指针，指向新分配的内存</p>\n<p>失败：0（NULL）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;\t\t<span class=\"comment\">//不赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">10</span>);\t<span class=\"comment\">//赋初值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>delete 指针p</code></p>\n<p>功能：释放指针P所指向的内存。P必须是new操作的返回值。</p>\n<h4 id=\"C-中的参数传递\"><a href=\"#C-中的参数传递\" class=\"headerlink\" title=\"C++中的参数传递\"></a><strong>C++中的参数传递</strong></h4><ul>\n<li>函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序</li>\n<li>参数传递有两种方式<ul>\n<li>传值方式（参数为整型、实型、字符型等）</li>\n<li>传地址<ul>\n<li>参数为指针变量</li>\n<li>参数为引用类型</li>\n<li>参数为数组名</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-中-引用类型做参数\"><a href=\"#C-中-引用类型做参数\" class=\"headerlink\" title=\"C++中 引用类型做参数\"></a><strong>C++中 引用类型做参数</strong></h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;j = i;\t\t<span class=\"comment\">//引用类型,j作为i的一个替代名字，会随着i的改变而改变</span></span><br><span class=\"line\">\ti = <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">float</span> &amp;m,<span class=\"keyword\">float</span> &amp;n)</span> <span class=\"comment\">//这里的m和n与主函数中的实参用的是同一块空间</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> temp;</span><br><span class=\"line\">    temp = n;</span><br><span class=\"line\">    n = m;</span><br><span class=\"line\">    m = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"引用类型做形参的三种说明\"><a href=\"#引用类型做形参的三种说明\" class=\"headerlink\" title=\"引用类型做形参的三种说明\"></a><strong>引用类型做形参的三种说明</strong></h4><ol>\n<li><p>传递引用给函数与传递指针的效果是一样的，<font color=\"red\">形参变化实参也发生变化</font>。</p>\n</li>\n<li><p>引用类型做形参，在内存中并没有产生实参的副本，它<font color=\"red\">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color=\"red\">形参变量的值是实参变量的副本</font>。因此，当<font color=\"red\">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。</p>\n</li>\n<li><p>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。</p>\n</li>\n</ol>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><h3 id=\"栈和队列的定义和特点\"><a href=\"#栈和队列的定义和特点\" class=\"headerlink\" title=\"栈和队列的定义和特点\"></a>栈和队列的定义和特点</h3><ul>\n<li>栈和队列是两种常用的、重要的数据结构</li>\n<li>栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表</li>\n</ul>\n<p>栈</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Insert</span>(s,n+<span class=\"number\">1</span>,x)\t<span class=\"comment\">//插入和删除只能在表尾进行</span></span><br><span class=\"line\"><span class=\"built_in\">Delete</span>(s,n)</span><br></pre></td></tr></table></figure>\n\n<p>队列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Insert</span>(q,n+<span class=\"number\">1</span>,x)\t<span class=\"comment\">//插入在表尾进行</span></span><br><span class=\"line\"><span class=\"built_in\">Delete</span>(q,<span class=\"number\">1</span>)\t\t<span class=\"comment\">//删除在表头进行</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"栈的定义和特点\"><a href=\"#栈的定义和特点\" class=\"headerlink\" title=\"栈的定义和特点\"></a>栈的定义和特点</h3><p>栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表</p>\n<p>又称为<font color=\"red\">后进先出</font>(Last In First Out)的线性表，简称<font color=\"red\">LIFO</font>结构。</p>\n<p><strong>栈的相关概念</strong></p>\n<ul>\n<li><p>表尾（即a<del>n</del>端）称为<font color=\"red\">栈顶</font>Top；表头（即a<del>1</del>端）称为<font color=\"red\">栈底</font>Base</p>\n</li>\n<li><p>插入元素到栈顶（即表尾）的操作，称为<font color=\"red\">入栈</font>        PUSH</p>\n</li>\n<li><p>从栈顶删除一个元素的操作，称为<font color=\"red\">出栈</font>                    POP</p>\n</li>\n<li><p>逻辑结构：与线性表相同，仍为一对一关系</p>\n</li>\n<li><p>存储结构：用顺序栈或链栈均可，但以顺序栈更常见</p>\n</li>\n<li><p>运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则</p>\n</li>\n<li><p>实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同</p>\n</li>\n</ul>\n<p><font color=\"red\">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出</p>\n<h3 id=\"队列的定义和特点\"><a href=\"#队列的定义和特点\" class=\"headerlink\" title=\"队列的定义和特点\"></a>队列的定义和特点</h3><p>队列(queue)是一种<font color=\"red\">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除</p>\n<p><strong>队列的相关概念</strong></p>\n<ul>\n<li>逻辑结构：一对一</li>\n<li>存储结构：顺序队或链队，以循环队列更常见</li>\n<li>运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则</li>\n<li>实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同</li>\n</ul>\n<h3 id=\"栈的表示和实现\"><a href=\"#栈的表示和实现\" class=\"headerlink\" title=\"栈的表示和实现\"></a>栈的表示和实现</h3><h4 id=\"栈的抽象数据类型的类型定义\"><a href=\"#栈的抽象数据类型的类型定义\" class=\"headerlink\" title=\"栈的抽象数据类型的类型定义\"></a>栈的抽象数据类型的类型定义</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Stack&#123;</span><br><span class=\"line\">\t数据对象:</span><br><span class=\"line\">\t\tD = &#123;ai|ai∈ElemSet,i=<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.</span>...n,n&gt;=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">\t数据关系：</span><br><span class=\"line\">\t\tR1 = &#123;&lt;ai<span class=\"number\">-1</span>,ai&gt;|ai<span class=\"number\">-1</span>,ai∈D,i=<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4.</span>..n&#125;</span><br><span class=\"line\">\t\t约定an为栈顶，a1为栈底</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\t初始化、进栈、出栈、取栈顶元素等</span><br><span class=\"line\">&#125;ADT Stack</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"🍨顺序栈的表示和实现\"><a href=\"#🍨顺序栈的表示和实现\" class=\"headerlink\" title=\"🍨顺序栈的表示和实现\"></a>🍨顺序栈的表示和实现</h4><p>存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。</p>\n<ul>\n<li>附设<font color=\"red\">top</font>指针，指示栈顶元素在顺序栈中的位置</li>\n<li>另设<font color=\"red\">base</font>指针，指示栈底元素在顺序栈中的位置</li>\n</ul>\n<p><font color=\"red\">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font></p>\n<ul>\n<li>另外，用<font color=\"red\">stacksize</font>表示栈可用的最大容量</li>\n</ul>\n<p>空栈：base == top 是栈空标志</p>\n<p>栈满：top - base == stacksize</p>\n<p>栈满时的处理方法：</p>\n<ol>\n<li>报错，返回操作系统</li>\n<li>分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈</li>\n</ol>\n<p>使用数组作为顺序栈存储方式的特点：</p>\n<p>简单、方便，但易产生溢出</p>\n<ul>\n<li>上溢(overflow)：栈已经满，又要压入元素</li>\n<li>下溢(underflow)：栈已经空，又要弹出元素</li>\n</ul>\n<p>顺序栈的表示</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tSElemType *top;</span><br><span class=\"line\">\tSElemType *base;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stacksize;</span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的初始化\"><a href=\"#顺序栈的初始化\" class=\"headerlink\" title=\"顺序栈的初始化\"></a>顺序栈的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">\tS.base = <span class=\"keyword\">new</span> SElemType[MAXSIZE];\t<span class=\"comment\">//分配内存空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);\t\t\t<span class=\"comment\">//如果分配失败</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tS.top = S.base;\t\t\t\t\t\t<span class=\"comment\">//栈顶指针等于栈底指针</span></span><br><span class=\"line\">\tS.stacksize = MAXSIZE;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈判断栈是否为空\"><a href=\"#顺序栈判断栈是否为空\" class=\"headerlink\" title=\"顺序栈判断栈是否为空\"></a>顺序栈判断栈是否为空</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">StackEmpty</span><span class=\"params\">(SqStack s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == S.base)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求顺序栈长度\"><a href=\"#求顺序栈长度\" class=\"headerlink\" title=\"求顺序栈长度\"></a>求顺序栈长度</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackLength</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> S.top-S.base;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"清空顺序栈\"><a href=\"#清空顺序栈\" class=\"headerlink\" title=\"清空顺序栈\"></a>清空顺序栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearStack</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.base) S.top == S.base;\t<span class=\"comment\">//如果没有base就不用清空了；不用删除元素，令栈顶指</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;\t\t\t\t\t<span class=\"comment\">//针等于栈底指针就相当于栈为空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"销毁顺序栈\"><a href=\"#销毁顺序栈\" class=\"headerlink\" title=\"销毁顺序栈\"></a>销毁顺序栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestoryStack</span><span class=\"params\">(SqStack &amp;s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.base)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> S.base;</span><br><span class=\"line\">\t\tS.stacksize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tS.top = S.base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的入栈\"><a href=\"#顺序栈的入栈\" class=\"headerlink\" title=\"顺序栈的入栈\"></a>顺序栈的入栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top-S.base == stacksize) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t*S.top++ = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"顺序栈的出栈\"><a href=\"#顺序栈的出栈\" class=\"headerlink\" title=\"顺序栈的出栈\"></a>顺序栈的出栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == S.base)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = *--S.top;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"🍨链栈的表示\"><a href=\"#🍨链栈的表示\" class=\"headerlink\" title=\"🍨链栈的表示\"></a>🍨链栈的表示</h4><ul>\n<li>链栈是<font color=\"red\">运算受限</font>的单链表，只能在<font color=\"red\">链表头部</font>进行操作</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\tSElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode,*LinkStack;</span><br><span class=\"line\">LinkStack S;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>链表的头指针就是栈顶</li>\n<li>不需要头结点</li>\n<li>基本不存在栈满的情况</li>\n<li>空栈相当于头指针指向空</li>\n<li>插入和删除仅在栈顶处执行</li>\n</ul>\n<h5 id=\"链栈的初始化\"><a href=\"#链栈的初始化\" class=\"headerlink\" title=\"链栈的初始化\"></a>链栈的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitStack</span><span class=\"params\">(LinkStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空栈，栈顶指针置为空</span></span><br><span class=\"line\">\tS = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"判断链栈是否为空\"><a href=\"#判断链栈是否为空\" class=\"headerlink\" title=\"判断链栈是否为空\"></a>判断链栈是否为空</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">StackEmpty</span><span class=\"params\">(LinkStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链栈的入栈\"><a href=\"#链栈的入栈\" class=\"headerlink\" title=\"链栈的入栈\"></a>链栈的入栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class=\"line\">\tStackNode *p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> StackNode;</span><br><span class=\"line\">\tp-&gt;data = e;</span><br><span class=\"line\">\tp-&gt;next = S;</span><br><span class=\"line\">\tS = p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链栈的出栈\"><a href=\"#链栈的出栈\" class=\"headerlink\" title=\"链栈的出栈\"></a>链栈的出栈</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(LinkList &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = S-&gt;data;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tStacknode *p;</span><br><span class=\"line\">\tp = S;</span><br><span class=\"line\">\tS = S-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"取栈顶元素\"><a href=\"#取栈顶元素\" class=\"headerlink\" title=\"取栈顶元素\"></a>取栈顶元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SElemType <span class=\"title\">GetTop</span><span class=\"params\">(LinkStack S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S != <span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> S-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"栈与递归\"><a href=\"#栈与递归\" class=\"headerlink\" title=\"栈与递归\"></a>栈与递归</h3><h4 id=\"递归的定义\"><a href=\"#递归的定义\" class=\"headerlink\" title=\"递归的定义\"></a>递归的定义</h4><ul>\n<li>若一个对象部分地<font color=\"red\">包含它自己</font>，或者用它<font color=\"red\">给自己定义</font>，则称这个对象是递归的</li>\n<li>若一个过程<font color=\"red\">直接或间接地调用自己</font>，则称这个过程是递归过程</li>\n</ul>\n<h4 id=\"以下这三种情况常常用到递归方法\"><a href=\"#以下这三种情况常常用到递归方法\" class=\"headerlink\" title=\"以下这三种情况常常用到递归方法\"></a>以下这三种情况常常用到递归方法</h4><ol>\n<li>递归定义的数学函数<ul>\n<li>阶乘函数</li>\n<li>斐波那契数列</li>\n</ul>\n</li>\n<li>具有递归特性的数据结构<ul>\n<li>二叉树</li>\n<li>广义表</li>\n</ul>\n</li>\n<li>可递归求解的问题<ul>\n<li>迷宫问题</li>\n<li>汉诺塔问题</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"递归问题：用分治法求解\"><a href=\"#递归问题：用分治法求解\" class=\"headerlink\" title=\"递归问题：用分治法求解\"></a>递归问题：用分治法求解</h4><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p>\n<p>必备的三个条件：</p>\n<ol>\n<li>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的</li>\n<li>可以通过上述转化而使问题简化</li>\n<li>必须有一个明确的递归出口，或称递归边界</li>\n</ol>\n<h4 id=\"分治法求解递归问题算法的一般形式\"><a href=\"#分治法求解递归问题算法的一般形式\" class=\"headerlink\" title=\"分治法求解递归问题算法的一般形式\"></a>分治法求解递归问题算法的一般形式</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">p</span><span class=\"params\">(参数表)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(递归结束条件) 可直接求解步骤;\t<span class=\"comment\">//基本项</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">p</span> (较小的参数);\t<span class=\"comment\">//归纳项</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h4><p>调用前，系统完成：</p>\n<ol>\n<li>将<font color=\"red\">实参，返回地址</font>等传递给被调用函数</li>\n<li>为被调用函数的<font color=\"red\">局部变量</font>分配存储区</li>\n<li>将控制转移到被调用函数的<font color=\"red\">入口</font></li>\n</ol>\n<p>调用后，系统完成：</p>\n<ol>\n<li>保存被调用函数的计算<font color=\"red\">结果</font></li>\n<li>释放被调用函数的<font color=\"red\">数据区</font></li>\n<li>依照被调用函数保存的<font color=\"red\">返回地址</font>将控制转移到调用函数</li>\n</ol>\n<h4 id=\"多个函数嵌套调用\"><a href=\"#多个函数嵌套调用\" class=\"headerlink\" title=\"多个函数嵌套调用\"></a>多个函数嵌套调用</h4><p><font color=\"red\">遵循后调用的先返回</font></p>\n<h4 id=\"递归函数调用的实现\"><a href=\"#递归函数调用的实现\" class=\"headerlink\" title=\"递归函数调用的实现\"></a>递归函数调用的实现</h4><p>“层次”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主函数\t\t 0层</span><br><span class=\"line\">第1次调用\t1层</span><br><span class=\"line\">......\t\t</span><br><span class=\"line\">第i次调用\ti层</span><br></pre></td></tr></table></figure>\n\n<p>“递归工作栈”    ——递归程序运行期间使用的数据存储区</p>\n<p>“工作记录”        实际参数、局部变量、返回地址</p>\n<h4 id=\"递归的优缺点\"><a href=\"#递归的优缺点\" class=\"headerlink\" title=\"递归的优缺点\"></a>递归的优缺点</h4><p>优点：结构清晰，程序易读</p>\n<p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p>\n<p>递归——&gt;非递归</p>\n<p>方法1：尾递归、单向递归 ——&gt;循环结构</p>\n<p>方法2：自用<font color=\"red\">栈</font>模拟系统的运行时候栈</p>\n<h3 id=\"队列的表示和操作的实现\"><a href=\"#队列的表示和操作的实现\" class=\"headerlink\" title=\"队列的表示和操作的实现\"></a>队列的表示和操作的实现</h3><h4 id=\"队列的抽象数据类型定义\"><a href=\"#队列的抽象数据类型定义\" class=\"headerlink\" title=\"队列的抽象数据类型定义\"></a>队列的抽象数据类型定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Queue&#123;</span><br><span class=\"line\">\t数据对象：D = &#123;ai|ai∈Elemset,(i=1,2,...,n,n&gt;=0)&#125;</span><br><span class=\"line\">\t数据关系：R = &#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,(i=2,3,...n)&#125;    //这里的ai中的i都是下标</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\tInitQueue(&amp;Q);</span><br><span class=\"line\">\t\tDestroyQueue(&amp;Q);</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">&#125;ADT Queue</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"队列的顺序表示和实现\"><a href=\"#队列的顺序表示和实现\" class=\"headerlink\" title=\"队列的顺序表示和实现\"></a>队列的顺序表示和实现</h4><p>用一维数组base[MAXQSIZE]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXQSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tQElemType *base;\t<span class=\"comment\">//指向数组首地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;\t\t\t<span class=\"comment\">//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;\t\t\t<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>解决假上溢的方法：</strong></p>\n<ol>\n<li><p>将队中元素依次向队头方向移动</p>\n<p>缺点：浪费时间。每移动一次，队中元素都要移动</p>\n</li>\n<li><p>将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间</p>\n</li>\n</ol>\n<p>base[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；</p>\n<p>实现方法：利用<font color=\"red\">模运算（mod,c语言中：%）</font></p>\n<p><strong>区分队空和队满</strong></p>\n<ol>\n<li><p>另外设置一个标志来区分队空、队满</p>\n</li>\n<li><p>另设一个变量，记录元素个数</p>\n</li>\n<li><p><font color=\"red\">少用一个元素空间</font></p>\n<p>用第三种方法时：</p>\n<p>队空：front == rear</p>\n<p>队满：（rear+1）% MAXQSIZE == front            //无论对front下标在哪都适用</p>\n</li>\n</ol>\n<h5 id=\"队列的初始化\"><a href=\"#队列的初始化\" class=\"headerlink\" title=\"队列的初始化\"></a>队列的初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQ.base = <span class=\"keyword\">new</span> QElemType[MAXQSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求队列的长度\"><a href=\"#求队列的长度\" class=\"headerlink\" title=\"求队列的长度\"></a>求队列的长度</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"循环队列入队\"><a href=\"#循环队列入队\" class=\"headerlink\" title=\"循环队列入队\"></a>循环队列入队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(&amp;Q,QElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( (Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    Q.base[Q.rear] = e;</span><br><span class=\"line\">\tQ.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"循环队列出队\"><a href=\"#循环队列出队\" class=\"headerlink\" title=\"循环队列出队\"></a>循环队列出队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(&amp;Q,&amp;QElemType e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = Q.base[Q.front];</span><br><span class=\"line\">\tQ.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"取队头元素\"><a href=\"#取队头元素\" class=\"headerlink\" title=\"取队头元素\"></a>取队头元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">QElemType <span class=\"title\">GetHead</span><span class=\"params\">(Q)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front != Q.rear)\t<span class=\"keyword\">return</span> Q.base[front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"队列的链式表示和实现\"><a href=\"#队列的链式表示和实现\" class=\"headerlink\" title=\"队列的链式表示和实现\"></a>队列的链式表示和实现</h4><p>若用户无法估计所用队列的长度，宜采用链队列</p>\n<ul>\n<li>带头结点</li>\n</ul>\n<h5 id=\"链队列的类型定义\"><a href=\"#链队列的类型定义\" class=\"headerlink\" title=\"链队列的类型定义\"></a>链队列的类型定义</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXQSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Qnode</span>&#123;</span></span><br><span class=\"line\">\tQElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Qnode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Qnode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    QueuePtr front;\t\t<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    QueuePtr rear;\t\t<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列初始化\"><a href=\"#链队列初始化\" class=\"headerlink\" title=\"链队列初始化\"></a>链队列初始化</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"keyword\">new</span> Qnode;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!Q.front) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tQ.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列的销毁\"><a href=\"#链队列的销毁\" class=\"headerlink\" title=\"链队列的销毁\"></a>链队列的销毁</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestroyQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(Q.front)&#123;</span><br><span class=\"line\">\t\tp = Q.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> Q.front;</span><br><span class=\"line\">\t\tQ.front = p;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//这里Q.rear 没什么用，可以直接用它来代替p</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列入队\"><a href=\"#链队列入队\" class=\"headerlink\" title=\"链队列入队\"></a>链队列入队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType e)</span></span>&#123;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> Qnode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!p) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">\tp-&gt;data = e;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tQ.rear-&gt;next = p;</span><br><span class=\"line\">    Q.rear = p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"链队列出队\"><a href=\"#链队列出队\" class=\"headerlink\" title=\"链队列出队\"></a>链队列出队</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\tQnode *p;</span><br><span class=\"line\">\tp = Q.front-&gt;next;</span><br><span class=\"line\">\te = p-&gt;data;</span><br><span class=\"line\">\tQ.front-&gt;next = Q.front-&gt;next-&gt;next;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.rear == p) Q.rear = Q.front;\t<span class=\"comment\">//如果恰好删除的是尾结点，那么尾指针也指向</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"求链队列队头元素\"><a href=\"#求链队列队头元素\" class=\"headerlink\" title=\"求链队列队头元素\"></a>求链队列队头元素</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetHead</span><span class=\"params\">(LinkQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = Q.front-&gt;next-&gt;data;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h2><h3 id=\"串的定义\"><a href=\"#串的定义\" class=\"headerlink\" title=\"串的定义\"></a>串的定义</h3><p>串（string）：零个或多个任意字符组成的有限序列</p>\n<p>s = “a<del>1</del>a<del>2</del>···a<del>n</del>” (n&gt;=0)</p>\n<p>串名：s</p>\n<p>串值：a<del>1</del>到a<del>n</del></p>\n<p>串长：n</p>\n<p>空串：n=0    用∅表示</p>\n<p>子串：串中任意个连续字符组成的子序列称为该串的子串</p>\n<p>真子串：不包含自身的所有子串</p>\n<p>主串：包含子串的串</p>\n<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>\n<p>子串位置：子串中第一个字符在主串中的位置</p>\n<p>空格串：由一个或多个空格所构成的串，与空串不同</p>\n<p>串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等</p>\n<p>​                所有的空串都是相等的</p>\n<h3 id=\"串的类型定义\"><a href=\"#串的类型定义\" class=\"headerlink\" title=\"串的类型定义\"></a>串的类型定义</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT String&#123;</span><br><span class=\"line\">\t数据对象：字符</span><br><span class=\"line\">\t数据关系：序偶关系</span><br><span class=\"line\">\t基本操作：</span><br><span class=\"line\">\t\t1.串赋值</span><br><span class=\"line\">\t\t2.串比较</span><br><span class=\"line\">\t\t3.求串长</span><br><span class=\"line\">\t\t4.串连结</span><br><span class=\"line\">\t\t5.求子串</span><br><span class=\"line\">\t\t6.串拷贝</span><br><span class=\"line\">\t\t7.清空串</span><br><span class=\"line\">\t\t8.串判空</span><br><span class=\"line\">\t\t9.子串的位置</span><br><span class=\"line\">\t\t10.串替换</span><br><span class=\"line\">\t\t11.子串插入</span><br><span class=\"line\">\t\t12.子串删除</span><br><span class=\"line\">\t\t13.串销毁</span><br><span class=\"line\">&#125;ADT String</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h3><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）</p>\n<h4 id=\"串的顺序存储结构\"><a href=\"#串的顺序存储结构\" class=\"headerlink\" title=\"串的顺序存储结构\"></a>串的顺序存储结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLEN 255</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch[MAXLEN+<span class=\"number\">1</span>];\t<span class=\"comment\">//0号位置不用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length;</span><br><span class=\"line\">&#125;SString</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"串的链式存储结构\"><a href=\"#串的链式存储结构\" class=\"headerlink\" title=\"串的链式存储结构\"></a>串的链式存储结构</h4><p>与单链表类似    优点：操作方便        缺点：存储密度较低</p>\n<p>为了克服缺点，可将多个字符放在一个结点中，称为<font color=\"red\">块</font></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define CHUNKSIZE 80</span><br><span class=\"line\">typedef struct Chunk&#123;</span><br><span class=\"line\">\tchar ch[CHUNKSIZE];</span><br><span class=\"line\">\tstruct Chunk *next;</span><br><span class=\"line\">&#125;Chunk;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct&#123;</span><br><span class=\"line\">\tChunk *head,*tail;\t//串的头指针和尾指针</span><br><span class=\"line\">\tint curlen;\t\t\t//串的当前长度</span><br><span class=\"line\">&#125;LString;\t\t\t\t//字符串的块链结构</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"串的模式匹配算法\"><a href=\"#串的模式匹配算法\" class=\"headerlink\" title=\"串的模式匹配算法\"></a>串的模式匹配算法</h3><p>算法目的：确定主串中所含子串（模式串）第一次出现的位置</p>\n<p>算法应用：搜索引擎、拼写检查、语言翻译、数据压缩</p>\n<p>算法种类：BF算法、KMP算法</p>\n<h4 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h4><p>简单匹配算法，采用穷举法的思路</p>\n<p>算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配</p>\n<h5 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h5><p>Index (S,T,pos)</p>\n<ul>\n<li>将主串的第pos个字符和模式串的第一个字符比较</li>\n<li>若相等，继续逐个比较后续字符</li>\n<li>若不等，从主串的下一字符起，重新与模式串的第一个字符比较</li>\n<li>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功</li>\n<li>否则，匹配失败，返回值为0</li>\n</ul>\n<h5 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index_BF</span><span class=\"params\">(SString S,SString T，<span class=\"keyword\">int</span> pos)</span></span>&#123;\t<span class=\"comment\">//pos是从什么位置开始寻找</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=pos,j=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(S.ch[i] == T.ch[j])\t&#123;++i;++j;&#125;\t<span class=\"comment\">//主串和子串依次匹配下一个字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;j = <span class=\"number\">1</span>; i = i - j + <span class=\"number\">2</span>;&#125;\t\t<span class=\"comment\">//主串、子串回溯开始下一次匹配</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(j&gt;T.length) <span class=\"keyword\">return</span> i-T.length;\t\t<span class=\"comment\">//匹配成功返回第一个字符的下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t\t\t\t\t<span class=\"comment\">//匹配失败</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"算法时间复杂度\"><a href=\"#算法时间复杂度\" class=\"headerlink\" title=\"算法时间复杂度\"></a>算法时间复杂度</h5><p>主串长度为n，子串长度为m</p>\n<p>最好情况：O（m）</p>\n<p>最坏情况：O [ (n-m)*m + m ]    若 m&lt;&lt;n，则算法复杂度为 O (m * n)</p>\n<h4 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h4><p>该算法较BF有较大改进，从而算法效率有了某种程度的提高</p>\n<h5 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h5><p>利用已经<font color=\"red\">部分匹配</font>的结果而加快模式串的滑动速度</p>\n<p>且主串S的指针<font color=\"red\">i不必回溯</font>，可提速到<font color=\"red\">O（m+n）</font></p>\n<h5 id=\"next-j-数组\"><a href=\"#next-j-数组\" class=\"headerlink\" title=\"next[j]数组\"></a>next[j]数组</h5><p>表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置</p>\n<p>​                    max    </p>\n<p>next [j] =     0    当j=1时</p>\n<p>​                    1    其他情况</p>\n<h5 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index_KMP</span><span class=\"params\">(SString S,SString T，<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=pos,j=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(S.ch[i] == T.ch[j])\t&#123;++i;++j;&#125;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> \tj = next[j];\t\t<span class=\"comment\">//i不变，j后退 （与BF算法的区别）</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(j&gt;T.length) <span class=\"keyword\">return</span> i-T.length;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获得next[j]数组的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T,<span class=\"keyword\">int</span> &amp;next[])</span></span>&#123;</span><br><span class=\"line\">\ti = <span class=\"number\">1</span>;next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class=\"line\">\t\t\t++i;++j;</span><br><span class=\"line\">\t\t\tnext[i] = j;  <span class=\"comment\">//如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> j = next[j]; <span class=\"comment\">//如果不相等，变成重新再找前j个字符的最长公共前缀子串，再\t\t\t\t\t\t  //移下一位看是否相等</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解：</p>\n<p>[(7条消息) KMP算法原理描述，告诉你为什么要“j = next<a href=\"https://blog.csdn.net/Leycaner/article/details/108301195\">j]”_Leycaner的博客-CSDN博客_j=next[j]</a></p>\n<h5 id=\"next函数的改进\"><a href=\"#next函数的改进\" class=\"headerlink\" title=\"next函数的改进\"></a>next函数的改进</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_nextval</span><span class=\"params\">(SString T,<span class=\"keyword\">int</span> &amp;nextval[])</span></span>&#123;</span><br><span class=\"line\">\ti = <span class=\"number\">1</span>;nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;T.length)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class=\"line\">\t\t\t++i;++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(T.ch[i]!=T.ch[j]) nextval = j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\"> \t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> j = nextval[j]; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>按一定格式排列起来的具有<font color=\"red\">相同类型</font>的数据元素的集合</p>\n<p><strong>结论：</strong>线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展</p>\n<p><strong>特点：</strong>结构固定</p>\n<p><strong>数组基本操作：</strong>除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p>\n<h3 id=\"数组的抽象数据类型定义\"><a href=\"#数组的抽象数据类型定义\" class=\"headerlink\" title=\"数组的抽象数据类型定义\"></a>数组的抽象数据类型定义</h3><p><font color=\"red\">n维数组</font>的抽象数据类型</p>\n<p>ADT Array{</p>\n<p>​    数据对象： j<del>i</del> = 0,······,b<del>i</del>-1    i = 1,2,······n                n为数组的维数，b<del>i</del>为数组第i维的长度</p>\n<p>​                        D = {a<del>j1j2······jn</del>|a<del>j1j2······jn</del> ∈ElemSet}</p>\n<p>​    数据关系：</p>\n<p>​                        R1 = {&lt;a<del>j1······ji······jn</del>，a<del>j1······ji+1······jn</del>&gt;|0&lt;=j<del>k</del>&lt;=b<del>k</del>-1 , 1&lt;=k&lt;=n, 且k≠i, 0&lt;=j<del>i</del>&lt;=b<del>k</del>-2,</p>\n<p>​                                    &lt;a<del>j1······ji······jn</del>，a<del>j1······ji+1······jn</del>&gt;∈D ,i = 2,······,n}</p>\n<p>}</p>\n<p>基本操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.InitArray(&amp;A,n,bound1,...boundn)\t\t//n是维数，boundn是每一维的上界</span><br><span class=\"line\">2.DestoryArray(&amp;A)</span><br><span class=\"line\">3.Value(A,&amp;e,index1,...indexn)</span><br><span class=\"line\">4.Assign(A,&amp;e,index,...indexn)</span><br><span class=\"line\">&#125;ADT Array</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组的顺序存储\"><a href=\"#数组的顺序存储\" class=\"headerlink\" title=\"数组的顺序存储\"></a>数组的顺序存储</h3><p>数组特点：结构固定</p>\n<p>数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作</p>\n<p><font color=\"red\">所以：</font>一般都是用<font color=\"blue\">顺序存储结构</font>来表示数组</p>\n<p>注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的</p>\n<p><strong>一维数组</strong></p>\n<p>​                    LOC(0) = a                            i = 0</p>\n<p>LOC（i）=  </p>\n<p>​                    LOC(i-1) + L = a + i * L,        i &gt; 0</p>\n<p><strong>二维数组</strong></p>\n<p>两种存储方式：</p>\n<ol>\n<li>以行序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L             n列数  m行数</li>\n<li>以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L </li>\n</ol>\n<p><strong>三维数组</strong></p>\n<p>按 页/行/列 存放，页优先的顺序存储</p>\n<p>a[m1] [m2] [m3] 各维元素个数为m1,m2,m3</p>\n<p>下标为i<del>1</del>,i<del>2</del>,i<del>3</del>的数组元素的存储位置</p>\n<p>LOC ( i<del>1</del>,i<del>2</del>,i<del>3</del> ) = a + i<del>1</del> * m2 * m3 + i<del>2</del> * m3 + i<del>3</del></p>\n<h3 id=\"特殊矩阵的压缩存储\"><a href=\"#特殊矩阵的压缩存储\" class=\"headerlink\" title=\"特殊矩阵的压缩存储\"></a>特殊矩阵的压缩存储</h3><p>矩阵的常规存储：描述为二维数组</p>\n<p>矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1</p>\n<p>不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多</p>\n<p>矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间</p>\n<ol>\n<li><p>什么是压缩存储</p>\n<p>若多个数据元素的<font color=\"red\">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间</p>\n</li>\n<li><p>什么样的矩阵能够压缩</p>\n<p>一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等</p>\n</li>\n<li><p>什么叫稀疏矩阵</p>\n<p>矩阵中非零元素很少（一般少于5%）</p>\n</li>\n</ol>\n<h4 id=\"对称矩阵\"><a href=\"#对称矩阵\" class=\"headerlink\" title=\"对称矩阵\"></a>对称矩阵</h4><p><strong>特点：</strong>对角线上下两边都对称，即a<del>ij</del> = a<del>ji</del>  (1&lt;=i,j&lt;=n)</p>\n<p><strong>存储方法：</strong>只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间</p>\n<p><strong>存储结构：</strong></p>\n<p>可以<font color=\"red\">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中</p>\n<p>一维数组中的元素，它前面有多少个元素它就在第几个位置</p>\n<p>假如求 a<del>ij</del> 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1    （下三角）</p>\n<h4 id=\"三角矩阵\"><a href=\"#三角矩阵\" class=\"headerlink\" title=\"三角矩阵\"></a>三角矩阵</h4><p><strong>特点：</strong>对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c</p>\n<p><strong>存储方法：</strong>重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间</p>\n<p>​                    类似于对称矩阵</p>\n<h4 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h4><p><strong>特点：</strong>所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color=\"red\">对角矩阵</font></p>\n<p><strong>存储方法：</strong>用二维数组存储，每一个对角线上的所有元素存储为一行</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">8</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">-1</td>\n<td align=\"center\"></td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">8</td>\n<td align=\"center\">2</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">4</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">4</td>\n<td align=\"center\">7</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">8</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">5</td>\n<td align=\"center\">9</td>\n<td align=\"center\">6</td>\n<td align=\"center\">2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>其中主对角线存储在行标为0的行中</p>\n<h4 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h4><p>三元组法：三元组（i，j，a<del>ij</del>）唯一确定矩阵的一个非零元</p>\n<p>矩阵由所有三元组和矩阵维数（m，n）唯一确定</p>\n<p><strong>压缩存储原则：</strong>存各非零元的值、行列位置和矩阵的行列数</p>\n<p>1、顺序存储结构：三元组顺序表</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">i（行数）</th>\n<th align=\"center\">j（列数）</th>\n<th align=\"center\">v（元素值）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">6(总行数)</td>\n<td align=\"center\">6（总列数）</td>\n<td align=\"center\">8（非零元素总个数）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">-3</td>\n</tr>\n</tbody></table>\n<p>三元组顺序表又称<font color=\"red\">有序的双下标法</font></p>\n<p>优点：非零元在表中按行序有序存储，因此<font color=\"red\">便于进行依行顺序处理的矩阵运算</font></p>\n<p>缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找</p>\n<p>2.链式存储结构：十字链表</p>\n<p>优点：能够<font color=\"red\">灵活地插入</font>因运算而产生的新的非零元素，<font color=\"red\">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。</p>\n<p>表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）</p>\n<p>right：用于链接同一行中的下一个非零元素</p>\n<p>down：用于链接同一列中的下一个非零元素</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">头结点</th>\n<th align=\"center\">M.chead</th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">M.rhead</td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">结点</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h2><p>广义表（又称列表List）是n个元素的有限序列，其中每一个a<del>i</del>或者是<font color=\"red\">原子</font>或者是一个<font color=\"red\">广义表</font></p>\n<p>拓宽了的线性表就是广义表。</p>\n<h3 id=\"广义表的定义\"><a href=\"#广义表的定义\" class=\"headerlink\" title=\"广义表的定义\"></a>广义表的定义</h3><ul>\n<li>广义表通常记作：LS = （a<del>1</del>,a<del>2</del>,……,a<del>n</del>）</li>\n</ul>\n<p>​    其中：LS为表名，n为表的长度，每一个a<del>i</del>为表的元素</p>\n<ul>\n<li>习惯上，一般用大写字母表示广义表，小写字母表示原子</li>\n<li>表头：若LS非空，则其第一个元素a<del>1</del>就是表头，记作head（LS） = a<del>1</del> <font color=\"red\">注：</font>表头可以是原子或子表</li>\n<li>表尾：除表头之外<font color=\"red\">其他元素</font>组成的表，记作tail（LS） = （a<del>2</del>,……,a<del>n</del>） <font color=\"red\">注：</font>表尾不是最后一个元素，而是一个子表</li>\n</ul>\n<h3 id=\"广义表的性质\"><a href=\"#广义表的性质\" class=\"headerlink\" title=\"广义表的性质\"></a>广义表的性质</h3><ol>\n<li>广义表中的数据元素有相对 <font color=\"red\">次序</font>；一个直接前驱和一个直接后继</li>\n<li>广义表的<font color=\"red\">长度</font>定义为最外层所包含元素的个数</li>\n<li>广义表的<font color=\"red\">深度</font>定义为该广义表 <font color=\"blue\">展开后所含括号的重数；</font>  <font color=\"red\">注：</font>“原子”的深度为0；“空表”的深度为1</li>\n<li>广义表可以为其他广义表<font color=\"red\">共享</font></li>\n<li>广义表可以是一个 <font color=\"red\">递归</font>的表。<font color=\"red\">注：</font>递归表的深度是无穷值，长度是有限值</li>\n<li>广义表是<font color=\"red\">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表</li>\n</ol>\n<h3 id=\"广义表和线性表的区别\"><a href=\"#广义表和线性表的区别\" class=\"headerlink\" title=\"广义表和线性表的区别\"></a>广义表和线性表的区别</h3><p>广义表可以看成是线性表的推广，线性表是广义表的特例</p>\n<p>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构</p>\n<h3 id=\"广义表的基本运算\"><a href=\"#广义表的基本运算\" class=\"headerlink\" title=\"广义表的基本运算\"></a>广义表的基本运算</h3><ol>\n<li>求表头GetHead（L)，可以是一个原子也可以是一个子表</li>\n<li>求表尾GetTail（L)，一定是一个子表</li>\n</ol>\n<h3 id=\"广义表的存储\"><a href=\"#广义表的存储\" class=\"headerlink\" title=\"广义表的存储\"></a>广义表的存储</h3><p>因为表中元素的大小不固定，所以不用数组存储，一般用链表存储</p>\n<h2 id=\"⛄树和二叉树\"><a href=\"#⛄树和二叉树\" class=\"headerlink\" title=\"⛄树和二叉树\"></a>⛄树和二叉树</h2><h3 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h3><p>树（Tree）是n（n&gt;=0）个结点的有限集（递归定义）。</p>\n<p>若n=0，称为空树；</p>\n<p>若n&gt;0，则它满足如下两个条件：</p>\n<pre><code>1. 有且仅有一个特定的称为 根 的结点\n2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）\n3. \n</code></pre>\n<h3 id=\"树的基本术语\"><a href=\"#树的基本术语\" class=\"headerlink\" title=\"树的基本术语\"></a>树的基本术语</h3><p>结点：数据元素以及指向子树的分支</p>\n<p>根节点：非空树中无前驱结点的结点</p>\n<p>结点的度：结点拥有的子树数</p>\n<p>树的度：树内各结点的度的最大值</p>\n<p>叶子结点：度为0，也叫作终端节点</p>\n<p>分支结点：度不为0，非终端结点</p>\n<p>内部结点：根节点以外的分支结点</p>\n<p>结点的子树称为该结点的<font color=\"red\">孩子</font>，该结点称为孩子的<font color=\"red\">双亲</font></p>\n<p>拥有同一个双亲的结点称为<font color=\"red\">兄弟结点</font></p>\n<p>双亲在同一层但双亲不同的结点称为<font color=\"red\">堂兄弟结点</font></p>\n<p>结点的<font color=\"red\">祖先</font>：从根到该结点所经分支上的所有结点</p>\n<p>结点的<font color=\"red\">子孙</font>：以某结点为根的子树中的任一结点</p>\n<p>树的<font color=\"red\">深度</font>：树中结点的最大层次</p>\n<p><font color=\"red\">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）</p>\n<p><font color=\"red\">无序树：</font>树中结点的各子树无次序</p>\n<p><font color=\"red\">森林：</font>是m（m&gt;=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树</p>\n<h3 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h3><p>为什么要研究二叉树？</p>\n<p>答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。</p>\n<p><strong>定义</strong></p>\n<p>二叉树是n（n&gt;=0）个结点的有限集，它或者是空集，或者由一个<font color=\"blue\">根结点</font>及<font color=\"red\">两个互不相交</font>的分别称作这个根的<font color=\"blue\">左子树</font>和<font color=\"blue\">右子树</font>的二叉树组成。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>每个结点最多有两个孩子<font color=\"red\">（二叉树中不存在度大于2的结点）</font></li>\n<li>子树有左右之分，其次序不能颠倒</li>\n<li>二叉树可以是空集合，根可以有空的左子树或空的右子树</li>\n</ol>\n<p><font color=\"red\">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。</p>\n<h3 id=\"二叉树的抽象数据类型定义\"><a href=\"#二叉树的抽象数据类型定义\" class=\"headerlink\" title=\"二叉树的抽象数据类型定义\"></a>二叉树的抽象数据类型定义</h3><p><strong>二叉树的抽象数据类型定义</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT BinaryTree&#123;</span><br><span class=\"line\">\t数据对象D：D是具有相同特性的数据元素的集合</span><br><span class=\"line\">\t数据关系R：若D=∅，则R=∅</span><br><span class=\"line\">\t\t\t  若D≠∅，则R=&#123;H&#125;,H是如下二元关系</span><br><span class=\"line\">\t\t\t  1. root唯一//关于根的说明</span><br><span class=\"line\">\t\t\t  2. ......//子树不相交</span><br><span class=\"line\">\t\t\t  3. ......//关于数据元素的说明</span><br><span class=\"line\">\t\t\t  4. ......//关于左子树和右子树的说明</span><br><span class=\"line\">\t基本操作P：//至少有20个</span><br><span class=\"line\">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>\n\n<p><strong>比较重要的几个操作：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateBiTree(&amp;T,definition)</span><br><span class=\"line\">\t初始条件：definition给出二叉树T的定义\t//definition是指构造方式（先序...)</span><br><span class=\"line\">\t操作结果：按definition构造二叉树T</span><br><span class=\"line\">PreOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：先序遍历T，对每个结点访问一次</span><br><span class=\"line\">InOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：中序遍历T，对每个结点访问一次</span><br><span class=\"line\">PostOrderTraverse(T)</span><br><span class=\"line\">\t初始条件：二叉树T存在</span><br><span class=\"line\">\t操作结果：后序遍历T，对每个结点访问一次</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h3><p><font color=\"red\">性质1：</font>在二叉树的第i层上<font color=\"blue\">最多</font>有2^i-1^个结点（i&gt;=1）</p>\n<p><font color=\"red\">性质2：</font>深度为k的二叉树<font color=\"blue\">最多</font>有2^k^-1个结点（k&gt;=1）    <font color=\"red\">深度为k时至少有k个结点</font></p>\n<p><font color=\"red\">性质3：</font>对任意一颗二叉树T，如果其叶子数为n<del>0</del>，度为2的结点数为n<del>2</del>，则<font color=\"red\">n<del>0</del>=n<del>2</del>+1</font></p>\n<p>从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）</p>\n<p>从上往下：B = n<del>2</del> * 2 + n<del>1</del> * 1</p>\n<p>B = n<del>2</del> * 2 + n<del>1</del> * 1 =  n - 1</p>\n<p>n = n<del>2</del> * 2 + n<del>1</del> * 1 + 1</p>\n<p>又因为n = n<del>0</del> + n<del>1</del> + n<del>2</del>    两式相结合得到 n<del>0</del>=n<del>2</del>+1</p>\n<p><strong>两种特殊形式的二叉树</strong></p>\n<p><strong>满二叉树</strong></p>\n<p>一颗深度为k且有2^k^-1个结点的二叉树称为<font color=\"blue\">满二叉树</font></p>\n<p>特点：1. 每层都满    2. 叶子结点全部在最底层</p>\n<p>对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。</p>\n<ul>\n<li>满二叉树在同样深度的二叉树中<font color=\"red\">结点</font>个数最多</li>\n<li>满二叉树在同样深度的二叉树中<font color=\"red\">叶子结点</font>个数最多</li>\n</ul>\n<p><strong>完全二叉树</strong></p>\n<p>深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color=\"red\">一一对应</font>时，称为完全二叉树</p>\n<p>注：在满二叉树中，从最后一个结点开始<font color=\"red\">连续</font>去掉<font color=\"red\">任意</font>个结点，即是一棵完全二叉树</p>\n<p>特点：1. 叶子只可能分布在层次最大的两层上</p>\n<p>​            2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1</p>\n<p><font color=\"red\">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log<del>2</del>n ⌋ + 1        (完全二叉树结点n与深度k的关系)</p>\n<p><font color=\"red\">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log<del>2</del>n ⌋ + 1层，每层从左到右），则对任一结点i（1&lt;=i&lt;=n），有</p>\n<ol>\n<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其<font color=\"red\">双亲结点是⌊ i / 2 ⌋</font></li>\n<li>如果2i&gt;n，则结点i为叶子结点，无左孩子；否则，其<font color=\"red\">左孩子结点是2i</font></li>\n<li>如果2i + 1&gt;n，则结点i无右孩子；否则，其<font color=\"red\">右孩子结点是2i+1</font></li>\n</ol>\n<p>性质5表明了完全二叉树中<font color=\"red\">双亲结点编号</font>与<font color=\"red\">孩子结点编号</font>之间的关系</p>\n<p><font color=\"red\">性质6：</font></p>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><h4 id=\"二叉树的顺序存储\"><a href=\"#二叉树的顺序存储\" class=\"headerlink\" title=\"二叉树的顺序存储\"></a>二叉树的顺序存储</h4><p>按<font color=\"red\">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树顺序存储表示</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXTSIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> TElemType SqBiTree[MAXSIZE];\t<span class=\"comment\">//定义了一种数组类型，元素类型TElemType</span></span><br><span class=\"line\">SqBiTree bt;</span><br></pre></td></tr></table></figure>\n\n<p>若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0</p>\n<p>二叉树的顺序存储缺点：</p>\n<p>最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组</p>\n<p>结点间关系蕴含在其存储位置中，浪费空间，适于存<font color=\"red\">满二叉树和完全二叉树</font></p>\n<h4 id=\"二叉树的链式存储结构\"><a href=\"#二叉树的链式存储结构\" class=\"headerlink\" title=\"二叉树的链式存储结构\"></a>二叉树的链式存储结构</h4><p>二叉链表存储结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct BiNode&#123;</span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\tstruct BiNode *lchild,*rchild;\t//左右孩子指针</span><br><span class=\"line\">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在n个结点的二叉链表中，必有<font color=\"red\">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color=\"red\">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中</p>\n<p><font color=\"red\">空指针数目= 2n - (n-1) = n +1</font></p>\n<h4 id=\"三叉链表\"><a href=\"#三叉链表\" class=\"headerlink\" title=\"三叉链表\"></a>三叉链表</h4><p>三个指针域：lchild、rchild、parent</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TriTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TriTNode</span> *<span class=\"title\">lchid</span>,*<span class=\"title\">rchild</span>,*<span class=\"title\">parent</span>;</span></span><br><span class=\"line\">&#125;TriTNode,*TriTree;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"遍历二叉树\"><a href=\"#遍历二叉树\" class=\"headerlink\" title=\"遍历二叉树\"></a>遍历二叉树</h3><p><font color=\"red\">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]</p>\n<p><font color=\"red\">遍历目的：</font>得到树中所有结点的一个线性排列</p>\n<p><font color=\"red\">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心</p>\n<h4 id=\"遍历二叉树算法描述\"><a href=\"#遍历二叉树算法描述\" class=\"headerlink\" title=\"遍历二叉树算法描述\"></a>遍历二叉树算法描述</h4><p><strong>遍历方法</strong></p>\n<p>若规定<strong>先左后右</strong>，则只有三种情况：</p>\n<p>DLR - 先序遍历</p>\n<p>LDR - 中序遍历</p>\n<p>LRD - 后序遍历</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">先序遍历二叉树</th>\n<th align=\"center\">中序遍历二叉树</th>\n<th align=\"center\">后序遍历二叉树</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n<td align=\"center\">若二叉树为空，则空操作；否则</td>\n</tr>\n<tr>\n<td align=\"center\">1.访问根结点</td>\n<td align=\"center\">1.中序遍历左子树</td>\n<td align=\"center\">1.后序遍历左子树</td>\n</tr>\n<tr>\n<td align=\"center\">2.先序遍历左子树</td>\n<td align=\"center\">2.访问根结点</td>\n<td align=\"center\">2.后序遍历右子树</td>\n</tr>\n<tr>\n<td align=\"center\">3.先序遍历右子树</td>\n<td align=\"center\">3.中序遍历右子树</td>\n<td align=\"center\">3.访问根结点</td>\n</tr>\n</tbody></table>\n<h4 id=\"根据遍历序列确定二叉树\"><a href=\"#根据遍历序列确定二叉树\" class=\"headerlink\" title=\"根据遍历序列确定二叉树\"></a>根据遍历序列确定二叉树</h4><ul>\n<li>若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的</li>\n<li>由二叉树的<font color=\"red\">先序序列和中序序列</font>，或由二叉树的<font color=\"red\">后序序列和中序序列</font>可以确定唯一一颗二叉树</li>\n</ul>\n<p><strong>已知先序和中序序列求二叉树</strong></p>\n<p>分析：由先序序列确定根，由中序序列确定左右子树</p>\n<p><strong>已知中序和后序序列求二叉树</strong></p>\n<p>分析：由后序序列确定根，由中序序列确定左右子树</p>\n<h4 id=\"遍历的算法实现\"><a href=\"#遍历的算法实现\" class=\"headerlink\" title=\"遍历的算法实现\"></a>遍历的算法实现</h4><h5 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h5><p>存储结构：二叉链表</p>\n<p>方法：递归</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t<span class=\"comment\">//递归后传递进来的就是T-&gt;child的值了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">visit</span>(T);\t<span class=\"comment\">//访问根结点\t例如，输出根结点：cout&lt;&lt;T-&gt;data;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">PreOrderTraverse</span>(T-&gt;lchild);\t<span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">PreOrderTraverse</span>(T-&gt;rchild);\t<span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pre</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t\t<span class=\"comment\">//例子</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;T-&gt;data;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>(T-&gt;rchild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t<span class=\"comment\">//中序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;\t<span class=\"comment\">//后序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">PostOrderTraverse</span>(T.&gt;rchild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">visit</span>(T);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"遍历算法的分析\"><a href=\"#遍历算法的分析\" class=\"headerlink\" title=\"遍历算法的分析\"></a>遍历算法的分析</h4><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。</p>\n<p>第1次经过时访问 = 先序遍历</p>\n<p>第2次经过时访问 = 中序遍历</p>\n<p>第3次经过时访问 = 后序遍历</p>\n<p>时间复杂度O（n）    //每个结点只访问一次</p>\n<p>空间复杂度O（n）    //栈占用的最大辅助空间（都是左子树或者都是右子树）</p>\n<h4 id=\"遍历二叉树的非递归算法\"><a href=\"#遍历二叉树的非递归算法\" class=\"headerlink\" title=\"遍历二叉树的非递归算法\"></a>遍历二叉树的非递归算法</h4><h5 id=\"中序遍历非递归算法\"><a href=\"#中序遍历非递归算法\" class=\"headerlink\" title=\"中序遍历非递归算法\"></a>中序遍历非递归算法</h5><p>关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树</p>\n<p><font color=\"red\">基本思想：</font></p>\n<ol>\n<li>建立一个<font color=\"red\">栈</font></li>\n<li><font color=\"red\">根</font>结点<font color=\"red\">进栈</font>，遍历<font color=\"red\">左子树</font></li>\n<li><font color=\"red\">根</font>结点<font color=\"red\">出栈</font>，输出根结点，遍历<font color=\"red\">右子树</font></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraver</span><span class=\"params\">(BiTree T)</span></span>&#123;\t\t<span class=\"comment\">//T是根结点</span></span><br><span class=\"line\">    BiTree p; <span class=\"built_in\">InitStack</span>(S); p = T;\t<span class=\"comment\">//p是当前要出栈或者入栈的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p||!<span class=\"built_in\">StackEmpty</span>(S))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p) &#123;<span class=\"built_in\">push</span>(S,p); p = p-&gt;lchild;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  &#123;<span class=\"built_in\">pop</span>(S,q); cout&lt;&lt;q-&gt;data; p = q-&gt;rchild;&#125;\t<span class=\"comment\">//q是栈顶元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二叉树的层次遍历\"><a href=\"#二叉树的层次遍历\" class=\"headerlink\" title=\"二叉树的层次遍历\"></a>二叉树的层次遍历</h4><p>对于一颗二叉树，从根结点开始，按<font color=\"red\">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。</p>\n<p>实现的关键：<font color=\"red\">顺序循环队列</font></p>\n<p>队列类型定义如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tBTNode data[MAXSIZE];\t<span class=\"comment\">//存放队中元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front, rear;\t\t<span class=\"comment\">//队头和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n\n<p>层次遍历算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BTNode &amp;b)</span></span>&#123;</span><br><span class=\"line\">\tBTNode *p; SqQueue *qu;\tp = b;</span><br><span class=\"line\">\t<span class=\"built_in\">InitQueue</span>(qu);\t\t\t\t<span class=\"comment\">//初始化队列</span></span><br><span class=\"line\">\t<span class=\"built_in\">enQueue</span>(qu,b);\t\t\t\t<span class=\"comment\">//根结点指针进入队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!<span class=\"built_in\">QueueEmpty</span>(qu))&#123;\t\t<span class=\"comment\">//队不为空，则循环</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">deQueue</span>(qu,p);\t\t\t<span class=\"comment\">//出队结点p（应该是队首元素）</span></span><br><span class=\"line\">\t\tcout&lt;&lt;p-&gt;data;\t\t\t<span class=\"comment\">//访问结点p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>) <span class=\"built_in\">enQueue</span>(qu,p-&gt;lchild);\t<span class=\"comment\">//有左孩子时将其进队</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;rchild !=<span class=\"literal\">NULL</span>) <span class=\"built_in\">enQueue</span>(qu,p-&gt;rchild);\t\t<span class=\"comment\">//有右孩子时将其进队</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"二叉树的建立\"><a href=\"#二叉树的建立\" class=\"headerlink\" title=\"二叉树的建立\"></a>二叉树的建立</h4><p><strong>按先序遍历建立二叉树的二叉链表</strong></p>\n<p>例：ABCDEGF    如果只这么输入，树不是唯一的，所以<font color=\"red\">空结点用其他符号表示</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">CreateBiTree</span><span class=\"params\">(BiTree &amp;T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    cin&gt;&gt;ch;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch == <span class=\"string\">&#x27;#&#x27;</span>) T == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(T = <span class=\"keyword\">new</span> BiTNode)) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">        T-&gt;data = ch;\t\t\t\t<span class=\"comment\">//生成根结点</span></span><br><span class=\"line\">        <span class=\"built_in\">createBiTree</span>(T-&gt;lchild);\t<span class=\"comment\">//构造左子树</span></span><br><span class=\"line\">        <span class=\"built_in\">createBiTree</span>(T-&gt;rchild);\t<span class=\"comment\">//构造右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"复制二叉树\"><a href=\"#复制二叉树\" class=\"headerlink\" title=\"复制二叉树\"></a>复制二叉树</h4><p><strong>先序遍历复制二叉树</strong></p>\n<ul>\n<li>如果是空树，递归结束；</li>\n<li>否则，申请新结点空间，复制根结点<ul>\n<li>递归复制左子树</li>\n<li>递归复制右子树</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Copy</span><span class=\"params\">(BiTree, BiTree &amp;NewT)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(BtTree == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tNewT = <span class=\"literal\">NULL</span>; <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tNewT = <span class=\"keyword\">new</span> BiTNode;\t\t<span class=\"comment\">//内存中申请一块新结点空间</span></span><br><span class=\"line\">\t\tNewT-&gt;data = T-&gt;data;\t<span class=\"comment\">//将data域中的值复制到新结点当中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);\t<span class=\"comment\">//递归复制左子树</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);\t<span class=\"comment\">//递归复制右子树</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树深度\"><a href=\"#计算二叉树深度\" class=\"headerlink\" title=\"计算二叉树深度\"></a>计算二叉树深度</h4><ul>\n<li>如果是空树，深度为0</li>\n<li>否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Depth</span><span class=\"params\">(BiTree)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tm = <span class=\"built_in\">Depth</span>(T-&gt;lchild);</span><br><span class=\"line\">\t\tn = <span class=\"built_in\">Depth</span>(T-&gt;rchild);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> m&gt;n?m+<span class=\"number\">1</span>:n+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树结点总个数\"><a href=\"#计算二叉树结点总个数\" class=\"headerlink\" title=\"计算二叉树结点总个数\"></a>计算二叉树结点总个数</h4><ul>\n<li>如果是空树，则结点个数为0</li>\n<li>否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NodeCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">NodeCount</span>(T-&gt;lchild) + <span class=\"built_in\">NodeCount</span>(T-&gt;rchild) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"计算二叉树叶子结点树\"><a href=\"#计算二叉树叶子结点树\" class=\"headerlink\" title=\"计算二叉树叶子结点树\"></a>计算二叉树叶子结点树</h4><ul>\n<li>如果是空树，叶子结点个数为0</li>\n<li>否则，为左子树的叶子结点树+右子树的叶子结点数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LeafCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lchild == <span class=\"literal\">NULL</span> &amp;&amp; T-&gt;rchild == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//如果是叶子结点返回1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">LeafCount</span>(T-&gt;lchild)+<span class=\"built_in\">LeafCount</span>(T-&gt;rchild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><p><strong>为什么要研究线索二叉树</strong>？</p>\n<p>当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color=\"red\">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font></p>\n<p><strong>如何寻找特定遍历序列中二叉树结点的前驱和后继？</strong></p>\n<p>解决方法：</p>\n<ol>\n<li>通过遍历寻找                        费时间</li>\n<li>添加前驱、后继指针域         费空间</li>\n<li><font color=\"red\">利用二叉链表的空指针域</font></li>\n</ol>\n<p><strong>二叉链表中空指针域的数量</strong></p>\n<p>n个结点的二叉树有2n个指针域，n个结点中有<font color=\"red\">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color=\"red\">n + 1 个指针域为空</font></p>\n<p><strong>利用二叉链表中的空指针域</strong></p>\n<p>如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color=\"red\">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color=\"red\">指向其后继</font></p>\n<p>这种<font color=\"red\">改变指向的指针</font>称为<font color=\"red\">“线索”</font></p>\n<p>加上了线索的二叉树称为<font color=\"red\">线索二叉树</font></p>\n<p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color=\"red\">线索化</font></p>\n<p><strong>区分孩子指针和前驱后继指针</strong></p>\n<p>为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color=\"red\">每个结点增设两个标志域 ltag 和 rtag</font></p>\n<p>ltag = 0    lchild指向该结点的左孩子</p>\n<p>ltag = 1    lchild指向该结点的前驱</p>\n<p>rtag = 0    rchild指向该结点的右孩子</p>\n<p>rtag = 1    rchild指向该结点的后继</p>\n<h4 id=\"结点的结构\"><a href=\"#结点的结构\" class=\"headerlink\" title=\"结点的结构\"></a>结点的结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ltag,rtag;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"增加一个头结点\"><a href=\"#增加一个头结点\" class=\"headerlink\" title=\"增加一个头结点\"></a><strong>增加一个头结点</strong></h4><p>为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点</p>\n<p>ltag=0，lchild指向根结点</p>\n<p>rtag=1，rchild指向遍历序列中的最后一个结点</p>\n<p>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</p>\n<h3 id=\"树和森林\"><a href=\"#树和森林\" class=\"headerlink\" title=\"树和森林\"></a>树和森林</h3><h4 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h4><h5 id=\"1-双亲表示法\"><a href=\"#1-双亲表示法\" class=\"headerlink\" title=\"1.双亲表示法\"></a>1.双亲表示法</h5><p>实现：定义数据结构，每个结点含两个域</p>\n<p>数据域：存放结点本身信息</p>\n<p>双亲域：指示本结点的双亲结点在数组中的位置</p>\n<p>r = 0  根结点位置    n = 10 结点数，方便定义数组</p>\n<p>特点：找双亲容易，找孩子难</p>\n<p><strong>结点的类型定义</strong></p>\n<p>结点结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PTNode</span>&#123;</span></span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> parent;</span><br><span class=\"line\">&#125;PTNode;</span><br></pre></td></tr></table></figure>\n\n<p>树结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_TREE_SIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tPTNode nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r,n;</span><br><span class=\"line\">&#125;PTree;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2-孩子链表\"><a href=\"#2-孩子链表\" class=\"headerlink\" title=\"2.孩子链表\"></a>2.孩子链表</h5><p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。</p>\n<p>则n个结点有n个孩子链表（叶子的孩子链表为空表）。</p>\n<p>而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p>\n<p>特点：找孩子容易，找双亲难</p>\n<p><strong>类型定义</strong></p>\n<p>孩子结点结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> child;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;*ChildPtr;</span><br></pre></td></tr></table></figure>\n\n<p>双亲结点结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tTElemType data;</span><br><span class=\"line\">\tChildPtr firstchild;\t<span class=\"comment\">//孩子链表头指针</span></span><br><span class=\"line\">&#125;CTBox;</span><br></pre></td></tr></table></figure>\n\n<p>树结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tCTBox nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,r;\t<span class=\"comment\">//结点数和根结点的位置</span></span><br><span class=\"line\">&#125;CTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color=\"red\">带双亲的孩子链表。</font></p>\n<h5 id=\"3-孩子兄弟表示法\"><a href=\"#3-孩子兄弟表示法\" class=\"headerlink\" title=\"3.孩子兄弟表示法\"></a>3.孩子兄弟表示法</h5><p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color=\"red\">第一个孩子结点</font>和<font color=\"red\">下一个兄弟结点</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typdedef <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span> *<span class=\"title\">firstchild</span>,*<span class=\"title\">nextsibling</span>;</span></span><br><span class=\"line\">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>\n\n<p>特点：查找孩子容易，查找双亲难</p>\n<h4 id=\"树与二叉树的转换\"><a href=\"#树与二叉树的转换\" class=\"headerlink\" title=\"树与二叉树的转换\"></a>树与二叉树的转换</h4><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作</p>\n<p>由于树和二叉树都可以用二叉链表作存储结构，则<font color=\"red\">以二叉链表作媒介</font>可以导出树与二叉树之间的一个对应关系</p>\n<p><font color=\"red\">给定一颗树，可以找到唯一的一棵二叉树与之对应</font></p>\n<p><strong>将树转换成二叉树</strong></p>\n<p>1.加线：在兄弟之间加一条线</p>\n<p>2.抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>\n<p>3.旋转：以树的根结点为轴心，将整树顺时针转45°</p>\n<p><strong>将二叉树转换成树</strong></p>\n<p>1.加线：若p结点是双亲结点的左孩子，则将p的有孩子，有孩子的有孩子……延分支找到所有的右孩子，都与p的双亲用线连起来</p>\n<p>2.抹线：抹掉原二叉树中双亲与右孩子之间的连线</p>\n<p>3.调整：将结点按层次排列，形成树结构</p>\n<h4 id=\"森林与二叉树的转化\"><a href=\"#森林与二叉树的转化\" class=\"headerlink\" title=\"森林与二叉树的转化\"></a>森林与二叉树的转化</h4><p><strong>森林转化成二叉树</strong></p>\n<p>1.将各棵树分别转换成二叉树</p>\n<p>2.将每棵树的根节点用线相连</p>\n<p>3.以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>\n<p><strong>二叉树转化成森林</strong></p>\n<p>1.抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子建连线全部抹掉，使之变成孤立的二叉树</p>\n<p>2.还原：将孤立的二叉树还原成树</p>\n<h4 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h4><p><strong>1.树的遍历（三种方式）</strong>         【二叉树的遍历有四种方式：先根、中根、后根、层次】</p>\n<ul>\n<li><p>先根遍历：</p>\n<p>若树不空，则先访问根结点，然后依次先根遍历各棵子树</p>\n</li>\n<li><p>后根遍历：</p>\n<p>若树不空，则先依次后根遍历各棵子树，然后访问根结点</p>\n</li>\n<li><p>参差遍历：</p>\n<p>若树不空，则自上而下从左至右访问树中每个结点 </p>\n</li>\n</ul>\n<p><strong>2.森林的遍历</strong></p>\n<p>将森林看做有三部分构成：</p>\n<p>1.森林中第一棵树的根结点；</p>\n<p>2.森林中第一棵树的子树森林；</p>\n<p>3.森林中其他树构成的森林</p>\n<p><strong>先序遍历：</strong></p>\n<p>若森林不空，则</p>\n<p>1.访问森林中第一棵树的根结点；</p>\n<p>2.先序遍历森林中第一棵树的子树森林；</p>\n<p>3.先序遍历森林中（除第一棵树之外）其余树构成的森林</p>\n<p><font color=\"red\">即：依次从左至右对森林中每一棵树进行先根遍历</font></p>\n<p><font color=\"red\">还有一种很简单的方法：即对森林中每一棵树依次进行先序遍历</font></p>\n<p><strong>中序遍历：</strong></p>\n<p>若森林不空，则</p>\n<p>1.中序遍历森里中第一棵树的子树森林；</p>\n<p>2.访问森林中第一棵树的根结点；</p>\n<p>3.中序遍历森林中（除第一棵树之外）其余树构成的森林</p>\n<p><font color=\"red\">即：依次从左至右对森林中每一棵树进行中序遍历</font></p>\n<h3 id=\"哈夫曼树及应用\"><a href=\"#哈夫曼树及应用\" class=\"headerlink\" title=\"哈夫曼树及应用\"></a>哈夫曼树及应用</h3><h4 id=\"哈夫曼树的基本概念\"><a href=\"#哈夫曼树的基本概念\" class=\"headerlink\" title=\"哈夫曼树的基本概念\"></a>哈夫曼树的基本概念</h4><p><font color=\"red\">判断树：</font>用于描述分类过程的二叉树</p>\n<p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径</p>\n<p>路径的长度：两结点间路径上的分支数</p>\n<p>树的路径长度：从<font color=\"red\">树根</font>到每一个结点的<font color=\"red\">路径长度之和</font>。记作：TL</p>\n<p><font color=\"red\">结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>路径长度最短的不一定是二叉树。</p>\n<p>权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<font color=\"red\">结点的权</font></p>\n<p>结点的带权路径长度：从<font color=\"red\">根结点</font>到该结点之间的<font color=\"red\">路径长度</font>与该结点的<font color=\"red\">权</font>的<font color=\"red\">乘积</font></p>\n<p>树的带权路径长度：树中所有<font color=\"red\">叶子</font>结点的<font color=\"red\">带权路径长度</font>。记作：WPL (Weighted Path Length)</p>\n<p>哈夫曼树：<font color=\"red\">最优树</font> 即带权路径长度最短的树</p>\n<p>“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。</p>\n<p>哈夫曼树：<font color=\"red\">最优二叉树</font> 带权路径长度最短的二叉树</p>\n<p>相应的算法称为哈夫曼算法</p>\n<p>特点：</p>\n<p>满二叉树不一定是哈夫曼树</p>\n<p>哈夫曼树中权越大的叶子离根越近</p>\n<p>具有相同带权结点的哈夫曼树不唯一</p>\n<h4 id=\"哈夫曼树的构造算法\"><a href=\"#哈夫曼树的构造算法\" class=\"headerlink\" title=\"哈夫曼树的构造算法\"></a>哈夫曼树的构造算法</h4><p>贪心算法：构造哈夫曼树时首先选择权值小的叶子结点</p>\n<p><font color=\"red\">哈夫曼算法</font></p>\n<p>1.根据n个给定的权值{w<del>1</del>,w<del>2</del>,…,w<del>n</del>}构成n棵二叉树的森林F={T<del>1</del>,T<del>2</del>,…,T<del>n</del>},其中T<del>i</del>只有一个带权为w<del>i</del>的根结点</p>\n<p><font color=\"red\">构造森林全是根</font></p>\n<p>2.在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右字数上根结点的权值之和</p>\n<p><font color=\"red\">选用两小造新树</font></p>\n<p>3.在F中删除这两棵树，同时将新得到的二叉树加入森林中</p>\n<p><font color=\"red\">删除两小添新人</font></p>\n<p>4.重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树</p>\n<p><font color=\"red\">重复2、3剩单根</font></p>\n<p>哈夫曼树的结点度数为0或2，没有度为1的结点</p>\n<p>包含n个叶子结点的哈夫曼树中共有2n-1个结点</p>\n<p>（包含n棵树的森林要经过n-1次和并才能形成哈夫曼树，共产生n-1个新结点）</p>\n<p><strong>总结：</strong></p>\n<p>1.在哈夫曼算法中，初始时有n棵二叉树，要经过<font color=\"red\">n-1</font>次合并最终形成哈夫曼树</p>\n<p>2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支节点</p>\n<p>可见：哈夫曼树中共有 n+n-1 =  <font color=\"red\">2n-1</font>个结点，且其所有的分支结点的度均不为1</p>\n<h4 id=\"哈夫曼树构造算法的实现\"><a href=\"#哈夫曼树构造算法的实现\" class=\"headerlink\" title=\"哈夫曼树构造算法的实现\"></a>哈夫曼树构造算法的实现</h4><p>采用顺序存储结构————一维结构数组</p>\n<p>结点类型定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> parent,lch,rch;</span><br><span class=\"line\">&#125;HTNode,*Huffman Tree;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">哈夫曼树中结点下标i</th>\n<th align=\"center\">weight</th>\n<th align=\"center\">parent</th>\n<th align=\"center\">lch</th>\n<th align=\"center\">rch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2n-1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>哈夫曼树中共有2n-1个结点，不使用0下标，数组大小为2n</p>\n<p>步骤：</p>\n<p>1.初始化<font color=\"red\">HT[1……2n-1]</font> : lch = rch = parent = 0;</p>\n<p>2.输入初始<font color=\"red\">n个叶子结点</font>：置HT[1……n]的<font color=\"red\">weight值</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateHuffmanTree</span><span class=\"params\">(HuffmanTree HT,<span class=\"keyword\">int</span> n)</span></span>&#123; <span class=\"comment\">//构造哈夫曼树--哈夫曼算法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tm = <span class=\"number\">2</span>*n - <span class=\"number\">1</span>;\t<span class=\"comment\">//数组共2n-1个元素</span></span><br><span class=\"line\">\tHT = <span class=\"keyword\">new</span> HTNode[m+<span class=\"number\">1</span>];\t<span class=\"comment\">//0号单元未用，HT[m]表示根结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tHT[i].lch = <span class=\"number\">0</span>;HT[i].rch = <span class=\"number\">0</span>;HT[i].parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n,++i) cin&gt;&gt;HT[i].weight;\t<span class=\"comment\">//输入前n个元素的weight值</span></span><br><span class=\"line\">\t<span class=\"comment\">//初始化结束，下面开始建立哈夫曼树</span></span><br><span class=\"line\">续</span><br></pre></td></tr></table></figure>\n\n<p>3.<font color=\"red\">进行以下n-1次合并，</font>依次产生n-1个结点HT[i], i=<font color=\"red\">n+1</font>…..2n-1;</p>\n<pre><code> a.在HT[1…i-1]中选两个&lt;font color=&quot;red&quot;&gt;未被选过&lt;/font&gt;（从parent==0的结点中选）的weight最小的两个结        点&lt;font color=&quot;red&quot;&gt;HT[s1]&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;HT[s2]&lt;/font&gt;,&lt;font color=&quot;red&quot;&gt;s1、s2为两个最小结点下标&lt;/font&gt;\n</code></pre>\n<p>​    b.修改HT[s1]和HT[s2]的parent值：HT[s1].parent = i; HT[s2].parent = i;</p>\n<p>​    c.修改新产生的HT[i]：</p>\n<p>​        HT[i].weight = HT[s1].weight + HT[s2].weight;</p>\n<p>​        HT[i].lch = s1; HT[i].rch = s2;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">续</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=n+<span class=\"number\">1</span>;i&lt;=m;i++)&#123;\t\t<span class=\"comment\">//合并产生n-1个结点--构造Huffman树</span></span><br><span class=\"line\">\t<span class=\"built_in\">Select</span>(HT,i<span class=\"number\">-1</span>,s1,s2);\t<span class=\"comment\">//在HT[k](1&lt;=k&lt;=i-1)中选择两个其双亲域为0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class=\"line\">\tHT[s1].parent = i; HT[s2].parent = i;\t<span class=\"comment\">//表示从F中删除s1,s2</span></span><br><span class=\"line\">    HT[i].lch = s1; HT[i].rch = s2;\t\t\t<span class=\"comment\">//s1，s2分别作为i的左右孩子</span></span><br><span class=\"line\">    HT[i].weight = HT[s1].weight+HT[s2].weight;<span class=\"comment\">//i的权值为左右孩子权值之和</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h4><p>在远程通讯中，要将待传字符转换成由二进制的字符串</p>\n<p>若将编码设计为长度不等的二进制编码，即让待传字符串中<font color=\"red\">出现次数较多的字符采用尽可能短的编码，</font>则转换的二进制字符串便可能减少</p>\n<p><font color=\"red\">关键：</font>要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀</p>\n<p>这种编码称作<font color=\"red\">前缀编码</font></p>\n<p>问题：什么样的前缀码能使电文总长最短  —-<font color=\"red\">哈弗曼编码</font></p>\n<p>1.<font color=\"red\">统计</font>字符集中<font color=\"red\">每个字符</font>在电文中<font color=\"red\">出现的</font>平均<font color=\"red\">概率</font>（概率越大，要求编码越短）。</p>\n<p>2.利用哈夫曼树的特点：权越大的叶子离根越近；<font color=\"red\">将每个字符的概率值作为权值，构造哈夫曼树。</font>则概率越大的结点，路径越短。</p>\n<p>3.在哈夫曼树的每个分支上标上0或1：</p>\n<p>​    结点的<font color=\"red\">左分支标0，右分支标1</font></p>\n<p>​    把根到每个叶子的路径上的标号连接起来，作为该叶子代表的<font color=\"red\">字符的编码</font></p>\n<p><strong>为什么哈弗曼编码能够保证是前缀编码？</strong></p>\n<p>因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀</p>\n<p><strong>为什么哈弗曼编码能够保证字符编码总长最短</strong></p>\n<p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短</p>\n<p><font color=\"red\">哈夫曼编码的两个性质</font></p>\n<p>1.哈弗曼编码是前缀码</p>\n<p>2.哈夫曼编码是最优前缀码</p>\n<h4 id=\"哈夫曼编码的算法实现\"><a href=\"#哈夫曼编码的算法实现\" class=\"headerlink\" title=\"哈夫曼编码的算法实现\"></a>哈夫曼编码的算法实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateHuffmanCode</span><span class=\"params\">(Huffman Tree HT,HuffmanCode &amp;HC,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//从叶子到根逆向求每个字符的哈弗曼编码，存储在编码表HC中</span></span><br><span class=\"line\">\tHC = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span> *[n+<span class=\"number\">1</span>];\t<span class=\"comment\">//分配n个字符编码的头指针矢量</span></span><br><span class=\"line\">\tcd = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[n];\t\t<span class=\"comment\">//分配临时存放编码的动态数组空间</span></span><br><span class=\"line\">\tcd[n<span class=\"number\">-1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;\t\t\t<span class=\"comment\">//编码结束符 （字符串结束符）</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tstart=n<span class=\"number\">-1</span>;c=i;f=Ht[i].parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(f!=<span class=\"number\">0</span>)&#123;\t<span class=\"comment\">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class=\"line\">\t\t\t--start;\t<span class=\"comment\">//回溯一次start向前指一个位置</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(HT[f].lchild == c) cd[start]=<span class=\"string\">&#x27;0&#x27;</span>; <span class=\"comment\">//结点c是f的左孩子，0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cd[start]=<span class=\"string\">&#x27;1&#x27;</span>;\t\t\t\t\t <span class=\"comment\">//结点c是f的右孩子，1</span></span><br><span class=\"line\">\t\t\tc = f; f = HT[f].parent;\t\t\t <span class=\"comment\">//继续向上回溯</span></span><br><span class=\"line\">\t\t&#125;\t<span class=\"comment\">//求出第i个字符的编码</span></span><br><span class=\"line\">\t\tHC[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[n-start];\t\t<span class=\"comment\">//为第i个字符串编码分配空间大小是</span></span><br><span class=\"line\">        \t\t\t\t\t\t\t\t<span class=\"comment\">// n-start 已占用的空间量</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(HC[i],&amp;cd[start]);\t\t<span class=\"comment\">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> cd;\t<span class=\"comment\">//释放临时空间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"文件的编码和解码\"><a href=\"#文件的编码和解码\" class=\"headerlink\" title=\"文件的编码和解码\"></a>文件的编码和解码</h4><p><strong>编码</strong></p>\n<p>1.输入各字符及其权值</p>\n<p>2.构造哈夫曼树–HT[i]</p>\n<p>3.进行哈夫曼编码–HC[i]</p>\n<p>4.查HC[i]，得到各字符的哈弗曼编码</p>\n<p><strong>解码</strong></p>\n<p>1.构造哈夫曼树</p>\n<p>2.依次读入二进制码</p>\n<p>3.读入0，则走向左孩子；读入1，则走向右孩子</p>\n<p>4.一旦达到某叶子时，即可译出字符</p>\n<p>5.然后再从根出发继续译码，直到结束</p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"图的定义和基本术语\"><a href=\"#图的定义和基本术语\" class=\"headerlink\" title=\"图的定义和基本术语\"></a>图的定义和基本术语</h3><p>图：G=(V,E)                Graph = （Vertex , Edge)</p>\n<p>​        V：顶点（数据元素）的有穷非空集合；</p>\n<p>​        E：边的有穷集合</p>\n<p>无向图：每条边都是无方向的</p>\n<p>有向图：每条边都是有方向的</p>\n<p>完全图：任意两个点都有一条边相连（无向完全图和有向完全图，其中有向完全图要两个方向都有边）</p>\n<p>无向完全图：<font color=\"red\">n个顶点，n(n-1)/2条边</font></p>\n<p>有向完全图：<font color=\"red\">n个顶点，n(n-1)条边</font></p>\n<p>稀疏图：有很少边或弧的图（e &lt; nlog<del>n</del>）</p>\n<p>稠密图：有较多边或弧的图</p>\n<p>网：边/弧带权的图</p>\n<p>邻接：有边/弧相连的两个顶点之间的关系</p>\n<p>​            存在（v<del>i</del> , v<del>j</del>）, 则称v<del>i</del> 和 v<del>j</del>互为邻接点</p>\n<p>​            存在 &lt;v<del>i</del> , v<del>j</del>&gt; , 则称 v<del>i</del> 邻接到 v<del>j</del> ，v<del>j</del> 邻接于 v<del>i</del> </p>\n<p>​            圆括号表示无向图，尖括号表示有向图，从前面到后面</p>\n<p>关联（依附）：边/弧与顶点之间的关系</p>\n<p>​                            存在（v<del>i</del> , v<del>j</del>） / &lt;v<del>i</del> , v<del>j</del>&gt; , 则称该边/弧关联于v<del>i</del> 和v<del>j</del></p>\n<p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p>\n<p>​                    在<font color=\"red\">有向图</font>中，顶点的度等于该顶点的<font color=\"red\">入度</font>和<font color=\"red\">出度</font>之和</p>\n<p>​                    顶点<font color=\"red\">v的入度</font>是以v为终点的有向边的条数，记作ID(v)</p>\n<p>​                    顶点<font color=\"red\">v的出度</font>是以v为始点的有向边的条数，记作OD(v)</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cku3k7flh000180u6hsgngket","category_id":"cku3k7fll000480u62c5dhdw1","_id":"cku3k7flu000i80u66o39g8j3"},{"post_id":"cku3k7flk000380u6akkdc6u7","category_id":"cku3k7flr000c80u66hmbaxg2","_id":"cku3k7flx000p80u61y7ihgsg"},{"post_id":"cku3k7flu000g80u6esz34spy","category_id":"cku3k7fll000480u62c5dhdw1","_id":"cku3k7flz000t80u68e3x5oeg"},{"post_id":"cku3k7flv000m80u63y0edp2v","category_id":"cku3k7fll000480u62c5dhdw1","_id":"cku3k7fm0000v80u63pw6haql"},{"post_id":"cku3k7flo000880u64nhyalic","category_id":"cku3k7flv000j80u62jsed9wa","_id":"cku3k7fm1000y80u6f83kclg4"},{"post_id":"cku3k7flq000b80u62pqt55kt","category_id":"cku3k7flv000j80u62jsed9wa","_id":"cku3k7fm2001080u6a4cd2zzr"},{"post_id":"cku3k7flx000o80u6ac03c4ln","category_id":"cku3k7fm0000w80u6hbg3eqe0","_id":"cku3k7fm3001380u67bz64qx5"},{"post_id":"cku3k7fm2000z80u64p63a3ds","category_id":"cku3k7flv000j80u62jsed9wa","_id":"cku3k7fm3001580u64dt71yss"},{"post_id":"cku3k7fly000r80u6b2yg5i5c","category_id":"cku3k7fm2001180u6fo6rckhd","_id":"cku3k7fm4001780u666st9dvi"},{"post_id":"cku3k7fm1000x80u6e6kb95c1","category_id":"cku3k7fm3001480u6b36qfx83","_id":"cku3k7fm4001880u62ocwdy73"}],"PostTag":[{"post_id":"cku3k7fln000680u678gtc64n","tag_id":"cku3k7flp000980u6h5ecap7u","_id":"cku3k7flv000k80u6aoxkcpno"},{"post_id":"cku3k7flo000880u64nhyalic","tag_id":"cku3k7flu000h80u6atqz5c65","_id":"cku3k7flz000s80u606mh1ca4"},{"post_id":"cku3k7fm2000z80u64p63a3ds","tag_id":"cku3k7fm3001280u62bpt3stj","_id":"cku3k7fm4001680u6cf9haucv"}],"Tag":[{"name":"唱歌","_id":"cku3k7flp000980u6h5ecap7u"},{"name":"C++","_id":"cku3k7flu000h80u6atqz5c65"},{"name":"数据结构","_id":"cku3k7fm3001280u62bpt3stj"}]}}